/* testsmsstorage.c generated by valac 0.14.2, the Vala compiler
 * generated from testsmsstorage.vala, do not modify */

/*
 * Copyright (C) 2009-2011 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <fsogsm.h>
#include <stdlib.h>
#include <string.h>
#include <smsutil.h>
#include <conversions.h>
#include <util.h>
#include <gee.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _sms_free0(var) ((var == NULL) ? NULL : (var = (sms_free (var), NULL)))
#define _wrap_hex_pdu_unref0(var) ((var == NULL) ? NULL : (var = (wrap_hex_pdu_unref (var), NULL)))



void test_fso_sms_storage_new (void);
#define IMSI "26203123456789"
void test_fso_sms_storage_add_single (void);
#define pdu3 "0791947106004034040C9194713900303341009001910002108059D6B75B076A86D36C" \
"F11BEF024DD365103A2C2EBB413290BB5C2F839CE1315A9E1EA3E96537C805D2D6DBA0" \
"A0585E3797DDA0FB1ECD2EBB41D37419244ED3E965906845CBC56EB9190C069BCD6622"
#define pdulength3 97
void test_fso_sms_storage_add_concatenated (void);
void test_fso_sms_storage_store_transaction_index (void);
#define PHONE_NUMBER "+49123456789"
#define LONG_TEXT "freesmartphone.org is a collaboration platform for open source and ope" \
"n discussion software projects working on interoperability and shared " \
"technology for Linux-based SmartPhones. freesmartphone.org works on a " \
"service layer (middleware) that allows developers to concentrate on th" \
"eir application business logic rather than dealing with device specifi" \
"cs. freesmartphone.org honours and bases on specifications and softwar" \
"e created by the freedesktop.org community."
void test_fso_sms_storage_confirm_ack (void);
void _vala_main (gchar** args, int args_length1);
static void _test_fso_sms_storage_new_gcallback (void);
static void _test_fso_sms_storage_add_single_gcallback (void);
static void _test_fso_sms_storage_add_concatenated_gcallback (void);
static void _test_fso_sms_storage_store_transaction_index_gcallback (void);
static void _test_fso_sms_storage_confirm_ack_gcallback (void);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

extern const gint pdulengths1[11];
extern const gchar* pdus1[11];

void test_fso_sms_storage_new (void) {
	FsoGsmISmsStorage* _tmp0_ = NULL;
	FsoGsmISmsStorage* storage;
	_tmp0_ = fso_gsm_sms_storage_factory_create ("default", IMSI);
	storage = _tmp0_;
	_g_object_unref0 (storage);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static struct sms* sms_newFromHexPdu (const gchar* hexpdu, gint tpdulen) {
	struct sms* result = NULL;
	glong items_written;
	gchar* _tmp0_ = NULL;
	gchar* binpdu;
	gint binpdu_length1;
	gint _binpdu_size_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gint _tmp2__length1;
	glong _tmp3_ = 0L;
	glong _tmp4_;
	struct sms* _tmp5_;
	struct sms* sms;
	gchar* _tmp6_;
	gint _tmp6__length1;
	gint _tmp7_;
	struct sms* _tmp8_;
	gboolean _tmp9_ = FALSE;
	gboolean res;
	gboolean _tmp10_;
	g_return_val_if_fail (hexpdu != NULL, NULL);
	items_written = (glong) (-1);
	_tmp0_ = g_new0 (gchar, 1024);
	binpdu = _tmp0_;
	binpdu_length1 = 1024;
	_binpdu_size_ = binpdu_length1;
	_tmp1_ = hexpdu;
	_tmp2_ = binpdu;
	_tmp2__length1 = binpdu_length1;
	decode_hex_own_buf (_tmp1_, (glong) (-1), &_tmp3_, (gchar) 0, _tmp2_);
	items_written = _tmp3_;
	_tmp4_ = items_written;
	g_assert (_tmp4_ != ((glong) (-1)));
	_tmp5_ = sms_new ();
	sms = _tmp5_;
	_tmp6_ = binpdu;
	_tmp6__length1 = binpdu_length1;
	_tmp7_ = tpdulen;
	_tmp8_ = sms;
	_tmp9_ = sms_decode (_tmp6_, _tmp6__length1, FALSE, _tmp7_, _tmp8_);
	res = _tmp9_;
	_tmp10_ = res;
	if (!_tmp10_) {
		gint _tmp11_;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_;
		const gchar* _tmp14_;
		const gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		_tmp11_ = tpdulen;
		_tmp12_ = g_strdup_printf ("%i", _tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = hexpdu;
		_tmp15_ = string_to_string (_tmp14_);
		_tmp16_ = g_strconcat ("Sms.Message::newFromHexPdu: could not decode message w/ tpdulen ", _tmp13_, " and hexpdu ", _tmp15_, NULL);
		_tmp17_ = _tmp16_;
		g_warning ("fsogsm3rdparty.vapi:602: %s", _tmp17_);
		_g_free0 (_tmp17_);
		_g_free0 (_tmp13_);
		result = NULL;
		_sms_free0 (sms);
		binpdu = (g_free (binpdu), NULL);
		return result;
	} else {
		result = sms;
		binpdu = (g_free (binpdu), NULL);
		return result;
	}
	_sms_free0 (sms);
	binpdu = (g_free (binpdu), NULL);
}


void test_fso_sms_storage_add_single (void) {
	FsoGsmISmsStorage* _tmp0_ = NULL;
	FsoGsmISmsStorage* storage;
	struct sms* _tmp1_ = NULL;
	struct sms* sms;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	_tmp0_ = fso_gsm_sms_storage_factory_create ("default", IMSI);
	storage = _tmp0_;
	fso_gsm_isms_storage_clean (storage);
	_tmp1_ = sms_newFromHexPdu (pdu3, pdulength3);
	sms = _tmp1_;
	g_assert (sms != NULL);
	_tmp2_ = fso_gsm_isms_storage_addSms (storage, sms);
	g_assert (_tmp2_ == FSO_GSM_SMS_STORAGE_SMS_SINGLE_COMPLETE);
	_tmp3_ = fso_gsm_isms_storage_addSms (storage, sms);
	g_assert (_tmp3_ == FSO_GSM_SMS_STORAGE_SMS_ALREADY_SEEN);
	_sms_free0 (sms);
	_g_object_unref0 (storage);
}


void test_fso_sms_storage_add_concatenated (void) {
	FsoGsmISmsStorage* _tmp0_ = NULL;
	FsoGsmISmsStorage* storage;
	FsoGsmISmsStorage* _tmp1_;
	struct sms** _tmp2_ = NULL;
	struct sms** smses;
	gint smses_length1;
	gint _smses_size_;
	FsoGsmISmsStorage* _tmp24_;
	struct sms** _tmp25_;
	gint _tmp25__length1;
	struct sms* _tmp26_;
	gint _tmp27_ = 0;
	_tmp0_ = fso_gsm_sms_storage_factory_create ("default", IMSI);
	storage = _tmp0_;
	_tmp1_ = storage;
	fso_gsm_isms_storage_clean (_tmp1_);
	_tmp2_ = g_new0 (struct sms*, G_N_ELEMENTS (pdulengths1) + 1);
	smses = _tmp2_;
	smses_length1 = G_N_ELEMENTS (pdulengths1);
	_smses_size_ = smses_length1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				gint _tmp6_;
				struct sms** _tmp7_;
				gint _tmp7__length1;
				gint _tmp8_;
				gint _tmp9_;
				const gchar* _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				struct sms* _tmp13_ = NULL;
				struct sms* _tmp14_;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = i;
				if (!(_tmp6_ < G_N_ELEMENTS (pdulengths1))) {
					break;
				}
				_tmp7_ = smses;
				_tmp7__length1 = smses_length1;
				_tmp8_ = i;
				_tmp9_ = i;
				_tmp10_ = pdus1[_tmp9_];
				_tmp11_ = i;
				_tmp12_ = pdulengths1[_tmp11_];
				_tmp13_ = sms_newFromHexPdu (_tmp10_, _tmp12_);
				_sms_free0 (_tmp7_[_tmp8_]);
				_tmp7_[_tmp8_] = _tmp13_;
				_tmp14_ = _tmp7_[_tmp8_];
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp15_;
			_tmp15_ = TRUE;
			while (TRUE) {
				gboolean _tmp16_;
				gint _tmp18_;
				FsoGsmISmsStorage* _tmp19_;
				struct sms** _tmp20_;
				gint _tmp20__length1;
				gint _tmp21_;
				struct sms* _tmp22_;
				gint _tmp23_ = 0;
				_tmp16_ = _tmp15_;
				if (!_tmp16_) {
					gint _tmp17_;
					_tmp17_ = i;
					i = _tmp17_ + 1;
				}
				_tmp15_ = FALSE;
				_tmp18_ = i;
				if (!(_tmp18_ < (G_N_ELEMENTS (pdulengths1) - 1))) {
					break;
				}
				_tmp19_ = storage;
				_tmp20_ = smses;
				_tmp20__length1 = smses_length1;
				_tmp21_ = i;
				_tmp22_ = _tmp20_[_tmp21_];
				_tmp23_ = fso_gsm_isms_storage_addSms (_tmp19_, _tmp22_);
				g_assert (_tmp23_ == FSO_GSM_SMS_STORAGE_SMS_MULTI_INCOMPLETE);
			}
		}
	}
	_tmp24_ = storage;
	_tmp25_ = smses;
	_tmp25__length1 = smses_length1;
	_tmp26_ = _tmp25_[G_N_ELEMENTS (pdulengths1) - 1];
	_tmp27_ = fso_gsm_isms_storage_addSms (_tmp24_, _tmp26_);
	g_assert (_tmp27_ == G_N_ELEMENTS (pdulengths1));
	smses = (_vala_array_free (smses, smses_length1, (GDestroyNotify) sms_free), NULL);
	_g_object_unref0 (storage);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void test_fso_sms_storage_store_transaction_index (void) {
	FsoGsmAtSmsHandler* _tmp0_;
	FsoGsmAtSmsHandler* handler;
	FsoGsmAtSmsHandler* _tmp1_;
	FsoGsmISmsStorage* _tmp2_ = NULL;
	FsoGsmISmsStorage* _tmp3_;
	FsoGsmAtSmsHandler* _tmp4_;
	GeeArrayList* _tmp5_ = NULL;
	GeeArrayList* pdus;
	gint i;
	FsoGsmAtSmsHandler* _tmp20_;
	GeeArrayList* _tmp21_;
	_tmp0_ = fso_gsm_at_sms_handler_new ();
	handler = _tmp0_;
	_tmp1_ = handler;
	_tmp2_ = fso_gsm_sms_storage_factory_create ("default", IMSI);
	_tmp3_ = _tmp2_;
	fso_gsm_sms_handler_set_storage ((FsoGsmSmsHandler*) _tmp1_, _tmp3_);
	_g_object_unref0 (_tmp3_);
	_tmp4_ = handler;
	_tmp5_ = fso_gsm_sms_handler_formatTextMessage ((FsoGsmSmsHandler*) _tmp4_, PHONE_NUMBER, LONG_TEXT, TRUE);
	pdus = _tmp5_;
	i = 0;
	{
		GeeArrayList* _tmp6_;
		GeeArrayList* _tmp7_;
		GeeArrayList* _pdu_list;
		GeeArrayList* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		gint _pdu_size;
		gint _pdu_index;
		_tmp6_ = pdus;
		_tmp7_ = _g_object_ref0 (_tmp6_);
		_pdu_list = _tmp7_;
		_tmp8_ = _pdu_list;
		_tmp9_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp8_);
		_tmp10_ = _tmp9_;
		_pdu_size = _tmp10_;
		_pdu_index = -1;
		while (TRUE) {
			gint _tmp11_;
			gint _tmp12_;
			gint _tmp13_;
			GeeArrayList* _tmp14_;
			gint _tmp15_;
			gpointer _tmp16_ = NULL;
			WrapHexPdu* pdu;
			WrapHexPdu* _tmp17_;
			gint _tmp18_;
			gint _tmp19_;
			_tmp11_ = _pdu_index;
			_pdu_index = _tmp11_ + 1;
			_tmp12_ = _pdu_index;
			_tmp13_ = _pdu_size;
			if (!(_tmp12_ < _tmp13_)) {
				break;
			}
			_tmp14_ = _pdu_list;
			_tmp15_ = _pdu_index;
			_tmp16_ = gee_abstract_list_get ((GeeAbstractList*) _tmp14_, _tmp15_);
			pdu = (WrapHexPdu*) _tmp16_;
			_tmp17_ = pdu;
			_tmp18_ = i;
			i = _tmp18_ + 1;
			_tmp19_ = i;
			_tmp17_->transaction_index = _tmp19_;
			_wrap_hex_pdu_unref0 (pdu);
		}
		_g_object_unref0 (_pdu_list);
	}
	_tmp20_ = handler;
	_tmp21_ = pdus;
	fso_gsm_sms_handler_storeTransactionIndizesForSentMessage ((FsoGsmSmsHandler*) _tmp20_, _tmp21_);
	_g_object_unref0 (pdus);
	_g_object_unref0 (handler);
}


void test_fso_sms_storage_confirm_ack (void) {
	FsoGsmAtSmsHandler* _tmp0_;
	FsoGsmAtSmsHandler* handler;
	FsoGsmISmsStorage* _tmp1_ = NULL;
	FsoGsmISmsStorage* _tmp2_;
	FsoGsmISmsStorage* _tmp3_;
	FsoGsmISmsStorage* _tmp4_;
	gint _tmp5_ = 0;
	FsoGsmISmsStorage* _tmp6_;
	FsoGsmISmsStorage* _tmp7_;
	gint _tmp8_ = 0;
	FsoGsmISmsStorage* _tmp9_;
	FsoGsmISmsStorage* _tmp10_;
	gint _tmp11_ = 0;
	FsoGsmISmsStorage* _tmp12_;
	FsoGsmISmsStorage* _tmp13_;
	gint _tmp14_ = 0;
	_tmp0_ = fso_gsm_at_sms_handler_new ();
	handler = _tmp0_;
	_tmp1_ = fso_gsm_sms_storage_factory_create ("default", IMSI);
	_tmp2_ = _tmp1_;
	fso_gsm_sms_handler_set_storage ((FsoGsmSmsHandler*) handler, _tmp2_);
	_g_object_unref0 (_tmp2_);
	_tmp3_ = fso_gsm_sms_handler_get_storage ((FsoGsmSmsHandler*) handler);
	_tmp4_ = _tmp3_;
	_tmp5_ = fso_gsm_isms_storage_confirmReceivedMessage (_tmp4_, 2);
	g_assert (_tmp5_ == (-1));
	_tmp6_ = fso_gsm_sms_handler_get_storage ((FsoGsmSmsHandler*) handler);
	_tmp7_ = _tmp6_;
	_tmp8_ = fso_gsm_isms_storage_confirmReceivedMessage (_tmp7_, 3);
	g_assert (_tmp8_ == (-1));
	_tmp9_ = fso_gsm_sms_handler_get_storage ((FsoGsmSmsHandler*) handler);
	_tmp10_ = _tmp9_;
	_tmp11_ = fso_gsm_isms_storage_confirmReceivedMessage (_tmp10_, 4);
	g_assert (_tmp11_ == (-1));
	_tmp12_ = fso_gsm_sms_handler_get_storage ((FsoGsmSmsHandler*) handler);
	_tmp13_ = _tmp12_;
	_tmp14_ = fso_gsm_isms_storage_confirmReceivedMessage (_tmp13_, 1);
	g_assert (_tmp14_ != (-1));
	_g_object_unref0 (handler);
}


static void _test_fso_sms_storage_new_gcallback (void) {
	test_fso_sms_storage_new ();
}


static void _test_fso_sms_storage_add_single_gcallback (void) {
	test_fso_sms_storage_add_single ();
}


static void _test_fso_sms_storage_add_concatenated_gcallback (void) {
	test_fso_sms_storage_add_concatenated ();
}


static void _test_fso_sms_storage_store_transaction_index_gcallback (void) {
	test_fso_sms_storage_store_transaction_index ();
}


static void _test_fso_sms_storage_confirm_ack_gcallback (void) {
	test_fso_sms_storage_confirm_ack ();
}


void _vala_main (gchar** args, int args_length1) {
	g_test_init (&args_length1, &args, NULL);
	g_test_add_func ("/Fso/Sms/Storage/New", _test_fso_sms_storage_new_gcallback);
	g_test_add_func ("/Fso/Sms/Storage/Add/Single", _test_fso_sms_storage_add_single_gcallback);
	g_test_add_func ("/Fso/Sms/Storage/Add/Concatenated", _test_fso_sms_storage_add_concatenated_gcallback);
	g_test_add_func ("/Fso/Sms/Storage/StoreTransactionIndex", _test_fso_sms_storage_store_transaction_index_gcallback);
	g_test_add_func ("/Fso/Sms/Storage/ConfirmReceivedMessage", _test_fso_sms_storage_confirm_ack_gcallback);
	g_test_run ();
}


int main (int argc, char ** argv) {
	g_type_init ();
	_vala_main (argv, argc);
	return 0;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



