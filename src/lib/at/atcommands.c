/* atcommands.c generated by valac 0.16.1, the Vala compiler
 * generated from atcommands.vala, do not modify */

/*
 * Copyright (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <freesmartphone.h>
#include <gee.h>
#include <smsutil.h>
#include <conversions.h>
#include <util.h>
#include <fsobasics.h>
#include <stdio.h>


#define FSO_GSM_TYPE_AT_COMMAND_QUEUE_COMMAND (fso_gsm_at_command_queue_command_get_type ())
#define FSO_GSM_AT_COMMAND_QUEUE_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_AT_COMMAND_QUEUE_COMMAND, FsoGsmAtCommandQueueCommand))
#define FSO_GSM_IS_AT_COMMAND_QUEUE_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_AT_COMMAND_QUEUE_COMMAND))
#define FSO_GSM_AT_COMMAND_QUEUE_COMMAND_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), FSO_GSM_TYPE_AT_COMMAND_QUEUE_COMMAND, FsoGsmAtCommandQueueCommandIface))

typedef struct _FsoGsmAtCommandQueueCommand FsoGsmAtCommandQueueCommand;
typedef struct _FsoGsmAtCommandQueueCommandIface FsoGsmAtCommandQueueCommandIface;

#define FSO_GSM_TYPE_AT_COMMAND (fso_gsm_at_command_get_type ())
#define FSO_GSM_AT_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_AT_COMMAND, FsoGsmAtCommand))
#define FSO_GSM_IS_AT_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_AT_COMMAND))
#define FSO_GSM_AT_COMMAND_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), FSO_GSM_TYPE_AT_COMMAND, FsoGsmAtCommandIface))

typedef struct _FsoGsmAtCommand FsoGsmAtCommand;
typedef struct _FsoGsmAtCommandIface FsoGsmAtCommandIface;

#define FSO_GSM_CONSTANTS_TYPE_AT_RESPONSE (fso_gsm_constants_at_response_get_type ())

#define FSO_GSM_TYPE_ABSTRACT_AT_COMMAND (fso_gsm_abstract_at_command_get_type ())
#define FSO_GSM_ABSTRACT_AT_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, FsoGsmAbstractAtCommand))
#define FSO_GSM_ABSTRACT_AT_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, FsoGsmAbstractAtCommandClass))
#define FSO_GSM_IS_ABSTRACT_AT_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_ABSTRACT_AT_COMMAND))
#define FSO_GSM_IS_ABSTRACT_AT_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_ABSTRACT_AT_COMMAND))
#define FSO_GSM_ABSTRACT_AT_COMMAND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, FsoGsmAbstractAtCommandClass))

typedef struct _FsoGsmAbstractAtCommand FsoGsmAbstractAtCommand;
typedef struct _FsoGsmAbstractAtCommandClass FsoGsmAbstractAtCommandClass;
typedef struct _FsoGsmAbstractAtCommandPrivate FsoGsmAbstractAtCommandPrivate;

#define FSO_GSM_TYPE_PLUS_CALA (fso_gsm_plus_cala_get_type ())
#define FSO_GSM_PLUS_CALA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CALA, FsoGsmPlusCALA))
#define FSO_GSM_PLUS_CALA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CALA, FsoGsmPlusCALAClass))
#define FSO_GSM_IS_PLUS_CALA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CALA))
#define FSO_GSM_IS_PLUS_CALA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CALA))
#define FSO_GSM_PLUS_CALA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CALA, FsoGsmPlusCALAClass))

typedef struct _FsoGsmPlusCALA FsoGsmPlusCALA;
typedef struct _FsoGsmPlusCALAClass FsoGsmPlusCALAClass;
typedef struct _FsoGsmPlusCALAPrivate FsoGsmPlusCALAPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define FSO_GSM_TYPE_PLUS_CBC (fso_gsm_plus_cbc_get_type ())
#define FSO_GSM_PLUS_CBC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CBC, FsoGsmPlusCBC))
#define FSO_GSM_PLUS_CBC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CBC, FsoGsmPlusCBCClass))
#define FSO_GSM_IS_PLUS_CBC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CBC))
#define FSO_GSM_IS_PLUS_CBC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CBC))
#define FSO_GSM_PLUS_CBC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CBC, FsoGsmPlusCBCClass))

typedef struct _FsoGsmPlusCBC FsoGsmPlusCBC;
typedef struct _FsoGsmPlusCBCClass FsoGsmPlusCBCClass;
typedef struct _FsoGsmPlusCBCPrivate FsoGsmPlusCBCPrivate;

#define FSO_GSM_PLUS_CBC_TYPE_STATUS (fso_gsm_plus_cbc_status_get_type ())

#define FSO_GSM_TYPE_PLUS_CBM (fso_gsm_plus_cbm_get_type ())
#define FSO_GSM_PLUS_CBM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CBM, FsoGsmPlusCBM))
#define FSO_GSM_PLUS_CBM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CBM, FsoGsmPlusCBMClass))
#define FSO_GSM_IS_PLUS_CBM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CBM))
#define FSO_GSM_IS_PLUS_CBM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CBM))
#define FSO_GSM_PLUS_CBM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CBM, FsoGsmPlusCBMClass))

typedef struct _FsoGsmPlusCBM FsoGsmPlusCBM;
typedef struct _FsoGsmPlusCBMClass FsoGsmPlusCBMClass;
typedef struct _FsoGsmPlusCBMPrivate FsoGsmPlusCBMPrivate;

#define FSO_GSM_TYPE_PLUS_CCLK (fso_gsm_plus_cclk_get_type ())
#define FSO_GSM_PLUS_CCLK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CCLK, FsoGsmPlusCCLK))
#define FSO_GSM_PLUS_CCLK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CCLK, FsoGsmPlusCCLKClass))
#define FSO_GSM_IS_PLUS_CCLK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CCLK))
#define FSO_GSM_IS_PLUS_CCLK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CCLK))
#define FSO_GSM_PLUS_CCLK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CCLK, FsoGsmPlusCCLKClass))

typedef struct _FsoGsmPlusCCLK FsoGsmPlusCCLK;
typedef struct _FsoGsmPlusCCLKClass FsoGsmPlusCCLKClass;
typedef struct _FsoGsmPlusCCLKPrivate FsoGsmPlusCCLKPrivate;

#define FSO_GSM_TYPE_PLUS_CDS (fso_gsm_plus_cds_get_type ())
#define FSO_GSM_PLUS_CDS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CDS, FsoGsmPlusCDS))
#define FSO_GSM_PLUS_CDS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CDS, FsoGsmPlusCDSClass))
#define FSO_GSM_IS_PLUS_CDS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CDS))
#define FSO_GSM_IS_PLUS_CDS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CDS))
#define FSO_GSM_PLUS_CDS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CDS, FsoGsmPlusCDSClass))

typedef struct _FsoGsmPlusCDS FsoGsmPlusCDS;
typedef struct _FsoGsmPlusCDSClass FsoGsmPlusCDSClass;
typedef struct _FsoGsmPlusCDSPrivate FsoGsmPlusCDSPrivate;

#define FSO_GSM_TYPE_PLUS_CEER (fso_gsm_plus_ceer_get_type ())
#define FSO_GSM_PLUS_CEER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CEER, FsoGsmPlusCEER))
#define FSO_GSM_PLUS_CEER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CEER, FsoGsmPlusCEERClass))
#define FSO_GSM_IS_PLUS_CEER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CEER))
#define FSO_GSM_IS_PLUS_CEER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CEER))
#define FSO_GSM_PLUS_CEER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CEER, FsoGsmPlusCEERClass))

typedef struct _FsoGsmPlusCEER FsoGsmPlusCEER;
typedef struct _FsoGsmPlusCEERClass FsoGsmPlusCEERClass;
typedef struct _FsoGsmPlusCEERPrivate FsoGsmPlusCEERPrivate;

#define FSO_GSM_TYPE_SIMPLE_AT_COMMAND (fso_gsm_simple_at_command_get_type ())
#define FSO_GSM_SIMPLE_AT_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_SIMPLE_AT_COMMAND, FsoGsmSimpleAtCommand))
#define FSO_GSM_SIMPLE_AT_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_SIMPLE_AT_COMMAND, FsoGsmSimpleAtCommandClass))
#define FSO_GSM_IS_SIMPLE_AT_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_SIMPLE_AT_COMMAND))
#define FSO_GSM_IS_SIMPLE_AT_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_SIMPLE_AT_COMMAND))
#define FSO_GSM_SIMPLE_AT_COMMAND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_SIMPLE_AT_COMMAND, FsoGsmSimpleAtCommandClass))

typedef struct _FsoGsmSimpleAtCommand FsoGsmSimpleAtCommand;
typedef struct _FsoGsmSimpleAtCommandClass FsoGsmSimpleAtCommandClass;
typedef struct _FsoGsmSimpleAtCommandPrivate FsoGsmSimpleAtCommandPrivate;

#define FSO_GSM_TYPE_PLUS_CFUN (fso_gsm_plus_cfun_get_type ())
#define FSO_GSM_PLUS_CFUN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CFUN, FsoGsmPlusCFUN))
#define FSO_GSM_PLUS_CFUN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CFUN, FsoGsmPlusCFUNClass))
#define FSO_GSM_IS_PLUS_CFUN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CFUN))
#define FSO_GSM_IS_PLUS_CFUN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CFUN))
#define FSO_GSM_PLUS_CFUN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CFUN, FsoGsmPlusCFUNClass))

typedef struct _FsoGsmPlusCFUN FsoGsmPlusCFUN;
typedef struct _FsoGsmPlusCFUNClass FsoGsmPlusCFUNClass;
typedef struct _FsoGsmPlusCFUNPrivate FsoGsmPlusCFUNPrivate;

#define FSO_GSM_TYPE_PLUS_CGACT (fso_gsm_plus_cgact_get_type ())
#define FSO_GSM_PLUS_CGACT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CGACT, FsoGsmPlusCGACT))
#define FSO_GSM_PLUS_CGACT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CGACT, FsoGsmPlusCGACTClass))
#define FSO_GSM_IS_PLUS_CGACT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CGACT))
#define FSO_GSM_IS_PLUS_CGACT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CGACT))
#define FSO_GSM_PLUS_CGACT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CGACT, FsoGsmPlusCGACTClass))

typedef struct _FsoGsmPlusCGACT FsoGsmPlusCGACT;
typedef struct _FsoGsmPlusCGACTClass FsoGsmPlusCGACTClass;
typedef struct _FsoGsmPlusCGACTPrivate FsoGsmPlusCGACTPrivate;

#define FSO_GSM_TYPE_PLUS_CGATT (fso_gsm_plus_cgatt_get_type ())
#define FSO_GSM_PLUS_CGATT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CGATT, FsoGsmPlusCGATT))
#define FSO_GSM_PLUS_CGATT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CGATT, FsoGsmPlusCGATTClass))
#define FSO_GSM_IS_PLUS_CGATT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CGATT))
#define FSO_GSM_IS_PLUS_CGATT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CGATT))
#define FSO_GSM_PLUS_CGATT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CGATT, FsoGsmPlusCGATTClass))

typedef struct _FsoGsmPlusCGATT FsoGsmPlusCGATT;
typedef struct _FsoGsmPlusCGATTClass FsoGsmPlusCGATTClass;
typedef struct _FsoGsmPlusCGATTPrivate FsoGsmPlusCGATTPrivate;

#define FSO_GSM_TYPE_PLUS_CGCLASS (fso_gsm_plus_cgclass_get_type ())
#define FSO_GSM_PLUS_CGCLASS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CGCLASS, FsoGsmPlusCGCLASS))
#define FSO_GSM_PLUS_CGCLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CGCLASS, FsoGsmPlusCGCLASSClass))
#define FSO_GSM_IS_PLUS_CGCLASS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CGCLASS))
#define FSO_GSM_IS_PLUS_CGCLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CGCLASS))
#define FSO_GSM_PLUS_CGCLASS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CGCLASS, FsoGsmPlusCGCLASSClass))

typedef struct _FsoGsmPlusCGCLASS FsoGsmPlusCGCLASS;
typedef struct _FsoGsmPlusCGCLASSClass FsoGsmPlusCGCLASSClass;
typedef struct _FsoGsmPlusCGCLASSPrivate FsoGsmPlusCGCLASSPrivate;

#define FSO_GSM_TYPE_PLUS_CGDCONT (fso_gsm_plus_cgdcont_get_type ())
#define FSO_GSM_PLUS_CGDCONT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CGDCONT, FsoGsmPlusCGDCONT))
#define FSO_GSM_PLUS_CGDCONT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CGDCONT, FsoGsmPlusCGDCONTClass))
#define FSO_GSM_IS_PLUS_CGDCONT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CGDCONT))
#define FSO_GSM_IS_PLUS_CGDCONT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CGDCONT))
#define FSO_GSM_PLUS_CGDCONT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CGDCONT, FsoGsmPlusCGDCONTClass))

typedef struct _FsoGsmPlusCGDCONT FsoGsmPlusCGDCONT;
typedef struct _FsoGsmPlusCGDCONTClass FsoGsmPlusCGDCONTClass;
typedef struct _FsoGsmPlusCGDCONTPrivate FsoGsmPlusCGDCONTPrivate;

#define FSO_GSM_TYPE_PLUS_CGMI (fso_gsm_plus_cgmi_get_type ())
#define FSO_GSM_PLUS_CGMI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CGMI, FsoGsmPlusCGMI))
#define FSO_GSM_PLUS_CGMI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CGMI, FsoGsmPlusCGMIClass))
#define FSO_GSM_IS_PLUS_CGMI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CGMI))
#define FSO_GSM_IS_PLUS_CGMI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CGMI))
#define FSO_GSM_PLUS_CGMI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CGMI, FsoGsmPlusCGMIClass))

typedef struct _FsoGsmPlusCGMI FsoGsmPlusCGMI;
typedef struct _FsoGsmPlusCGMIClass FsoGsmPlusCGMIClass;
typedef struct _FsoGsmPlusCGMIPrivate FsoGsmPlusCGMIPrivate;

#define FSO_GSM_TYPE_PLUS_CGMM (fso_gsm_plus_cgmm_get_type ())
#define FSO_GSM_PLUS_CGMM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CGMM, FsoGsmPlusCGMM))
#define FSO_GSM_PLUS_CGMM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CGMM, FsoGsmPlusCGMMClass))
#define FSO_GSM_IS_PLUS_CGMM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CGMM))
#define FSO_GSM_IS_PLUS_CGMM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CGMM))
#define FSO_GSM_PLUS_CGMM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CGMM, FsoGsmPlusCGMMClass))

typedef struct _FsoGsmPlusCGMM FsoGsmPlusCGMM;
typedef struct _FsoGsmPlusCGMMClass FsoGsmPlusCGMMClass;
typedef struct _FsoGsmPlusCGMMPrivate FsoGsmPlusCGMMPrivate;

#define FSO_GSM_TYPE_PLUS_CGMR (fso_gsm_plus_cgmr_get_type ())
#define FSO_GSM_PLUS_CGMR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CGMR, FsoGsmPlusCGMR))
#define FSO_GSM_PLUS_CGMR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CGMR, FsoGsmPlusCGMRClass))
#define FSO_GSM_IS_PLUS_CGMR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CGMR))
#define FSO_GSM_IS_PLUS_CGMR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CGMR))
#define FSO_GSM_PLUS_CGMR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CGMR, FsoGsmPlusCGMRClass))

typedef struct _FsoGsmPlusCGMR FsoGsmPlusCGMR;
typedef struct _FsoGsmPlusCGMRClass FsoGsmPlusCGMRClass;
typedef struct _FsoGsmPlusCGMRPrivate FsoGsmPlusCGMRPrivate;

#define FSO_GSM_TYPE_PLUS_CGREG (fso_gsm_plus_cgreg_get_type ())
#define FSO_GSM_PLUS_CGREG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CGREG, FsoGsmPlusCGREG))
#define FSO_GSM_PLUS_CGREG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CGREG, FsoGsmPlusCGREGClass))
#define FSO_GSM_IS_PLUS_CGREG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CGREG))
#define FSO_GSM_IS_PLUS_CGREG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CGREG))
#define FSO_GSM_PLUS_CGREG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CGREG, FsoGsmPlusCGREGClass))

typedef struct _FsoGsmPlusCGREG FsoGsmPlusCGREG;
typedef struct _FsoGsmPlusCGREGClass FsoGsmPlusCGREGClass;
typedef struct _FsoGsmPlusCGREGPrivate FsoGsmPlusCGREGPrivate;

#define FSO_GSM_TYPE_PLUS_CGSN (fso_gsm_plus_cgsn_get_type ())
#define FSO_GSM_PLUS_CGSN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CGSN, FsoGsmPlusCGSN))
#define FSO_GSM_PLUS_CGSN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CGSN, FsoGsmPlusCGSNClass))
#define FSO_GSM_IS_PLUS_CGSN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CGSN))
#define FSO_GSM_IS_PLUS_CGSN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CGSN))
#define FSO_GSM_PLUS_CGSN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CGSN, FsoGsmPlusCGSNClass))

typedef struct _FsoGsmPlusCGSN FsoGsmPlusCGSN;
typedef struct _FsoGsmPlusCGSNClass FsoGsmPlusCGSNClass;
typedef struct _FsoGsmPlusCGSNPrivate FsoGsmPlusCGSNPrivate;

#define FSO_GSM_TYPE_PLUS_CHLD (fso_gsm_plus_chld_get_type ())
#define FSO_GSM_PLUS_CHLD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CHLD, FsoGsmPlusCHLD))
#define FSO_GSM_PLUS_CHLD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CHLD, FsoGsmPlusCHLDClass))
#define FSO_GSM_IS_PLUS_CHLD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CHLD))
#define FSO_GSM_IS_PLUS_CHLD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CHLD))
#define FSO_GSM_PLUS_CHLD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CHLD, FsoGsmPlusCHLDClass))

typedef struct _FsoGsmPlusCHLD FsoGsmPlusCHLD;
typedef struct _FsoGsmPlusCHLDClass FsoGsmPlusCHLDClass;
typedef struct _FsoGsmPlusCHLDPrivate FsoGsmPlusCHLDPrivate;

#define FSO_GSM_PLUS_CHLD_TYPE_ACTION (fso_gsm_plus_chld_action_get_type ())

#define FSO_GSM_TYPE_TWO_PARAMS_AT_COMMAND (fso_gsm_two_params_at_command_get_type ())
#define FSO_GSM_TWO_PARAMS_AT_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_TWO_PARAMS_AT_COMMAND, FsoGsmTwoParamsAtCommand))
#define FSO_GSM_TWO_PARAMS_AT_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_TWO_PARAMS_AT_COMMAND, FsoGsmTwoParamsAtCommandClass))
#define FSO_GSM_IS_TWO_PARAMS_AT_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_TWO_PARAMS_AT_COMMAND))
#define FSO_GSM_IS_TWO_PARAMS_AT_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_TWO_PARAMS_AT_COMMAND))
#define FSO_GSM_TWO_PARAMS_AT_COMMAND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_TWO_PARAMS_AT_COMMAND, FsoGsmTwoParamsAtCommandClass))

typedef struct _FsoGsmTwoParamsAtCommand FsoGsmTwoParamsAtCommand;
typedef struct _FsoGsmTwoParamsAtCommandClass FsoGsmTwoParamsAtCommandClass;
typedef struct _FsoGsmTwoParamsAtCommandPrivate FsoGsmTwoParamsAtCommandPrivate;

#define FSO_GSM_TYPE_PLUS_CIEV (fso_gsm_plus_ciev_get_type ())
#define FSO_GSM_PLUS_CIEV(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CIEV, FsoGsmPlusCIEV))
#define FSO_GSM_PLUS_CIEV_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CIEV, FsoGsmPlusCIEVClass))
#define FSO_GSM_IS_PLUS_CIEV(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CIEV))
#define FSO_GSM_IS_PLUS_CIEV_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CIEV))
#define FSO_GSM_PLUS_CIEV_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CIEV, FsoGsmPlusCIEVClass))

typedef struct _FsoGsmPlusCIEV FsoGsmPlusCIEV;
typedef struct _FsoGsmPlusCIEVClass FsoGsmPlusCIEVClass;
typedef struct _FsoGsmPlusCIEVPrivate FsoGsmPlusCIEVPrivate;

#define FSO_GSM_TYPE_PLUS_CIMI (fso_gsm_plus_cimi_get_type ())
#define FSO_GSM_PLUS_CIMI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CIMI, FsoGsmPlusCIMI))
#define FSO_GSM_PLUS_CIMI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CIMI, FsoGsmPlusCIMIClass))
#define FSO_GSM_IS_PLUS_CIMI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CIMI))
#define FSO_GSM_IS_PLUS_CIMI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CIMI))
#define FSO_GSM_PLUS_CIMI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CIMI, FsoGsmPlusCIMIClass))

typedef struct _FsoGsmPlusCIMI FsoGsmPlusCIMI;
typedef struct _FsoGsmPlusCIMIClass FsoGsmPlusCIMIClass;
typedef struct _FsoGsmPlusCIMIPrivate FsoGsmPlusCIMIPrivate;

#define FSO_GSM_TYPE_PLUS_CLCC (fso_gsm_plus_clcc_get_type ())
#define FSO_GSM_PLUS_CLCC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CLCC, FsoGsmPlusCLCC))
#define FSO_GSM_PLUS_CLCC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CLCC, FsoGsmPlusCLCCClass))
#define FSO_GSM_IS_PLUS_CLCC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CLCC))
#define FSO_GSM_IS_PLUS_CLCC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CLCC))
#define FSO_GSM_PLUS_CLCC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CLCC, FsoGsmPlusCLCCClass))

typedef struct _FsoGsmPlusCLCC FsoGsmPlusCLCC;
typedef struct _FsoGsmPlusCLCCClass FsoGsmPlusCLCCClass;
typedef struct _FsoGsmPlusCLCCPrivate FsoGsmPlusCLCCPrivate;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))

#define FSO_GSM_TYPE_PLUS_CLCK (fso_gsm_plus_clck_get_type ())
#define FSO_GSM_PLUS_CLCK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CLCK, FsoGsmPlusCLCK))
#define FSO_GSM_PLUS_CLCK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CLCK, FsoGsmPlusCLCKClass))
#define FSO_GSM_IS_PLUS_CLCK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CLCK))
#define FSO_GSM_IS_PLUS_CLCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CLCK))
#define FSO_GSM_PLUS_CLCK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CLCK, FsoGsmPlusCLCKClass))

typedef struct _FsoGsmPlusCLCK FsoGsmPlusCLCK;
typedef struct _FsoGsmPlusCLCKClass FsoGsmPlusCLCKClass;
typedef struct _FsoGsmPlusCLCKPrivate FsoGsmPlusCLCKPrivate;

#define FSO_GSM_PLUS_CLCK_TYPE_MODE (fso_gsm_plus_clck_mode_get_type ())

#define FSO_GSM_TYPE_PLUS_CLIR (fso_gsm_plus_clir_get_type ())
#define FSO_GSM_PLUS_CLIR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CLIR, FsoGsmPlusCLIR))
#define FSO_GSM_PLUS_CLIR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CLIR, FsoGsmPlusCLIRClass))
#define FSO_GSM_IS_PLUS_CLIR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CLIR))
#define FSO_GSM_IS_PLUS_CLIR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CLIR))
#define FSO_GSM_PLUS_CLIR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CLIR, FsoGsmPlusCLIRClass))

typedef struct _FsoGsmPlusCLIR FsoGsmPlusCLIR;
typedef struct _FsoGsmPlusCLIRClass FsoGsmPlusCLIRClass;
typedef struct _FsoGsmPlusCLIRPrivate FsoGsmPlusCLIRPrivate;

#define FSO_GSM_TYPE_PLUS_CLVL (fso_gsm_plus_clvl_get_type ())
#define FSO_GSM_PLUS_CLVL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CLVL, FsoGsmPlusCLVL))
#define FSO_GSM_PLUS_CLVL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CLVL, FsoGsmPlusCLVLClass))
#define FSO_GSM_IS_PLUS_CLVL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CLVL))
#define FSO_GSM_IS_PLUS_CLVL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CLVL))
#define FSO_GSM_PLUS_CLVL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CLVL, FsoGsmPlusCLVLClass))

typedef struct _FsoGsmPlusCLVL FsoGsmPlusCLVL;
typedef struct _FsoGsmPlusCLVLClass FsoGsmPlusCLVLClass;
typedef struct _FsoGsmPlusCLVLPrivate FsoGsmPlusCLVLPrivate;

#define FSO_GSM_TYPE_PLUS_CMGD (fso_gsm_plus_cmgd_get_type ())
#define FSO_GSM_PLUS_CMGD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMGD, FsoGsmPlusCMGD))
#define FSO_GSM_PLUS_CMGD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMGD, FsoGsmPlusCMGDClass))
#define FSO_GSM_IS_PLUS_CMGD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMGD))
#define FSO_GSM_IS_PLUS_CMGD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMGD))
#define FSO_GSM_PLUS_CMGD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMGD, FsoGsmPlusCMGDClass))

typedef struct _FsoGsmPlusCMGD FsoGsmPlusCMGD;
typedef struct _FsoGsmPlusCMGDClass FsoGsmPlusCMGDClass;
typedef struct _FsoGsmPlusCMGDPrivate FsoGsmPlusCMGDPrivate;

#define FSO_GSM_TYPE_PLUS_CMGL (fso_gsm_plus_cmgl_get_type ())
#define FSO_GSM_PLUS_CMGL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMGL, FsoGsmPlusCMGL))
#define FSO_GSM_PLUS_CMGL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMGL, FsoGsmPlusCMGLClass))
#define FSO_GSM_IS_PLUS_CMGL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMGL))
#define FSO_GSM_IS_PLUS_CMGL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMGL))
#define FSO_GSM_PLUS_CMGL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMGL, FsoGsmPlusCMGLClass))

typedef struct _FsoGsmPlusCMGL FsoGsmPlusCMGL;
typedef struct _FsoGsmPlusCMGLClass FsoGsmPlusCMGLClass;
typedef struct _FsoGsmPlusCMGLPrivate FsoGsmPlusCMGLPrivate;

#define TYPE_WRAP_SMS (wrap_sms_get_type ())
#define WRAP_SMS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WRAP_SMS, WrapSms))
#define WRAP_SMS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WRAP_SMS, WrapSmsClass))
#define IS_WRAP_SMS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WRAP_SMS))
#define IS_WRAP_SMS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WRAP_SMS))
#define WRAP_SMS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WRAP_SMS, WrapSmsClass))

typedef struct _WrapSms WrapSms;
typedef struct _WrapSmsClass WrapSmsClass;

#define FSO_GSM_PLUS_CMGL_TYPE_MODE (fso_gsm_plus_cmgl_mode_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _sms_free0(var) ((var == NULL) ? NULL : (var = (sms_free (var), NULL)))
#define _wrap_sms_unref0(var) ((var == NULL) ? NULL : (var = (wrap_sms_unref (var), NULL)))

#define FSO_GSM_TYPE_PLUS_CMGR (fso_gsm_plus_cmgr_get_type ())
#define FSO_GSM_PLUS_CMGR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMGR, FsoGsmPlusCMGR))
#define FSO_GSM_PLUS_CMGR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMGR, FsoGsmPlusCMGRClass))
#define FSO_GSM_IS_PLUS_CMGR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMGR))
#define FSO_GSM_IS_PLUS_CMGR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMGR))
#define FSO_GSM_PLUS_CMGR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMGR, FsoGsmPlusCMGRClass))

typedef struct _FsoGsmPlusCMGR FsoGsmPlusCMGR;
typedef struct _FsoGsmPlusCMGRClass FsoGsmPlusCMGRClass;
typedef struct _FsoGsmPlusCMGRPrivate FsoGsmPlusCMGRPrivate;

#define FSO_GSM_TYPE_PLUS_CMGS (fso_gsm_plus_cmgs_get_type ())
#define FSO_GSM_PLUS_CMGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMGS, FsoGsmPlusCMGS))
#define FSO_GSM_PLUS_CMGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMGS, FsoGsmPlusCMGSClass))
#define FSO_GSM_IS_PLUS_CMGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMGS))
#define FSO_GSM_IS_PLUS_CMGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMGS))
#define FSO_GSM_PLUS_CMGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMGS, FsoGsmPlusCMGSClass))

typedef struct _FsoGsmPlusCMGS FsoGsmPlusCMGS;
typedef struct _FsoGsmPlusCMGSClass FsoGsmPlusCMGSClass;
typedef struct _FsoGsmPlusCMGSPrivate FsoGsmPlusCMGSPrivate;

#define TYPE_WRAP_HEX_PDU (wrap_hex_pdu_get_type ())
#define WRAP_HEX_PDU(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WRAP_HEX_PDU, WrapHexPdu))
#define WRAP_HEX_PDU_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WRAP_HEX_PDU, WrapHexPduClass))
#define IS_WRAP_HEX_PDU(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WRAP_HEX_PDU))
#define IS_WRAP_HEX_PDU_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WRAP_HEX_PDU))
#define WRAP_HEX_PDU_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WRAP_HEX_PDU, WrapHexPduClass))

typedef struct _WrapHexPdu WrapHexPdu;
typedef struct _WrapHexPduClass WrapHexPduClass;
typedef struct _WrapHexPduPrivate WrapHexPduPrivate;

#define FSO_GSM_TYPE_PLUS_CMGW (fso_gsm_plus_cmgw_get_type ())
#define FSO_GSM_PLUS_CMGW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMGW, FsoGsmPlusCMGW))
#define FSO_GSM_PLUS_CMGW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMGW, FsoGsmPlusCMGWClass))
#define FSO_GSM_IS_PLUS_CMGW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMGW))
#define FSO_GSM_IS_PLUS_CMGW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMGW))
#define FSO_GSM_PLUS_CMGW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMGW, FsoGsmPlusCMGWClass))

typedef struct _FsoGsmPlusCMGW FsoGsmPlusCMGW;
typedef struct _FsoGsmPlusCMGWClass FsoGsmPlusCMGWClass;
typedef struct _FsoGsmPlusCMGWPrivate FsoGsmPlusCMGWPrivate;

#define FSO_GSM_TYPE_PLUS_CMICKEY (fso_gsm_plus_cmickey_get_type ())
#define FSO_GSM_PLUS_CMICKEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMICKEY, FsoGsmPlusCMICKEY))
#define FSO_GSM_PLUS_CMICKEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMICKEY, FsoGsmPlusCMICKEYClass))
#define FSO_GSM_IS_PLUS_CMICKEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMICKEY))
#define FSO_GSM_IS_PLUS_CMICKEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMICKEY))
#define FSO_GSM_PLUS_CMICKEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMICKEY, FsoGsmPlusCMICKEYClass))

typedef struct _FsoGsmPlusCMICKEY FsoGsmPlusCMICKEY;
typedef struct _FsoGsmPlusCMICKEYClass FsoGsmPlusCMICKEYClass;
typedef struct _FsoGsmPlusCMICKEYPrivate FsoGsmPlusCMICKEYPrivate;

#define FSO_GSM_TYPE_PLUS_CMSS (fso_gsm_plus_cmss_get_type ())
#define FSO_GSM_PLUS_CMSS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMSS, FsoGsmPlusCMSS))
#define FSO_GSM_PLUS_CMSS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMSS, FsoGsmPlusCMSSClass))
#define FSO_GSM_IS_PLUS_CMSS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMSS))
#define FSO_GSM_IS_PLUS_CMSS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMSS))
#define FSO_GSM_PLUS_CMSS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMSS, FsoGsmPlusCMSSClass))

typedef struct _FsoGsmPlusCMSS FsoGsmPlusCMSS;
typedef struct _FsoGsmPlusCMSSClass FsoGsmPlusCMSSClass;
typedef struct _FsoGsmPlusCMSSPrivate FsoGsmPlusCMSSPrivate;

#define FSO_GSM_TYPE_PLUS_CMT (fso_gsm_plus_cmt_get_type ())
#define FSO_GSM_PLUS_CMT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMT, FsoGsmPlusCMT))
#define FSO_GSM_PLUS_CMT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMT, FsoGsmPlusCMTClass))
#define FSO_GSM_IS_PLUS_CMT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMT))
#define FSO_GSM_IS_PLUS_CMT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMT))
#define FSO_GSM_PLUS_CMT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMT, FsoGsmPlusCMTClass))

typedef struct _FsoGsmPlusCMT FsoGsmPlusCMT;
typedef struct _FsoGsmPlusCMTClass FsoGsmPlusCMTClass;
typedef struct _FsoGsmPlusCMTPrivate FsoGsmPlusCMTPrivate;

#define FSO_GSM_TYPE_PLUS_CMTI (fso_gsm_plus_cmti_get_type ())
#define FSO_GSM_PLUS_CMTI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMTI, FsoGsmPlusCMTI))
#define FSO_GSM_PLUS_CMTI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMTI, FsoGsmPlusCMTIClass))
#define FSO_GSM_IS_PLUS_CMTI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMTI))
#define FSO_GSM_IS_PLUS_CMTI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMTI))
#define FSO_GSM_PLUS_CMTI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMTI, FsoGsmPlusCMTIClass))

typedef struct _FsoGsmPlusCMTI FsoGsmPlusCMTI;
typedef struct _FsoGsmPlusCMTIClass FsoGsmPlusCMTIClass;
typedef struct _FsoGsmPlusCMTIPrivate FsoGsmPlusCMTIPrivate;

#define FSO_GSM_TYPE_PLUS_CMMS (fso_gsm_plus_cmms_get_type ())
#define FSO_GSM_PLUS_CMMS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMMS, FsoGsmPlusCMMS))
#define FSO_GSM_PLUS_CMMS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMMS, FsoGsmPlusCMMSClass))
#define FSO_GSM_IS_PLUS_CMMS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMMS))
#define FSO_GSM_IS_PLUS_CMMS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMMS))
#define FSO_GSM_PLUS_CMMS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMMS, FsoGsmPlusCMMSClass))

typedef struct _FsoGsmPlusCMMS FsoGsmPlusCMMS;
typedef struct _FsoGsmPlusCMMSClass FsoGsmPlusCMMSClass;
typedef struct _FsoGsmPlusCMMSPrivate FsoGsmPlusCMMSPrivate;

#define FSO_GSM_TYPE_PLUS_CMUT (fso_gsm_plus_cmut_get_type ())
#define FSO_GSM_PLUS_CMUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMUT, FsoGsmPlusCMUT))
#define FSO_GSM_PLUS_CMUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMUT, FsoGsmPlusCMUTClass))
#define FSO_GSM_IS_PLUS_CMUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMUT))
#define FSO_GSM_IS_PLUS_CMUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMUT))
#define FSO_GSM_PLUS_CMUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMUT, FsoGsmPlusCMUTClass))

typedef struct _FsoGsmPlusCMUT FsoGsmPlusCMUT;
typedef struct _FsoGsmPlusCMUTClass FsoGsmPlusCMUTClass;
typedef struct _FsoGsmPlusCMUTPrivate FsoGsmPlusCMUTPrivate;

#define FSO_GSM_TYPE_PLUS_CNMA (fso_gsm_plus_cnma_get_type ())
#define FSO_GSM_PLUS_CNMA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CNMA, FsoGsmPlusCNMA))
#define FSO_GSM_PLUS_CNMA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CNMA, FsoGsmPlusCNMAClass))
#define FSO_GSM_IS_PLUS_CNMA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CNMA))
#define FSO_GSM_IS_PLUS_CNMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CNMA))
#define FSO_GSM_PLUS_CNMA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CNMA, FsoGsmPlusCNMAClass))

typedef struct _FsoGsmPlusCNMA FsoGsmPlusCNMA;
typedef struct _FsoGsmPlusCNMAClass FsoGsmPlusCNMAClass;
typedef struct _FsoGsmPlusCNMAPrivate FsoGsmPlusCNMAPrivate;

#define FSO_GSM_TYPE_PLUS_CNMI (fso_gsm_plus_cnmi_get_type ())
#define FSO_GSM_PLUS_CNMI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CNMI, FsoGsmPlusCNMI))
#define FSO_GSM_PLUS_CNMI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CNMI, FsoGsmPlusCNMIClass))
#define FSO_GSM_IS_PLUS_CNMI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CNMI))
#define FSO_GSM_IS_PLUS_CNMI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CNMI))
#define FSO_GSM_PLUS_CNMI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CNMI, FsoGsmPlusCNMIClass))

typedef struct _FsoGsmPlusCNMI FsoGsmPlusCNMI;
typedef struct _FsoGsmPlusCNMIClass FsoGsmPlusCNMIClass;
typedef struct _FsoGsmPlusCNMIPrivate FsoGsmPlusCNMIPrivate;

#define FSO_GSM_TYPE_AT_RESULT_ITER (fso_gsm_at_result_iter_get_type ())
#define FSO_GSM_AT_RESULT_ITER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_AT_RESULT_ITER, FsoGsmAtResultIter))
#define FSO_GSM_AT_RESULT_ITER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_AT_RESULT_ITER, FsoGsmAtResultIterClass))
#define FSO_GSM_IS_AT_RESULT_ITER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_AT_RESULT_ITER))
#define FSO_GSM_IS_AT_RESULT_ITER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_AT_RESULT_ITER))
#define FSO_GSM_AT_RESULT_ITER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_AT_RESULT_ITER, FsoGsmAtResultIterClass))

typedef struct _FsoGsmAtResultIter FsoGsmAtResultIter;
typedef struct _FsoGsmAtResultIterClass FsoGsmAtResultIterClass;
#define _fso_gsm_at_result_iter_unref0(var) ((var == NULL) ? NULL : (var = (fso_gsm_at_result_iter_unref (var), NULL)))

#define FSO_GSM_TYPE_PLUS_COPN (fso_gsm_plus_copn_get_type ())
#define FSO_GSM_PLUS_COPN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_COPN, FsoGsmPlusCOPN))
#define FSO_GSM_PLUS_COPN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_COPN, FsoGsmPlusCOPNClass))
#define FSO_GSM_IS_PLUS_COPN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_COPN))
#define FSO_GSM_IS_PLUS_COPN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_COPN))
#define FSO_GSM_PLUS_COPN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_COPN, FsoGsmPlusCOPNClass))

typedef struct _FsoGsmPlusCOPN FsoGsmPlusCOPN;
typedef struct _FsoGsmPlusCOPNClass FsoGsmPlusCOPNClass;
typedef struct _FsoGsmPlusCOPNPrivate FsoGsmPlusCOPNPrivate;

#define FSO_GSM_TYPE_PLUS_COPS (fso_gsm_plus_cops_get_type ())
#define FSO_GSM_PLUS_COPS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_COPS, FsoGsmPlusCOPS))
#define FSO_GSM_PLUS_COPS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_COPS, FsoGsmPlusCOPSClass))
#define FSO_GSM_IS_PLUS_COPS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_COPS))
#define FSO_GSM_IS_PLUS_COPS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_COPS))
#define FSO_GSM_PLUS_COPS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_COPS, FsoGsmPlusCOPSClass))

typedef struct _FsoGsmPlusCOPS FsoGsmPlusCOPS;
typedef struct _FsoGsmPlusCOPSClass FsoGsmPlusCOPSClass;
typedef struct _FsoGsmPlusCOPSPrivate FsoGsmPlusCOPSPrivate;

#define FSO_GSM_PLUS_COPS_TYPE_ACTION (fso_gsm_plus_cops_action_get_type ())

#define FSO_GSM_PLUS_COPS_TYPE_FORMAT (fso_gsm_plus_cops_format_get_type ())

#define FSO_GSM_TYPE_PLUS_CPBR (fso_gsm_plus_cpbr_get_type ())
#define FSO_GSM_PLUS_CPBR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CPBR, FsoGsmPlusCPBR))
#define FSO_GSM_PLUS_CPBR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CPBR, FsoGsmPlusCPBRClass))
#define FSO_GSM_IS_PLUS_CPBR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CPBR))
#define FSO_GSM_IS_PLUS_CPBR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CPBR))
#define FSO_GSM_PLUS_CPBR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CPBR, FsoGsmPlusCPBRClass))

typedef struct _FsoGsmPlusCPBR FsoGsmPlusCPBR;
typedef struct _FsoGsmPlusCPBRClass FsoGsmPlusCPBRClass;
typedef struct _FsoGsmPlusCPBRPrivate FsoGsmPlusCPBRPrivate;

#define FSO_GSM_TYPE_PLUS_CPBS (fso_gsm_plus_cpbs_get_type ())
#define FSO_GSM_PLUS_CPBS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CPBS, FsoGsmPlusCPBS))
#define FSO_GSM_PLUS_CPBS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CPBS, FsoGsmPlusCPBSClass))
#define FSO_GSM_IS_PLUS_CPBS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CPBS))
#define FSO_GSM_IS_PLUS_CPBS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CPBS))
#define FSO_GSM_PLUS_CPBS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CPBS, FsoGsmPlusCPBSClass))

typedef struct _FsoGsmPlusCPBS FsoGsmPlusCPBS;
typedef struct _FsoGsmPlusCPBSClass FsoGsmPlusCPBSClass;
typedef struct _FsoGsmPlusCPBSPrivate FsoGsmPlusCPBSPrivate;

#define FSO_GSM_TYPE_PLUS_CPBW (fso_gsm_plus_cpbw_get_type ())
#define FSO_GSM_PLUS_CPBW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CPBW, FsoGsmPlusCPBW))
#define FSO_GSM_PLUS_CPBW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CPBW, FsoGsmPlusCPBWClass))
#define FSO_GSM_IS_PLUS_CPBW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CPBW))
#define FSO_GSM_IS_PLUS_CPBW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CPBW))
#define FSO_GSM_PLUS_CPBW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CPBW, FsoGsmPlusCPBWClass))

typedef struct _FsoGsmPlusCPBW FsoGsmPlusCPBW;
typedef struct _FsoGsmPlusCPBWClass FsoGsmPlusCPBWClass;
typedef struct _FsoGsmPlusCPBWPrivate FsoGsmPlusCPBWPrivate;

#define FSO_GSM_TYPE_PLUS_CPIN (fso_gsm_plus_cpin_get_type ())
#define FSO_GSM_PLUS_CPIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CPIN, FsoGsmPlusCPIN))
#define FSO_GSM_PLUS_CPIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CPIN, FsoGsmPlusCPINClass))
#define FSO_GSM_IS_PLUS_CPIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CPIN))
#define FSO_GSM_IS_PLUS_CPIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CPIN))
#define FSO_GSM_PLUS_CPIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CPIN, FsoGsmPlusCPINClass))

typedef struct _FsoGsmPlusCPIN FsoGsmPlusCPIN;
typedef struct _FsoGsmPlusCPINClass FsoGsmPlusCPINClass;
typedef struct _FsoGsmPlusCPINPrivate FsoGsmPlusCPINPrivate;

#define FSO_GSM_TYPE_PLUS_CPMS (fso_gsm_plus_cpms_get_type ())
#define FSO_GSM_PLUS_CPMS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CPMS, FsoGsmPlusCPMS))
#define FSO_GSM_PLUS_CPMS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CPMS, FsoGsmPlusCPMSClass))
#define FSO_GSM_IS_PLUS_CPMS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CPMS))
#define FSO_GSM_IS_PLUS_CPMS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CPMS))
#define FSO_GSM_PLUS_CPMS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CPMS, FsoGsmPlusCPMSClass))

typedef struct _FsoGsmPlusCPMS FsoGsmPlusCPMS;
typedef struct _FsoGsmPlusCPMSClass FsoGsmPlusCPMSClass;
typedef struct _FsoGsmPlusCPMSPrivate FsoGsmPlusCPMSPrivate;

#define FSO_GSM_TYPE_PLUS_CPWD (fso_gsm_plus_cpwd_get_type ())
#define FSO_GSM_PLUS_CPWD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CPWD, FsoGsmPlusCPWD))
#define FSO_GSM_PLUS_CPWD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CPWD, FsoGsmPlusCPWDClass))
#define FSO_GSM_IS_PLUS_CPWD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CPWD))
#define FSO_GSM_IS_PLUS_CPWD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CPWD))
#define FSO_GSM_PLUS_CPWD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CPWD, FsoGsmPlusCPWDClass))

typedef struct _FsoGsmPlusCPWD FsoGsmPlusCPWD;
typedef struct _FsoGsmPlusCPWDClass FsoGsmPlusCPWDClass;
typedef struct _FsoGsmPlusCPWDPrivate FsoGsmPlusCPWDPrivate;

#define FSO_GSM_TYPE_PLUS_CREG (fso_gsm_plus_creg_get_type ())
#define FSO_GSM_PLUS_CREG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CREG, FsoGsmPlusCREG))
#define FSO_GSM_PLUS_CREG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CREG, FsoGsmPlusCREGClass))
#define FSO_GSM_IS_PLUS_CREG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CREG))
#define FSO_GSM_IS_PLUS_CREG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CREG))
#define FSO_GSM_PLUS_CREG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CREG, FsoGsmPlusCREGClass))

typedef struct _FsoGsmPlusCREG FsoGsmPlusCREG;
typedef struct _FsoGsmPlusCREGClass FsoGsmPlusCREGClass;
typedef struct _FsoGsmPlusCREGPrivate FsoGsmPlusCREGPrivate;

#define FSO_GSM_PLUS_CREG_TYPE_MODE (fso_gsm_plus_creg_mode_get_type ())

#define FSO_GSM_TYPE_PLUS_CRSM (fso_gsm_plus_crsm_get_type ())
#define FSO_GSM_PLUS_CRSM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CRSM, FsoGsmPlusCRSM))
#define FSO_GSM_PLUS_CRSM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CRSM, FsoGsmPlusCRSMClass))
#define FSO_GSM_IS_PLUS_CRSM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CRSM))
#define FSO_GSM_IS_PLUS_CRSM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CRSM))
#define FSO_GSM_PLUS_CRSM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CRSM, FsoGsmPlusCRSMClass))

typedef struct _FsoGsmPlusCRSM FsoGsmPlusCRSM;
typedef struct _FsoGsmPlusCRSMClass FsoGsmPlusCRSMClass;
typedef struct _FsoGsmPlusCRSMPrivate FsoGsmPlusCRSMPrivate;

#define FSO_GSM_TYPE_PLUS_CSCA (fso_gsm_plus_csca_get_type ())
#define FSO_GSM_PLUS_CSCA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CSCA, FsoGsmPlusCSCA))
#define FSO_GSM_PLUS_CSCA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CSCA, FsoGsmPlusCSCAClass))
#define FSO_GSM_IS_PLUS_CSCA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CSCA))
#define FSO_GSM_IS_PLUS_CSCA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CSCA))
#define FSO_GSM_PLUS_CSCA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CSCA, FsoGsmPlusCSCAClass))

typedef struct _FsoGsmPlusCSCA FsoGsmPlusCSCA;
typedef struct _FsoGsmPlusCSCAClass FsoGsmPlusCSCAClass;
typedef struct _FsoGsmPlusCSCAPrivate FsoGsmPlusCSCAPrivate;

#define FSO_GSM_TYPE_PLUS_CSCB (fso_gsm_plus_cscb_get_type ())
#define FSO_GSM_PLUS_CSCB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CSCB, FsoGsmPlusCSCB))
#define FSO_GSM_PLUS_CSCB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CSCB, FsoGsmPlusCSCBClass))
#define FSO_GSM_IS_PLUS_CSCB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CSCB))
#define FSO_GSM_IS_PLUS_CSCB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CSCB))
#define FSO_GSM_PLUS_CSCB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CSCB, FsoGsmPlusCSCBClass))

typedef struct _FsoGsmPlusCSCB FsoGsmPlusCSCB;
typedef struct _FsoGsmPlusCSCBClass FsoGsmPlusCSCBClass;
typedef struct _FsoGsmPlusCSCBPrivate FsoGsmPlusCSCBPrivate;

#define FSO_GSM_PLUS_CSCB_TYPE_MODE (fso_gsm_plus_cscb_mode_get_type ())

#define FSO_GSM_TYPE_PLUS_CSCS (fso_gsm_plus_cscs_get_type ())
#define FSO_GSM_PLUS_CSCS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CSCS, FsoGsmPlusCSCS))
#define FSO_GSM_PLUS_CSCS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CSCS, FsoGsmPlusCSCSClass))
#define FSO_GSM_IS_PLUS_CSCS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CSCS))
#define FSO_GSM_IS_PLUS_CSCS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CSCS))
#define FSO_GSM_PLUS_CSCS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CSCS, FsoGsmPlusCSCSClass))

typedef struct _FsoGsmPlusCSCS FsoGsmPlusCSCS;
typedef struct _FsoGsmPlusCSCSClass FsoGsmPlusCSCSClass;
typedef struct _FsoGsmPlusCSCSPrivate FsoGsmPlusCSCSPrivate;

#define FSO_GSM_TYPE_PLUS_CSQ (fso_gsm_plus_csq_get_type ())
#define FSO_GSM_PLUS_CSQ(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CSQ, FsoGsmPlusCSQ))
#define FSO_GSM_PLUS_CSQ_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CSQ, FsoGsmPlusCSQClass))
#define FSO_GSM_IS_PLUS_CSQ(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CSQ))
#define FSO_GSM_IS_PLUS_CSQ_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CSQ))
#define FSO_GSM_PLUS_CSQ_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CSQ, FsoGsmPlusCSQClass))

typedef struct _FsoGsmPlusCSQ FsoGsmPlusCSQ;
typedef struct _FsoGsmPlusCSQClass FsoGsmPlusCSQClass;
typedef struct _FsoGsmPlusCSQPrivate FsoGsmPlusCSQPrivate;

#define FSO_GSM_TYPE_PLUS_CSSI (fso_gsm_plus_cssi_get_type ())
#define FSO_GSM_PLUS_CSSI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CSSI, FsoGsmPlusCSSI))
#define FSO_GSM_PLUS_CSSI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CSSI, FsoGsmPlusCSSIClass))
#define FSO_GSM_IS_PLUS_CSSI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CSSI))
#define FSO_GSM_IS_PLUS_CSSI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CSSI))
#define FSO_GSM_PLUS_CSSI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CSSI, FsoGsmPlusCSSIClass))

typedef struct _FsoGsmPlusCSSI FsoGsmPlusCSSI;
typedef struct _FsoGsmPlusCSSIClass FsoGsmPlusCSSIClass;
typedef struct _FsoGsmPlusCSSIPrivate FsoGsmPlusCSSIPrivate;

#define FSO_GSM_TYPE_PLUS_CSSU (fso_gsm_plus_cssu_get_type ())
#define FSO_GSM_PLUS_CSSU(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CSSU, FsoGsmPlusCSSU))
#define FSO_GSM_PLUS_CSSU_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CSSU, FsoGsmPlusCSSUClass))
#define FSO_GSM_IS_PLUS_CSSU(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CSSU))
#define FSO_GSM_IS_PLUS_CSSU_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CSSU))
#define FSO_GSM_PLUS_CSSU_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CSSU, FsoGsmPlusCSSUClass))

typedef struct _FsoGsmPlusCSSU FsoGsmPlusCSSU;
typedef struct _FsoGsmPlusCSSUClass FsoGsmPlusCSSUClass;
typedef struct _FsoGsmPlusCSSUPrivate FsoGsmPlusCSSUPrivate;

#define FSO_GSM_TYPE_PLUS_CUSD (fso_gsm_plus_cusd_get_type ())
#define FSO_GSM_PLUS_CUSD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CUSD, FsoGsmPlusCUSD))
#define FSO_GSM_PLUS_CUSD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CUSD, FsoGsmPlusCUSDClass))
#define FSO_GSM_IS_PLUS_CUSD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CUSD))
#define FSO_GSM_IS_PLUS_CUSD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CUSD))
#define FSO_GSM_PLUS_CUSD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CUSD, FsoGsmPlusCUSDClass))

typedef struct _FsoGsmPlusCUSD FsoGsmPlusCUSD;
typedef struct _FsoGsmPlusCUSDClass FsoGsmPlusCUSDClass;
typedef struct _FsoGsmPlusCUSDPrivate FsoGsmPlusCUSDPrivate;

#define FSO_GSM_PLUS_CUSD_TYPE_MODE (fso_gsm_plus_cusd_mode_get_type ())

#define FSO_GSM_TYPE_PLUS_FCLASS (fso_gsm_plus_fclass_get_type ())
#define FSO_GSM_PLUS_FCLASS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_FCLASS, FsoGsmPlusFCLASS))
#define FSO_GSM_PLUS_FCLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_FCLASS, FsoGsmPlusFCLASSClass))
#define FSO_GSM_IS_PLUS_FCLASS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_FCLASS))
#define FSO_GSM_IS_PLUS_FCLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_FCLASS))
#define FSO_GSM_PLUS_FCLASS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_FCLASS, FsoGsmPlusFCLASSClass))

typedef struct _FsoGsmPlusFCLASS FsoGsmPlusFCLASS;
typedef struct _FsoGsmPlusFCLASSClass FsoGsmPlusFCLASSClass;
typedef struct _FsoGsmPlusFCLASSPrivate FsoGsmPlusFCLASSPrivate;

#define FSO_GSM_TYPE_PLUS_GCAP (fso_gsm_plus_gcap_get_type ())
#define FSO_GSM_PLUS_GCAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_GCAP, FsoGsmPlusGCAP))
#define FSO_GSM_PLUS_GCAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_GCAP, FsoGsmPlusGCAPClass))
#define FSO_GSM_IS_PLUS_GCAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_GCAP))
#define FSO_GSM_IS_PLUS_GCAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_GCAP))
#define FSO_GSM_PLUS_GCAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_GCAP, FsoGsmPlusGCAPClass))

typedef struct _FsoGsmPlusGCAP FsoGsmPlusGCAP;
typedef struct _FsoGsmPlusGCAPClass FsoGsmPlusGCAPClass;
typedef struct _FsoGsmPlusGCAPPrivate FsoGsmPlusGCAPPrivate;

#define FSO_GSM_TYPE_PLUS_VTS (fso_gsm_plus_vts_get_type ())
#define FSO_GSM_PLUS_VTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_VTS, FsoGsmPlusVTS))
#define FSO_GSM_PLUS_VTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_VTS, FsoGsmPlusVTSClass))
#define FSO_GSM_IS_PLUS_VTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_VTS))
#define FSO_GSM_IS_PLUS_VTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_VTS))
#define FSO_GSM_PLUS_VTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_VTS, FsoGsmPlusVTSClass))

typedef struct _FsoGsmPlusVTS FsoGsmPlusVTS;
typedef struct _FsoGsmPlusVTSClass FsoGsmPlusVTSClass;
typedef struct _FsoGsmPlusVTSPrivate FsoGsmPlusVTSPrivate;

#define FSO_GSM_TYPE_V250TER_COMMAND (fso_gsm_v250ter_command_get_type ())
#define FSO_GSM_V250TER_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_V250TER_COMMAND, FsoGsmV250terCommand))
#define FSO_GSM_V250TER_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_V250TER_COMMAND, FsoGsmV250terCommandClass))
#define FSO_GSM_IS_V250TER_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_V250TER_COMMAND))
#define FSO_GSM_IS_V250TER_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_V250TER_COMMAND))
#define FSO_GSM_V250TER_COMMAND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_V250TER_COMMAND, FsoGsmV250terCommandClass))

typedef struct _FsoGsmV250terCommand FsoGsmV250terCommand;
typedef struct _FsoGsmV250terCommandClass FsoGsmV250terCommandClass;
typedef struct _FsoGsmV250terCommandPrivate FsoGsmV250terCommandPrivate;

#define FSO_GSM_TYPE_V250_A (fso_gsm_v250_a_get_type ())
#define FSO_GSM_V250_A(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_V250_A, FsoGsmV250A))
#define FSO_GSM_V250_A_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_V250_A, FsoGsmV250AClass))
#define FSO_GSM_IS_V250_A(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_V250_A))
#define FSO_GSM_IS_V250_A_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_V250_A))
#define FSO_GSM_V250_A_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_V250_A, FsoGsmV250AClass))

typedef struct _FsoGsmV250A FsoGsmV250A;
typedef struct _FsoGsmV250AClass FsoGsmV250AClass;
typedef struct _FsoGsmV250APrivate FsoGsmV250APrivate;

#define FSO_GSM_TYPE_V250_D (fso_gsm_v250_d_get_type ())
#define FSO_GSM_V250_D(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_V250_D, FsoGsmV250D))
#define FSO_GSM_V250_D_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_V250_D, FsoGsmV250DClass))
#define FSO_GSM_IS_V250_D(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_V250_D))
#define FSO_GSM_IS_V250_D_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_V250_D))
#define FSO_GSM_V250_D_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_V250_D, FsoGsmV250DClass))

typedef struct _FsoGsmV250D FsoGsmV250D;
typedef struct _FsoGsmV250DClass FsoGsmV250DClass;
typedef struct _FsoGsmV250DPrivate FsoGsmV250DPrivate;

#define FSO_GSM_TYPE_V250_H (fso_gsm_v250_h_get_type ())
#define FSO_GSM_V250_H(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_V250_H, FsoGsmV250H))
#define FSO_GSM_V250_H_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_V250_H, FsoGsmV250HClass))
#define FSO_GSM_IS_V250_H(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_V250_H))
#define FSO_GSM_IS_V250_H_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_V250_H))
#define FSO_GSM_V250_H_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_V250_H, FsoGsmV250HClass))

typedef struct _FsoGsmV250H FsoGsmV250H;
typedef struct _FsoGsmV250HClass FsoGsmV250HClass;
typedef struct _FsoGsmV250HPrivate FsoGsmV250HPrivate;

#define FSO_GSM_TYPE_PLUS_CCFC (fso_gsm_plus_ccfc_get_type ())
#define FSO_GSM_PLUS_CCFC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CCFC, FsoGsmPlusCCFC))
#define FSO_GSM_PLUS_CCFC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CCFC, FsoGsmPlusCCFCClass))
#define FSO_GSM_IS_PLUS_CCFC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CCFC))
#define FSO_GSM_IS_PLUS_CCFC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CCFC))
#define FSO_GSM_PLUS_CCFC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CCFC, FsoGsmPlusCCFCClass))

typedef struct _FsoGsmPlusCCFC FsoGsmPlusCCFC;
typedef struct _FsoGsmPlusCCFCClass FsoGsmPlusCCFCClass;
typedef struct _FsoGsmPlusCCFCPrivate FsoGsmPlusCCFCPrivate;

#define FSO_GSM_CONSTANTS_TYPE_BEARER_CLASS (fso_gsm_constants_bearer_class_get_type ())

#define FSO_GSM_CONSTANTS_TYPE_CALL_FORWARDING_TYPE (fso_gsm_constants_call_forwarding_type_get_type ())

#define FSO_GSM_CONSTANTS_TYPE_CALL_FORWARDING_MODE (fso_gsm_constants_call_forwarding_mode_get_type ())

#define FSO_GSM_TYPE_PLUS_CTFR (fso_gsm_plus_ctfr_get_type ())
#define FSO_GSM_PLUS_CTFR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CTFR, FsoGsmPlusCTFR))
#define FSO_GSM_PLUS_CTFR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CTFR, FsoGsmPlusCTFRClass))
#define FSO_GSM_IS_PLUS_CTFR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CTFR))
#define FSO_GSM_IS_PLUS_CTFR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CTFR))
#define FSO_GSM_PLUS_CTFR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CTFR, FsoGsmPlusCTFRClass))

typedef struct _FsoGsmPlusCTFR FsoGsmPlusCTFR;
typedef struct _FsoGsmPlusCTFRClass FsoGsmPlusCTFRClass;
typedef struct _FsoGsmPlusCTFRPrivate FsoGsmPlusCTFRPrivate;

#define FSO_GSM_TYPE_PLUS_CSMS (fso_gsm_plus_csms_get_type ())
#define FSO_GSM_PLUS_CSMS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CSMS, FsoGsmPlusCSMS))
#define FSO_GSM_PLUS_CSMS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CSMS, FsoGsmPlusCSMSClass))
#define FSO_GSM_IS_PLUS_CSMS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CSMS))
#define FSO_GSM_IS_PLUS_CSMS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CSMS))
#define FSO_GSM_PLUS_CSMS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CSMS, FsoGsmPlusCSMSClass))

typedef struct _FsoGsmPlusCSMS FsoGsmPlusCSMS;
typedef struct _FsoGsmPlusCSMSClass FsoGsmPlusCSMSClass;
typedef struct _FsoGsmPlusCSMSPrivate FsoGsmPlusCSMSPrivate;

#define FSO_GSM_TYPE_PLUS_CMGF (fso_gsm_plus_cmgf_get_type ())
#define FSO_GSM_PLUS_CMGF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_GSM_TYPE_PLUS_CMGF, FsoGsmPlusCMGF))
#define FSO_GSM_PLUS_CMGF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_GSM_TYPE_PLUS_CMGF, FsoGsmPlusCMGFClass))
#define FSO_GSM_IS_PLUS_CMGF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_GSM_TYPE_PLUS_CMGF))
#define FSO_GSM_IS_PLUS_CMGF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_GSM_TYPE_PLUS_CMGF))
#define FSO_GSM_PLUS_CMGF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_GSM_TYPE_PLUS_CMGF, FsoGsmPlusCMGFClass))

typedef struct _FsoGsmPlusCMGF FsoGsmPlusCMGF;
typedef struct _FsoGsmPlusCMGFClass FsoGsmPlusCMGFClass;
typedef struct _FsoGsmPlusCMGFPrivate FsoGsmPlusCMGFPrivate;

struct _FsoGsmAtCommandQueueCommandIface {
	GTypeInterface parent_iface;
	guint (*get_retry) (FsoGsmAtCommandQueueCommand* self);
	guint (*get_timeout) (FsoGsmAtCommandQueueCommand* self);
	gchar* (*get_prefix) (FsoGsmAtCommandQueueCommand* self);
	gchar* (*get_postfix) (FsoGsmAtCommandQueueCommand* self);
	gboolean (*is_valid_prefix) (FsoGsmAtCommandQueueCommand* self, const gchar* line);
};

typedef enum  {
	FSO_GSM_AT_COMMAND_ERROR_UNABLE_TO_PARSE
} FsoGsmAtCommandError;
#define FSO_GSM_AT_COMMAND_ERROR fso_gsm_at_command_error_quark ()
typedef enum  {
	FSO_GSM_CONSTANTS_AT_RESPONSE_VALID = 0,
	FSO_GSM_CONSTANTS_AT_RESPONSE_OK = 1,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CONNECT = 2,
	FSO_GSM_CONSTANTS_AT_RESPONSE_UNEXPECTED_LENGTH = 501,
	FSO_GSM_CONSTANTS_AT_RESPONSE_UNABLE_TO_PARSE = 502,
	FSO_GSM_CONSTANTS_AT_RESPONSE_ERROR = 503,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_START = 1000,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_000_PHONE_FAILURE = 1000,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_001_NO_CONNECTION_TO_PHONE = 1001,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_002_PHONE_ADAPTER_LINK_RESERVED = 1002,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_003_OPERATION_NOT_ALLOWED = 1003,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_004_OPERATION_NOT_SUPPORTED = 1004,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_005_PH_SIM_PIN_REQUIRED = 1005,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_006_PH_FSIM_PIN_REQUIRED = 1006,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_007_PH_FSIM_PUK_REQUIRED = 1007,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_010_SIM_NOT_INSERTED = 1010,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_011_SIM_PIN_REQUIRED = 1011,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_012_SIM_PUK_REQUIRED = 1012,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_013_SIM_FAILURE = 1013,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_014_SIM_BUSY = 1014,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_015_SIM_WRONG = 1015,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_016_INCORRECT_PASSWORD = 1016,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_017_SIM_PIN2_REQUIRED = 1017,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_018_SIM_PUK2_REQUIRED = 1018,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_020_MEMORY_FULL = 1020,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_021_INVALID_INDEX = 1021,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_022_NOT_FOUND = 1022,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_023_MEMORY_FAILURE = 1023,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_024_TEXT_STRING_TOO_LONG = 1024,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_025_INVALID_CHARACTERS_IN_TEXT_STRING = 1025,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_026_DIAL_STRING_TOO_LONG = 1026,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_027_INVALID_CHARACTERS_IN_DIAL_STRING = 1027,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_030_NO_NETWORK_SERVICE = 1030,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_031_NETWORK_TIMEOUT = 1031,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_032_NETWORK_NOT_ALLOWED_EMERGENCY_CALLS_ONLY = 1032,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_040_NETWORK_PERSONALIZATION_PIN_REQUIRED = 1040,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_041_NETWORK_PERSONALIZATION_PUK_REQUIRED = 1041,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_042_NETWORK_SUBSET_PERSONALIZATION_PIN_REQUIRED = 1042,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_043_NETWORK_SUBSET_PERSONALIZATION_PUK_REQUIRED = 1043,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_044_SERVICE_PROVIDER_PERSONALIZATION_PIN_REQUIRED = 1044,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_045_SERVICE_PROVIDER_PERSONALIZATION_PUK_REQUIRED = 1045,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_046_CORPORATE_PERSONALIZATION_PIN_REQUIRED = 1046,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_047_CORPORATE_PERSONALIZATION_PUK_REQUIRED = 1047,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_048_PH_SIM_PUK_REQUIRED = 1048,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_100_UNKNOWN_ERROR = 1100,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_103_GPRS_ILLEGAL_MS = 1103,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_106_GPRS_ILLEGAL_ME = 1106,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_107_GPRS_SERVICES_NOT_ALLOWED = 1107,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_111_GPRS_PLMN_NOT_ALLOWED = 1111,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_112_GPRS_LOCATION_AREA_NOT_ALLOWED = 1112,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_113_GPRS_ROAMING_NOT_ALLOWED_IN_THIS_LOCATION_AREA = 1113,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_126_GPRS_OPERATION_TEMPORARY_NOT_ALLOWED = 1126,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_132_GPRS_SERVICE_OPERATION_NOT_SUPPORTED = 1132,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_133_GPRS_REQUESTED_SERVICE_OPTION_NOT_SUBSCRIBED = 1133,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_134_GPRS_SERVICE_OPTION_TEMPORARY_OUT_OF_ORDER = 1134,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_148_GPRS_UNSPECIFIED_ERROR = 1148,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_149_GPRS_PDP_AUTHENTICATION_FAILURE = 1149,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_150_GPRS_INVALID_MOBILE_CLASS = 1150,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_256_OPERATION_TEMPORARILY_NOT_ALLOWED = 1256,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_257_CALL_BARRED = 1257,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_258_PHONE_IS_BUSY = 1258,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_259_USER_ABORT = 1259,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_260_INVALID_DIAL_STRING = 1260,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_261_SS_NOT_EXECUTED = 1261,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_262_SIM_BLOCKED = 1262,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_263_INVALID_BLOCK = 1263,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_265_BUSY_TRY_AGAIN = 1265,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_512_FAILED_TO_ABORT_COMMAND = 1512,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_513_ACM_RESET_NEEDED = 1513,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_514_SIM_APPLICATION_TOOLKIT_BUSY = 1514,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CME_ERROR_772_SIM_POWERED_DOWN = 1772,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_START = 2000,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_001_UNASSIGNED_NUMBER = 2001,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_008_OPERATOR_DETERMINED_BARRING = 2008,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_010_CALL_BARED = 2010,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_021_SHORT_MESSAGE_TRANSFER_REJECTED = 2021,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_027_DESTINATION_OUT_OF_SERVICE = 2027,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_028_UNIDENTIFIED_SUBSCRIBER = 2028,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_029_FACILITY_REJECTED = 2029,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_030_UNKNOWN_SUBSCRIBER = 2030,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_038_NETWORK_OUT_OF_ORDER = 2038,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_041_TEMPORARY_FAILURE = 2041,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_042_CONGESTION = 2042,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_047_RECOURCES_UNAVAILABLE = 2047,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_050_REQUESTED_FACILITY_NOT_SUBSCRIBED = 2050,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_069_REQUESTED_FACILITY_NOT_IMPLEMENTED = 2069,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_081_INVALID_SHORT_MESSAGE_TRANSFER_REFERENCE_VALUE = 2081,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_095_INVALID_MESSAGE_UNSPECIFIED = 2095,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_096_INVALID_MANDATORY_INFORMATION = 2096,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_097_MESSAGE_TYPE_NON_EXISTENT_OR_NOT_IMPLEMENTED = 2097,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_098_MESSAGE_NOT_COMPATIBLE_WITH_SHORT_MESSAGE_PROTOCOL = 2098,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_099_INFORMATION_ELEMENT_NON_EXISTENT_OR_NOT_IMPLEMENTED = 2099,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_111_PROTOCOL_ERROR_UNSPECIFIED = 2111,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_127_INTERNETWORKING_UNSPECIFIED = 2127,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_128_TELEMATIC_INTERNETWORKING_NOT_SUPPORTED = 2128,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_129_SHORT_MESSAGE_TYPE_0_NOT_SUPPORTED = 2129,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_130_CANNOT_REPLACE_SHORT_MESSAGE = 2130,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_143_UNSPECIFIED_TP_PID_ERROR = 2143,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_144_DATA_CODE_SCHEME_NOT_SUPPORTED = 2144,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_145_MESSAGE_CLASS_NOT_SUPPORTED = 2145,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_159_UNSPECIFIED_TP_DCS_ERROR = 2159,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_160_COMMAND_CANNOT_BE_ACTIONED = 2160,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_161_COMMAND_UNSUPPORTED = 2161,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_175_UNSPECIFIED_TP_COMMAND_ERROR = 2175,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_176_TPDU_NOT_SUPPORTED = 2176,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_192_SC_BUSY = 2192,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_193_NO_SC_SUBSCRIPTION = 2193,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_194_SC_SYSTEM_FAILURE = 2194,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_195_INVALID_SME_ADDRESS = 2195,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_196_DESTINATION_SME_BARRED = 2196,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_197_SM_REJECTED_DUPLICATE_SM = 2197,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_198_TP_VPF_NOT_SUPPORTED = 2198,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_199_TP_VP_NOT_SUPPORTED = 2199,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_208_D0_SIM_SMS_STORAGE_FULL = 2208,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_209_NO_SMS_STORAGE_CAPABILITY_IN_SIM = 2209,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_210_ERROR_IN_MS = 2210,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_211_MEMORY_CAPACITY_EXCEEDED = 2211,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_212_SIM_APPLICATION_TOOLKIT_BUSY = 2212,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_213_SIM_DATA_DOWNLOAD_ERROR = 2213,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_255_UNSPECIFIED_ERROR_CAUSE = 2255,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_300_ME_FAILURE = 2300,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_301_SMS_SERVICE_OF_ME_RESERVED = 2301,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_302_OPERATION_NOT_ALLOWED = 2302,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_303_OPERATION_NOT_SUPPORTED = 2303,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_304_INVALID_PDU_MODE_PARAMETER = 2304,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_305_INVALID_TEXT_MODE_PARAMETER = 2305,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_310_SIM_NOT_INSERTED = 2310,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_311_SIM_PIN_REQUIRED = 2311,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_312_PH_SIM_PIN_REQUIRED = 2312,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_313_SIM_FAILURE = 2313,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_314_SIM_BUSY = 2314,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_315_SIM_WRONG = 2315,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_316_SIM_PUK_REQUIRED = 2316,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_317_SIM_PIN2_REQUIRED = 2317,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_318_SIM_PUK2_REQUIRED = 2318,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_320_MEMORY_FAILURE = 2320,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_321_INVALID_MEMORY_INDEX = 2321,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_322_MEMORY_FULL = 2322,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_330_SMSC_ADDRESS_UNKNOWN = 2330,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_331_NO_NETWORK_SERVICE = 2331,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_332_NETWORK_TIMEOUT = 2332,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_340_NO_CNMA_EXPECTED = 2340,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_500_UNKNOWN_ERROR = 2500,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_512_FAILED_TO_ABORT_COMMAND = 2512,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_513_ACM_RESET_NEEDED = 2513,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_514_INVALID_STATUS = 2514,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_515_DEVICE_BUSY_OR_INVALID_CHARACTER_IN_STRING = 2515,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_516_INVALID_LENGTH = 2516,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_517_INVALID_CHARACTER_IN_PDU = 2517,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_518_INVALID_PARAMETER = 2518,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_519_INVALID_LENGTH_OR_CHARACTER = 2519,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_520_INVALID_CHARACTER_IN_TEXT = 2520,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_521_TIMER_EXPIRED = 2521,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_522_OPERATION_TEMPORARY_NOT_ALLOWED = 2522,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_532_SIM_NOT_READY = 2532,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_534_CELL_BROADCAST_ERROR_UNKNOWN = 2534,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_535_PROTOCOL_STACK_BUSY = 2535,
	FSO_GSM_CONSTANTS_AT_RESPONSE_CMS_ERROR_538_INVALID_PARAMETER = 2538,
	FSO_GSM_CONSTANTS_AT_RESPONSE_EXT_ERROR_START = 3000,
	FSO_GSM_CONSTANTS_AT_RESPONSE_EXT_ERROR_0_INVALID_PARAMETERR = 3000
} FsoGsmConstantsAtResponse;

struct _FsoGsmAtCommandIface {
	GTypeInterface parent_iface;
	guint (*get_timeout) (FsoGsmAtCommand* self);
	guint (*get_retry) (FsoGsmAtCommand* self);
	gchar* (*get_prefix) (FsoGsmAtCommand* self);
	gchar* (*get_postfix) (FsoGsmAtCommand* self);
	gboolean (*is_valid_prefix) (FsoGsmAtCommand* self, const gchar* line);
	void (*parse) (FsoGsmAtCommand* self, const gchar* response, GError** error);
	void (*parseMulti) (FsoGsmAtCommand* self, gchar** response, int response_length1, GError** error);
	void (*parseTest) (FsoGsmAtCommand* self, const gchar* response, GError** error);
	gchar* (*encodeString) (FsoGsmAtCommand* self, const gchar* str);
	gchar* (*decodeString) (FsoGsmAtCommand* self, const gchar* str);
	FsoGsmConstantsAtResponse (*validate) (FsoGsmAtCommand* self, gchar** response, int response_length1);
	FsoGsmConstantsAtResponse (*validateTest) (FsoGsmAtCommand* self, gchar** response, int response_length1);
	FsoGsmConstantsAtResponse (*validateUrc) (FsoGsmAtCommand* self, const gchar* response);
	FsoGsmConstantsAtResponse (*validateUrcPdu) (FsoGsmAtCommand* self, gchar** response, int response_length1);
	FsoGsmConstantsAtResponse (*validateOk) (FsoGsmAtCommand* self, gchar** response, int response_length1);
	FsoGsmConstantsAtResponse (*validateMulti) (FsoGsmAtCommand* self, gchar** response, int response_length1);
};

struct _FsoGsmAbstractAtCommand {
	GObject parent_instance;
	FsoGsmAbstractAtCommandPrivate * priv;
	GRegex* re;
	GRegex* tere;
	GMatchInfo* mi;
	gchar** prefix;
	gint prefix_length1;
	gint length;
};

struct _FsoGsmAbstractAtCommandClass {
	GObjectClass parent_class;
	void (*parse) (FsoGsmAbstractAtCommand* self, const gchar* response, GError** error);
	void (*parseTest) (FsoGsmAbstractAtCommand* self, const gchar* response, GError** error);
	void (*parseMulti) (FsoGsmAbstractAtCommand* self, gchar** response, int response_length1, GError** error);
	FsoGsmConstantsAtResponse (*validateOk) (FsoGsmAbstractAtCommand* self, gchar** response, int response_length1);
	FsoGsmConstantsAtResponse (*validate) (FsoGsmAbstractAtCommand* self, gchar** response, int response_length1);
	FsoGsmConstantsAtResponse (*validateTest) (FsoGsmAbstractAtCommand* self, gchar** response, int response_length1);
	FsoGsmConstantsAtResponse (*validateMulti) (FsoGsmAbstractAtCommand* self, gchar** response, int response_length1);
	FsoGsmConstantsAtResponse (*validateUrc) (FsoGsmAbstractAtCommand* self, const gchar* response);
	FsoGsmConstantsAtResponse (*validateUrcPdu) (FsoGsmAbstractAtCommand* self, gchar** response, int response_length1);
	guint (*get_timeout) (FsoGsmAbstractAtCommand* self);
	guint (*get_retry) (FsoGsmAbstractAtCommand* self);
	gchar* (*get_prefix) (FsoGsmAbstractAtCommand* self);
	gchar* (*get_postfix) (FsoGsmAbstractAtCommand* self);
};

struct _FsoGsmPlusCALA {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCALAPrivate * priv;
	gint year;
	gint month;
	gint day;
	gint hour;
	gint minute;
	gint second;
	gint tzoffset;
};

struct _FsoGsmPlusCALAClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

typedef enum  {
	FSO_GSM_PLUS_CBC_STATUS_DISCHARGING = 0,
	FSO_GSM_PLUS_CBC_STATUS_CHARGING = 1,
	FSO_GSM_PLUS_CBC_STATUS_AC = 2,
	FSO_GSM_PLUS_CBC_STATUS_UNKNOWN = 3
} FsoGsmPlusCBCStatus;

struct _FsoGsmPlusCBC {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCBCPrivate * priv;
	FsoGsmPlusCBCStatus status;
	gint level;
};

struct _FsoGsmPlusCBCClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCBM {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCBMPrivate * priv;
	gchar* hexpdu;
	gint tpdulen;
};

struct _FsoGsmPlusCBMClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCCLK {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCCLKPrivate * priv;
	gint year;
	gint month;
	gint day;
	gint hour;
	gint minute;
	gint second;
	gint tzoffset;
};

struct _FsoGsmPlusCCLKClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCDS {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCDSPrivate * priv;
	gchar* hexpdu;
	gint tpdulen;
};

struct _FsoGsmPlusCDSClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCEER {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCEERPrivate * priv;
	gchar* reason;
};

struct _FsoGsmPlusCEERClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmSimpleAtCommand {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmSimpleAtCommandPrivate * priv;
	gpointer value;
	gchar* righthandside;
	gint min;
	gint max;
};

struct _FsoGsmSimpleAtCommandClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCFUN {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCFUNPrivate * priv;
};

struct _FsoGsmPlusCFUNClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCGACT {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCGACTPrivate * priv;
};

struct _FsoGsmPlusCGACTClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCGATT {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCGATTPrivate * priv;
};

struct _FsoGsmPlusCGATTClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCGCLASS {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCGCLASSPrivate * priv;
};

struct _FsoGsmPlusCGCLASSClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCGDCONT {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCGDCONTPrivate * priv;
};

struct _FsoGsmPlusCGDCONTClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCGMI {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCGMIPrivate * priv;
};

struct _FsoGsmPlusCGMIClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCGMM {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCGMMPrivate * priv;
};

struct _FsoGsmPlusCGMMClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCGMR {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCGMRPrivate * priv;
};

struct _FsoGsmPlusCGMRClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCGREG {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCGREGPrivate * priv;
	gint mode;
	gint status;
	gchar* lac;
	gchar* cid;
};

struct _FsoGsmPlusCGREGClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCGSN {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCGSNPrivate * priv;
};

struct _FsoGsmPlusCGSNClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCHLD {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCHLDPrivate * priv;
};

struct _FsoGsmPlusCHLDClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

typedef enum  {
	FSO_GSM_PLUS_CHLD_ACTION_DROP_ALL_OR_SEND_BUSY = 0,
	FSO_GSM_PLUS_CHLD_ACTION_DROP_ALL_AND_ACCEPT_WAITING_OR_HELD = 1,
	FSO_GSM_PLUS_CHLD_ACTION_DROP_SPECIFIC_AND_ACCEPT_WAITING_OR_HELD = 1,
	FSO_GSM_PLUS_CHLD_ACTION_HOLD_ALL_AND_ACCEPT_WAITING_OR_HELD = 2,
	FSO_GSM_PLUS_CHLD_ACTION_HOLD_SPECIFIC_AND_ACCEPT_WAITING_OR_HELD = 2,
	FSO_GSM_PLUS_CHLD_ACTION_ACTIVATE_HELD = 3,
	FSO_GSM_PLUS_CHLD_ACTION_DROP_SELF_AND_CONNECT_ACTIVE = 4
} FsoGsmPlusCHLDAction;

struct _FsoGsmTwoParamsAtCommand {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmTwoParamsAtCommandPrivate * priv;
	gpointer value1;
	gpointer value2;
};

struct _FsoGsmTwoParamsAtCommandClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCIEV {
	FsoGsmTwoParamsAtCommand parent_instance;
	FsoGsmPlusCIEVPrivate * priv;
};

struct _FsoGsmPlusCIEVClass {
	FsoGsmTwoParamsAtCommandClass parent_class;
};

struct _FsoGsmPlusCIMI {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCIMIPrivate * priv;
};

struct _FsoGsmPlusCIMIClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCLCC {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCLCCPrivate * priv;
	FreeSmartphoneGSMCallDetail* calls;
	gint calls_length1;
};

struct _FsoGsmPlusCLCCClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCLCK {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCLCKPrivate * priv;
	gboolean enabled;
	gint klass;
	gchar* facilities;
};

struct _FsoGsmPlusCLCKClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

typedef enum  {
	FSO_GSM_PLUS_CLCK_MODE_DISABLE = 0,
	FSO_GSM_PLUS_CLCK_MODE_ENABLE = 1,
	FSO_GSM_PLUS_CLCK_MODE_QUERY = 2
} FsoGsmPlusCLCKMode;

struct _FsoGsmPlusCLIR {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCLIRPrivate * priv;
};

struct _FsoGsmPlusCLIRClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCLVL {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCLVLPrivate * priv;
};

struct _FsoGsmPlusCLVLClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCMGD {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCMGDPrivate * priv;
};

struct _FsoGsmPlusCMGDClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCMGL {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCMGLPrivate * priv;
	GeeArrayList* messagebook;
};

struct _FsoGsmPlusCMGLClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

typedef enum  {
	FSO_GSM_PLUS_CMGL_MODE_INVALID = -1,
	FSO_GSM_PLUS_CMGL_MODE_REC_UNREAD = 0,
	FSO_GSM_PLUS_CMGL_MODE_REC_READ = 1,
	FSO_GSM_PLUS_CMGL_MODE_STO_UNSENT = 2,
	FSO_GSM_PLUS_CMGL_MODE_STO_SENT = 3,
	FSO_GSM_PLUS_CMGL_MODE_ALL = 4
} FsoGsmPlusCMGLMode;

struct _FsoGsmPlusCMGR {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCMGRPrivate * priv;
	FsoGsmPlusCMGLMode status;
	gchar* hexpdu;
	gint tpdulen;
};

struct _FsoGsmPlusCMGRClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCMGS {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCMGSPrivate * priv;
	gint refnum;
};

struct _FsoGsmPlusCMGSClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _WrapHexPdu {
	GTypeInstance parent_instance;
	volatile int ref_count;
	WrapHexPduPrivate * priv;
	gchar* hexpdu;
	guint tpdulen;
	gint transaction_index;
};

struct _WrapHexPduClass {
	GTypeClass parent_class;
	void (*finalize) (WrapHexPdu *self);
};

struct _FsoGsmPlusCMGW {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCMGWPrivate * priv;
	gint memory_index;
};

struct _FsoGsmPlusCMGWClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCMICKEY {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCMICKEYPrivate * priv;
};

struct _FsoGsmPlusCMICKEYClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCMSS {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCMSSPrivate * priv;
	gint refnum;
};

struct _FsoGsmPlusCMSSClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCMT {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCMTPrivate * priv;
	gchar* hexpdu;
	gint tpdulen;
};

struct _FsoGsmPlusCMTClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCMTI {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCMTIPrivate * priv;
	gchar* storage;
	gint index;
};

struct _FsoGsmPlusCMTIClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCMMS {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCMMSPrivate * priv;
};

struct _FsoGsmPlusCMMSClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCMUT {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCMUTPrivate * priv;
};

struct _FsoGsmPlusCMUTClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCNMA {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCNMAPrivate * priv;
};

struct _FsoGsmPlusCNMAClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCNMI {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCNMIPrivate * priv;
};

struct _FsoGsmPlusCNMIClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCNMIPrivate {
	gint _mode;
	gint _mt;
	gint _bm;
	gint _ds;
	gint _bfr;
	GHashTable* _supported_opts;
};

struct _FsoGsmPlusCOPN {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCOPNPrivate * priv;
	GHashTable* operators;
};

struct _FsoGsmPlusCOPNClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCOPS {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCOPSPrivate * priv;
	gint format;
	gint mode;
	gchar* oper;
	gchar* act;
	FreeSmartphoneGSMNetworkProvider* providers;
	gint providers_length1;
};

struct _FsoGsmPlusCOPSClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

typedef enum  {
	FSO_GSM_PLUS_COPS_ACTION_REGISTER_WITH_BEST_PROVIDER = 0,
	FSO_GSM_PLUS_COPS_ACTION_REGISTER_WITH_SPECIFIC_PROVIDER = 1,
	FSO_GSM_PLUS_COPS_ACTION_UNREGISTER = 2,
	FSO_GSM_PLUS_COPS_ACTION_SET_FORMAT = 3
} FsoGsmPlusCOPSAction;

typedef enum  {
	FSO_GSM_PLUS_COPS_FORMAT_ALPHANUMERIC = 0,
	FSO_GSM_PLUS_COPS_FORMAT_ALPHANUMERIC_SHORT = 1,
	FSO_GSM_PLUS_COPS_FORMAT_NUMERIC = 2
} FsoGsmPlusCOPSFormat;

struct _FsoGsmPlusCPBR {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCPBRPrivate * priv;
	gint min;
	gint max;
	FreeSmartphoneGSMSIMEntry* phonebook;
	gint phonebook_length1;
};

struct _FsoGsmPlusCPBRClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCPBS {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCPBSPrivate * priv;
	gchar** phonebooks;
	gint phonebooks_length1;
};

struct _FsoGsmPlusCPBSClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCPBW {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCPBWPrivate * priv;
	gint max;
	gint nlength;
	gint tlength;
};

struct _FsoGsmPlusCPBWClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCPIN {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCPINPrivate * priv;
	FreeSmartphoneGSMSIMAuthStatus status;
};

struct _FsoGsmPlusCPINClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCPMS {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCPMSPrivate * priv;
	gint used;
	gint total;
};

struct _FsoGsmPlusCPMSClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCPWD {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCPWDPrivate * priv;
};

struct _FsoGsmPlusCPWDClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCREG {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCREGPrivate * priv;
	gint mode;
	gint status;
	gchar* lac;
	gchar* cid;
};

struct _FsoGsmPlusCREGClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

typedef enum  {
	FSO_GSM_PLUS_CREG_MODE_DISABLE = 0,
	FSO_GSM_PLUS_CREG_MODE_ENABLE_WITH_NETORK_REGISTRATION = 1,
	FSO_GSM_PLUS_CREG_MODE_ENABLE_WITH_NETORK_REGISTRATION_AND_LOCATION = 2
} FsoGsmPlusCREGMode;

struct _FsoGsmPlusCRSM {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCRSMPrivate * priv;
	gchar* payload;
};

struct _FsoGsmPlusCRSMClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCSCA {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCSCAPrivate * priv;
	gchar* number;
};

struct _FsoGsmPlusCSCAClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCSCB {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCSCBPrivate * priv;
	gint mode;
	gint channels;
	gint encodings;
};

struct _FsoGsmPlusCSCBClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

typedef enum  {
	FSO_GSM_PLUS_CSCB_MODE_NONE,
	FSO_GSM_PLUS_CSCB_MODE_ALL
} FsoGsmPlusCSCBMode;

struct _FsoGsmPlusCSCS {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCSCSPrivate * priv;
};

struct _FsoGsmPlusCSCSClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCSQ {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCSQPrivate * priv;
	gint signal;
};

struct _FsoGsmPlusCSQClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCSSI {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCSSIPrivate * priv;
};

struct _FsoGsmPlusCSSIClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusCSSU {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusCSSUPrivate * priv;
};

struct _FsoGsmPlusCSSUClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

typedef enum  {
	FSO_GSM_PLUS_CUSD_MODE_COMPLETED = 0,
	FSO_GSM_PLUS_CUSD_MODE_USERACTION = 1,
	FSO_GSM_PLUS_CUSD_MODE_TERMINATED = 2,
	FSO_GSM_PLUS_CUSD_MODE_LOCALCLIENT = 3,
	FSO_GSM_PLUS_CUSD_MODE_UNSUPPORTED = 4,
	FSO_GSM_PLUS_CUSD_MODE_TIMEOUT = 5
} FsoGsmPlusCUSDMode;

struct _FsoGsmPlusCUSD {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCUSDPrivate * priv;
	FsoGsmPlusCUSDMode mode;
	gchar* result;
	gint code;
};

struct _FsoGsmPlusCUSDClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusFCLASS {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusFCLASSPrivate * priv;
};

struct _FsoGsmPlusFCLASSClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusGCAP {
	FsoGsmSimpleAtCommand parent_instance;
	FsoGsmPlusGCAPPrivate * priv;
};

struct _FsoGsmPlusGCAPClass {
	FsoGsmSimpleAtCommandClass parent_class;
};

struct _FsoGsmPlusVTS {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusVTSPrivate * priv;
};

struct _FsoGsmPlusVTSClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmV250terCommand {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmV250terCommandPrivate * priv;
	gchar* name;
};

struct _FsoGsmV250terCommandClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmV250A {
	FsoGsmV250terCommand parent_instance;
	FsoGsmV250APrivate * priv;
};

struct _FsoGsmV250AClass {
	FsoGsmV250terCommandClass parent_class;
};

struct _FsoGsmV250D {
	FsoGsmV250terCommand parent_instance;
	FsoGsmV250DPrivate * priv;
};

struct _FsoGsmV250DClass {
	FsoGsmV250terCommandClass parent_class;
};

struct _FsoGsmV250H {
	FsoGsmV250terCommand parent_instance;
	FsoGsmV250HPrivate * priv;
};

struct _FsoGsmV250HClass {
	FsoGsmV250terCommandClass parent_class;
};

struct _FsoGsmPlusCCFC {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCCFCPrivate * priv;
};

struct _FsoGsmPlusCCFCClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

typedef enum  {
	FSO_GSM_CONSTANTS_BEARER_CLASS_UNKNOWN = 0,
	FSO_GSM_CONSTANTS_BEARER_CLASS_VOICE = 1,
	FSO_GSM_CONSTANTS_BEARER_CLASS_DATA = 2,
	FSO_GSM_CONSTANTS_BEARER_CLASS_FAX = 4,
	FSO_GSM_CONSTANTS_BEARER_CLASS_DEFAULT = 7,
	FSO_GSM_CONSTANTS_BEARER_CLASS_SMS = 8,
	FSO_GSM_CONSTANTS_BEARER_CLASS_DATA_SYNC = 16,
	FSO_GSM_CONSTANTS_BEARER_CLASS_DATA_ASYNC = 32,
	FSO_GSM_CONSTANTS_BEARER_CLASS_SS_DEFAULT = 61,
	FSO_GSM_CONSTANTS_BEARER_CLASS_PACKET = 64,
	FSO_GSM_CONSTANTS_BEARER_CLASS_PAD = 128
} FsoGsmConstantsBearerClass;

struct _FsoGsmPlusCCFCPrivate {
	gboolean _active;
	FsoGsmConstantsBearerClass _class1;
	gchar* _number;
	gint _number_type;
	gchar* _subaddr;
	gint _satype;
	gint _timeout;
};

typedef enum  {
	FSO_GSM_CONSTANTS_CALL_FORWARDING_TYPE_UNCONDITIONAL = 0,
	FSO_GSM_CONSTANTS_CALL_FORWARDING_TYPE_BUSY = 1,
	FSO_GSM_CONSTANTS_CALL_FORWARDING_TYPE_NO_REPLY = 2,
	FSO_GSM_CONSTANTS_CALL_FORWARDING_TYPE_NOT_REACHABLE = 3,
	FSO_GSM_CONSTANTS_CALL_FORWARDING_TYPE_ALL = 4,
	FSO_GSM_CONSTANTS_CALL_FORWARDING_TYPE_ALL_CONDITIONAL = 5
} FsoGsmConstantsCallForwardingType;

typedef enum  {
	FSO_GSM_CONSTANTS_CALL_FORWARDING_MODE_DISABLE = 0,
	FSO_GSM_CONSTANTS_CALL_FORWARDING_MODE_ENABLE = 1,
	FSO_GSM_CONSTANTS_CALL_FORWARDING_MODE_QUERY_STATUS = 2,
	FSO_GSM_CONSTANTS_CALL_FORWARDING_MODE_REGISTRATION = 3,
	FSO_GSM_CONSTANTS_CALL_FORWARDING_MODE_ERASURE = 4
} FsoGsmConstantsCallForwardingMode;

struct _FsoGsmPlusCTFR {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCTFRPrivate * priv;
};

struct _FsoGsmPlusCTFRClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCSMS {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCSMSPrivate * priv;
};

struct _FsoGsmPlusCSMSClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCSMSPrivate {
	gint _mt;
	gint _mo;
	gint _bm;
	gint* _supported_services;
	gint _supported_services_length1;
	gint __supported_services_size_;
};

struct _FsoGsmPlusCMGF {
	FsoGsmAbstractAtCommand parent_instance;
	FsoGsmPlusCMGFPrivate * priv;
};

struct _FsoGsmPlusCMGFClass {
	FsoGsmAbstractAtCommandClass parent_class;
};

struct _FsoGsmPlusCMGFPrivate {
	gint _mode;
	gint* _supported_modes;
	gint _supported_modes_length1;
	gint __supported_modes_size_;
};


static gpointer fso_gsm_plus_cala_parent_class = NULL;
static gpointer fso_gsm_plus_cbc_parent_class = NULL;
static gpointer fso_gsm_plus_cbm_parent_class = NULL;
static gpointer fso_gsm_plus_cclk_parent_class = NULL;
static gpointer fso_gsm_plus_cds_parent_class = NULL;
static gpointer fso_gsm_plus_ceer_parent_class = NULL;
static gpointer fso_gsm_plus_cfun_parent_class = NULL;
static gpointer fso_gsm_plus_cgact_parent_class = NULL;
static gpointer fso_gsm_plus_cgatt_parent_class = NULL;
static gpointer fso_gsm_plus_cgclass_parent_class = NULL;
static gpointer fso_gsm_plus_cgdcont_parent_class = NULL;
static gpointer fso_gsm_plus_cgmi_parent_class = NULL;
static gpointer fso_gsm_plus_cgmm_parent_class = NULL;
static gpointer fso_gsm_plus_cgmr_parent_class = NULL;
static gpointer fso_gsm_plus_cgreg_parent_class = NULL;
static gpointer fso_gsm_plus_cgsn_parent_class = NULL;
static gpointer fso_gsm_plus_chld_parent_class = NULL;
static gpointer fso_gsm_plus_ciev_parent_class = NULL;
static gpointer fso_gsm_plus_cimi_parent_class = NULL;
static gpointer fso_gsm_plus_clcc_parent_class = NULL;
static gpointer fso_gsm_plus_clck_parent_class = NULL;
static gpointer fso_gsm_plus_clir_parent_class = NULL;
static gpointer fso_gsm_plus_clvl_parent_class = NULL;
static gpointer fso_gsm_plus_cmgd_parent_class = NULL;
static gpointer fso_gsm_plus_cmgl_parent_class = NULL;
static gpointer fso_gsm_plus_cmgr_parent_class = NULL;
static gpointer fso_gsm_plus_cmgs_parent_class = NULL;
static gpointer fso_gsm_plus_cmgw_parent_class = NULL;
static gpointer fso_gsm_plus_cmickey_parent_class = NULL;
static gpointer fso_gsm_plus_cmss_parent_class = NULL;
static gpointer fso_gsm_plus_cmt_parent_class = NULL;
static gpointer fso_gsm_plus_cmti_parent_class = NULL;
static gpointer fso_gsm_plus_cmms_parent_class = NULL;
static gpointer fso_gsm_plus_cmut_parent_class = NULL;
static gpointer fso_gsm_plus_cnma_parent_class = NULL;
static gpointer fso_gsm_plus_cnmi_parent_class = NULL;
static gpointer fso_gsm_plus_copn_parent_class = NULL;
static gpointer fso_gsm_plus_cops_parent_class = NULL;
extern gboolean fso_gsm_plus_cops_providerNameDeliveredInConfiguredCharset;
gboolean fso_gsm_plus_cops_providerNameDeliveredInConfiguredCharset = FALSE;
static gpointer fso_gsm_plus_cpbr_parent_class = NULL;
static gpointer fso_gsm_plus_cpbs_parent_class = NULL;
static gpointer fso_gsm_plus_cpbw_parent_class = NULL;
static gpointer fso_gsm_plus_cpin_parent_class = NULL;
static gpointer fso_gsm_plus_cpms_parent_class = NULL;
static gpointer fso_gsm_plus_cpwd_parent_class = NULL;
static gpointer fso_gsm_plus_creg_parent_class = NULL;
static gpointer fso_gsm_plus_crsm_parent_class = NULL;
static gpointer fso_gsm_plus_csca_parent_class = NULL;
static gpointer fso_gsm_plus_cscb_parent_class = NULL;
static gpointer fso_gsm_plus_cscs_parent_class = NULL;
static gpointer fso_gsm_plus_csq_parent_class = NULL;
static gpointer fso_gsm_plus_cssi_parent_class = NULL;
static gpointer fso_gsm_plus_cssu_parent_class = NULL;
static gpointer fso_gsm_plus_cusd_parent_class = NULL;
static gpointer fso_gsm_plus_fclass_parent_class = NULL;
static gpointer fso_gsm_plus_gcap_parent_class = NULL;
static gpointer fso_gsm_plus_vts_parent_class = NULL;
static gpointer fso_gsm_v250_a_parent_class = NULL;
static gpointer fso_gsm_v250_d_parent_class = NULL;
static gpointer fso_gsm_v250_h_parent_class = NULL;
static gpointer fso_gsm_plus_ccfc_parent_class = NULL;
static gpointer fso_gsm_plus_ctfr_parent_class = NULL;
static gpointer fso_gsm_plus_csms_parent_class = NULL;
static gpointer fso_gsm_plus_cmgf_parent_class = NULL;

#define FSO_GSM_MODEM_COMM_TIMEOUT ((guint) 5)
#define FSO_GSM_SIM_COMM_TIMEOUT ((guint) 20)
#define FSO_GSM_NETWORK_COMM_TIMEOUT ((guint) 120)
#define FSO_GSM_VOICE_COMM_TIMEOUT ((guint) (3600 * 24))
GType fso_gsm_at_command_queue_command_get_type (void) G_GNUC_CONST;
GQuark fso_gsm_at_command_error_quark (void);
GType fso_gsm_constants_at_response_get_type (void) G_GNUC_CONST;
GType fso_gsm_at_command_get_type (void) G_GNUC_CONST;
GType fso_gsm_abstract_at_command_get_type (void) G_GNUC_CONST;
GType fso_gsm_plus_cala_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CALA_DUMMY_PROPERTY
};
FsoGsmPlusCALA* fso_gsm_plus_cala_new (void);
FsoGsmPlusCALA* fso_gsm_plus_cala_construct (GType object_type);
FsoGsmAbstractAtCommand* fso_gsm_abstract_at_command_construct (GType object_type);
static void fso_gsm_plus_cala_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
void fso_gsm_abstract_at_command_parse (FsoGsmAbstractAtCommand* self, const gchar* response, GError** error);
gint fso_gsm_abstract_at_command_to_int (FsoGsmAbstractAtCommand* self, const gchar* name);
gchar* fso_gsm_plus_cala_issue (FsoGsmPlusCALA* self, gint year, gint month, gint day, gint hour, gint minute, gint second, gint tzoffset);
gchar* fso_gsm_plus_cala_clear (FsoGsmPlusCALA* self);
gchar* fso_gsm_plus_cala_query (FsoGsmPlusCALA* self);
static void fso_gsm_plus_cala_finalize (GObject* obj);
GType fso_gsm_plus_cbc_get_type (void) G_GNUC_CONST;
GType fso_gsm_plus_cbc_status_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CBC_DUMMY_PROPERTY
};
FsoGsmPlusCBC* fso_gsm_plus_cbc_new (void);
FsoGsmPlusCBC* fso_gsm_plus_cbc_construct (GType object_type);
static void fso_gsm_plus_cbc_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_cbc_execute (FsoGsmPlusCBC* self);
static void fso_gsm_plus_cbc_finalize (GObject* obj);
GType fso_gsm_plus_cbm_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CBM_DUMMY_PROPERTY
};
FsoGsmPlusCBM* fso_gsm_plus_cbm_new (void);
FsoGsmPlusCBM* fso_gsm_plus_cbm_construct (GType object_type);
static void fso_gsm_plus_cbm_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error);
static void fso_gsm_plus_cbm_finalize (GObject* obj);
GType fso_gsm_plus_cclk_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CCLK_DUMMY_PROPERTY
};
FsoGsmPlusCCLK* fso_gsm_plus_cclk_new (void);
FsoGsmPlusCCLK* fso_gsm_plus_cclk_construct (GType object_type);
static void fso_gsm_plus_cclk_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_cclk_issue (FsoGsmPlusCCLK* self, gint year, gint month, gint day, gint hour, gint minute, gint second, gint tzoffset);
gchar* fso_gsm_plus_cclk_query (FsoGsmPlusCCLK* self);
static void fso_gsm_plus_cclk_finalize (GObject* obj);
GType fso_gsm_plus_cds_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CDS_DUMMY_PROPERTY
};
FsoGsmPlusCDS* fso_gsm_plus_cds_new (void);
FsoGsmPlusCDS* fso_gsm_plus_cds_construct (GType object_type);
static void fso_gsm_plus_cds_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error);
static void fso_gsm_plus_cds_finalize (GObject* obj);
GType fso_gsm_plus_ceer_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CEER_DUMMY_PROPERTY
};
FsoGsmPlusCEER* fso_gsm_plus_ceer_new (void);
FsoGsmPlusCEER* fso_gsm_plus_ceer_construct (GType object_type);
static void fso_gsm_plus_ceer_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_constants_ceerCauseToString (gint location, gint reason, gint ssrelease);
gchar* fso_gsm_plus_ceer_execute (FsoGsmPlusCEER* self);
static void fso_gsm_plus_ceer_finalize (GObject* obj);
GType fso_gsm_simple_at_command_get_type (void) G_GNUC_CONST;
GType fso_gsm_plus_cfun_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CFUN_DUMMY_PROPERTY
};
FsoGsmPlusCFUN* fso_gsm_plus_cfun_new (void);
FsoGsmPlusCFUN* fso_gsm_plus_cfun_construct (GType object_type);
FsoGsmSimpleAtCommand* fso_gsm_simple_at_command_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, const gchar* name, gboolean prefixoptional);
FsoGsmSimpleAtCommand* fso_gsm_simple_at_command_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, const gchar* name, gboolean prefixoptional);
static guint fso_gsm_plus_cfun_real_get_timeout (FsoGsmAbstractAtCommand* base);
GType fso_gsm_plus_cgact_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CGACT_DUMMY_PROPERTY
};
FsoGsmPlusCGACT* fso_gsm_plus_cgact_new (void);
FsoGsmPlusCGACT* fso_gsm_plus_cgact_construct (GType object_type);
GType fso_gsm_plus_cgatt_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CGATT_DUMMY_PROPERTY
};
FsoGsmPlusCGATT* fso_gsm_plus_cgatt_new (void);
FsoGsmPlusCGATT* fso_gsm_plus_cgatt_construct (GType object_type);
GType fso_gsm_plus_cgclass_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CGCLASS_DUMMY_PROPERTY
};
FsoGsmPlusCGCLASS* fso_gsm_plus_cgclass_new (void);
FsoGsmPlusCGCLASS* fso_gsm_plus_cgclass_construct (GType object_type);
GType fso_gsm_plus_cgdcont_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CGDCONT_DUMMY_PROPERTY
};
FsoGsmPlusCGDCONT* fso_gsm_plus_cgdcont_new (void);
FsoGsmPlusCGDCONT* fso_gsm_plus_cgdcont_construct (GType object_type);
gchar* fso_gsm_plus_cgdcont_issue (FsoGsmPlusCGDCONT* self, const gchar* apn);
GType fso_gsm_plus_cgmi_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CGMI_DUMMY_PROPERTY
};
FsoGsmPlusCGMI* fso_gsm_plus_cgmi_new (void);
FsoGsmPlusCGMI* fso_gsm_plus_cgmi_construct (GType object_type);
GType fso_gsm_plus_cgmm_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CGMM_DUMMY_PROPERTY
};
FsoGsmPlusCGMM* fso_gsm_plus_cgmm_new (void);
FsoGsmPlusCGMM* fso_gsm_plus_cgmm_construct (GType object_type);
GType fso_gsm_plus_cgmr_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CGMR_DUMMY_PROPERTY
};
FsoGsmPlusCGMR* fso_gsm_plus_cgmr_new (void);
FsoGsmPlusCGMR* fso_gsm_plus_cgmr_construct (GType object_type);
GType fso_gsm_plus_cgreg_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CGREG_DUMMY_PROPERTY
};
FsoGsmPlusCGREG* fso_gsm_plus_cgreg_new (void);
FsoGsmPlusCGREG* fso_gsm_plus_cgreg_construct (GType object_type);
static void fso_gsm_plus_cgreg_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_abstract_at_command_to_string (FsoGsmAbstractAtCommand* self, const gchar* name);
gchar* fso_gsm_plus_cgreg_query (FsoGsmPlusCGREG* self);
gchar* fso_gsm_plus_cgreg_issue (FsoGsmPlusCGREG* self, gint mode);
gchar* fso_gsm_plus_cgreg_queryFull (FsoGsmPlusCGREG* self, gint restoreMode);
static void fso_gsm_plus_cgreg_finalize (GObject* obj);
GType fso_gsm_plus_cgsn_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CGSN_DUMMY_PROPERTY
};
FsoGsmPlusCGSN* fso_gsm_plus_cgsn_new (void);
FsoGsmPlusCGSN* fso_gsm_plus_cgsn_construct (GType object_type);
GType fso_gsm_plus_chld_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CHLD_DUMMY_PROPERTY
};
GType fso_gsm_plus_chld_action_get_type (void) G_GNUC_CONST;
gchar* fso_gsm_plus_chld_issue (FsoGsmPlusCHLD* self, FsoGsmPlusCHLDAction action, gint cid);
FsoGsmPlusCHLD* fso_gsm_plus_chld_new (void);
FsoGsmPlusCHLD* fso_gsm_plus_chld_construct (GType object_type);
GType fso_gsm_two_params_at_command_get_type (void) G_GNUC_CONST;
GType fso_gsm_plus_ciev_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CIEV_DUMMY_PROPERTY
};
FsoGsmPlusCIEV* fso_gsm_plus_ciev_new (void);
FsoGsmPlusCIEV* fso_gsm_plus_ciev_construct (GType object_type);
FsoGsmTwoParamsAtCommand* fso_gsm_two_params_at_command_new (GType t1_type, GBoxedCopyFunc t1_dup_func, GDestroyNotify t1_destroy_func, GType t2_type, GBoxedCopyFunc t2_dup_func, GDestroyNotify t2_destroy_func, const gchar* name, gboolean prefixoptional);
FsoGsmTwoParamsAtCommand* fso_gsm_two_params_at_command_construct (GType object_type, GType t1_type, GBoxedCopyFunc t1_dup_func, GDestroyNotify t1_destroy_func, GType t2_type, GBoxedCopyFunc t2_dup_func, GDestroyNotify t2_destroy_func, const gchar* name, gboolean prefixoptional);
GType fso_gsm_plus_cimi_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CIMI_DUMMY_PROPERTY
};
FsoGsmPlusCIMI* fso_gsm_plus_cimi_new (void);
FsoGsmPlusCIMI* fso_gsm_plus_cimi_construct (GType object_type);
GType fso_gsm_plus_clcc_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CLCC_DUMMY_PROPERTY
};
static void _vala_FreeSmartphoneGSMCallDetail_array_free (FreeSmartphoneGSMCallDetail* array, gint array_length);
FsoGsmPlusCLCC* fso_gsm_plus_clcc_new (void);
FsoGsmPlusCLCC* fso_gsm_plus_clcc_construct (GType object_type);
static void fso_gsm_plus_clcc_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error);
FreeSmartphoneGSMCallStatus fso_gsm_constants_callStatusToEnum (gint code);
static void _g_free0_ (gpointer var);
static void _g_variant_unref0_ (gpointer var);
gchar* fso_gsm_constants_callDirectionToString (gint code);
static GVariant* _variant_new3 (gchar* value);
gchar* fso_gsm_constants_phonenumberTupleToString (const gchar* number, gint ntype);
static GVariant* _variant_new4 (gchar* value);
gchar* fso_gsm_constants_callTypeToString (gint code);
static GVariant* _variant_new5 (gchar* value);
static void _vala_array_add1 (FreeSmartphoneGSMCallDetail** array, int* length, int* size, const FreeSmartphoneGSMCallDetail* value);
static FreeSmartphoneGSMCallDetail* _vala_array_dup1 (FreeSmartphoneGSMCallDetail* self, int length);
gchar* fso_gsm_plus_clcc_execute (FsoGsmPlusCLCC* self);
gchar* fso_gsm_plus_clcc_query (FsoGsmPlusCLCC* self);
static void fso_gsm_plus_clcc_finalize (GObject* obj);
GType fso_gsm_plus_clck_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CLCK_DUMMY_PROPERTY
};
GType fso_gsm_plus_clck_mode_get_type (void) G_GNUC_CONST;
FsoGsmPlusCLCK* fso_gsm_plus_clck_new (void);
FsoGsmPlusCLCK* fso_gsm_plus_clck_construct (GType object_type);
static void fso_gsm_plus_clck_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
static void fso_gsm_plus_clck_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
void fso_gsm_abstract_at_command_parseTest (FsoGsmAbstractAtCommand* self, const gchar* response, GError** error);
gchar* fso_gsm_plus_clck_query (FsoGsmPlusCLCK* self, const gchar* facility);
gchar* fso_gsm_plus_clck_issue (FsoGsmPlusCLCK* self, const gchar* facility, gboolean enable, const gchar* pin);
gchar* fso_gsm_plus_clck_test (FsoGsmPlusCLCK* self);
static void fso_gsm_plus_clck_finalize (GObject* obj);
GType fso_gsm_plus_clir_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CLIR_DUMMY_PROPERTY
};
FsoGsmPlusCLIR* fso_gsm_plus_clir_new (void);
FsoGsmPlusCLIR* fso_gsm_plus_clir_construct (GType object_type);
GType fso_gsm_plus_clvl_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CLVL_DUMMY_PROPERTY
};
FsoGsmPlusCLVL* fso_gsm_plus_clvl_new (void);
FsoGsmPlusCLVL* fso_gsm_plus_clvl_construct (GType object_type);
GType fso_gsm_plus_cmgd_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMGD_DUMMY_PROPERTY
};
FsoGsmPlusCMGD* fso_gsm_plus_cmgd_new (void);
FsoGsmPlusCMGD* fso_gsm_plus_cmgd_construct (GType object_type);
GType fso_gsm_plus_cmgl_get_type (void) G_GNUC_CONST;
gpointer wrap_sms_ref (gpointer instance);
void wrap_sms_unref (gpointer instance);
GParamSpec* param_spec_wrap_sms (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_wrap_sms (GValue* value, gpointer v_object);
void value_take_wrap_sms (GValue* value, gpointer v_object);
gpointer value_get_wrap_sms (const GValue* value);
GType wrap_sms_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMGL_DUMMY_PROPERTY
};
GType fso_gsm_plus_cmgl_mode_get_type (void) G_GNUC_CONST;
FsoGsmPlusCMGL* fso_gsm_plus_cmgl_new (void);
FsoGsmPlusCMGL* fso_gsm_plus_cmgl_construct (GType object_type);
static void fso_gsm_plus_cmgl_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error);
WrapSms* wrap_sms_new (struct sms* message, gint index);
WrapSms* wrap_sms_construct (GType object_type, struct sms* message, gint index);
gchar* fso_gsm_plus_cmgl_issue (FsoGsmPlusCMGL* self, FsoGsmPlusCMGLMode mode);
static void fso_gsm_plus_cmgl_finalize (GObject* obj);
GType fso_gsm_plus_cmgr_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMGR_DUMMY_PROPERTY
};
FsoGsmPlusCMGR* fso_gsm_plus_cmgr_new (void);
FsoGsmPlusCMGR* fso_gsm_plus_cmgr_construct (GType object_type);
static void fso_gsm_plus_cmgr_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error);
gchar* fso_gsm_plus_cmgr_issue (FsoGsmPlusCMGR* self, guint index);
static void fso_gsm_plus_cmgr_finalize (GObject* obj);
GType fso_gsm_plus_cmgs_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMGS_DUMMY_PROPERTY
};
FsoGsmPlusCMGS* fso_gsm_plus_cmgs_new (void);
FsoGsmPlusCMGS* fso_gsm_plus_cmgs_construct (GType object_type);
static void fso_gsm_plus_cmgs_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gpointer wrap_hex_pdu_ref (gpointer instance);
void wrap_hex_pdu_unref (gpointer instance);
GParamSpec* param_spec_wrap_hex_pdu (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_wrap_hex_pdu (GValue* value, gpointer v_object);
void value_take_wrap_hex_pdu (GValue* value, gpointer v_object);
gpointer value_get_wrap_hex_pdu (const GValue* value);
GType wrap_hex_pdu_get_type (void) G_GNUC_CONST;
gchar* fso_gsm_plus_cmgs_issue (FsoGsmPlusCMGS* self, WrapHexPdu* pdu);
static gchar* fso_gsm_plus_cmgs_real_get_prefix (FsoGsmAbstractAtCommand* base);
static gchar* fso_gsm_plus_cmgs_real_get_postfix (FsoGsmAbstractAtCommand* base);
static guint fso_gsm_plus_cmgs_real_get_timeout (FsoGsmAbstractAtCommand* base);
static void fso_gsm_plus_cmgs_finalize (GObject* obj);
GType fso_gsm_plus_cmgw_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMGW_DUMMY_PROPERTY
};
FsoGsmPlusCMGW* fso_gsm_plus_cmgw_new (void);
FsoGsmPlusCMGW* fso_gsm_plus_cmgw_construct (GType object_type);
gchar* fso_gsm_plus_cmgw_issue (FsoGsmPlusCMGW* self, WrapHexPdu* pdu);
static void fso_gsm_plus_cmgw_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
static gchar* fso_gsm_plus_cmgw_real_get_prefix (FsoGsmAbstractAtCommand* base);
static gchar* fso_gsm_plus_cmgw_real_get_postfix (FsoGsmAbstractAtCommand* base);
static void fso_gsm_plus_cmgw_finalize (GObject* obj);
GType fso_gsm_plus_cmickey_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMICKEY_DUMMY_PROPERTY
};
FsoGsmPlusCMICKEY* fso_gsm_plus_cmickey_new (void);
FsoGsmPlusCMICKEY* fso_gsm_plus_cmickey_construct (GType object_type);
GType fso_gsm_plus_cmss_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMSS_DUMMY_PROPERTY
};
FsoGsmPlusCMSS* fso_gsm_plus_cmss_new (void);
FsoGsmPlusCMSS* fso_gsm_plus_cmss_construct (GType object_type);
static void fso_gsm_plus_cmss_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_cmss_issue (FsoGsmPlusCMSS* self, gint index);
static void fso_gsm_plus_cmss_finalize (GObject* obj);
GType fso_gsm_plus_cmt_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMT_DUMMY_PROPERTY
};
FsoGsmPlusCMT* fso_gsm_plus_cmt_new (void);
FsoGsmPlusCMT* fso_gsm_plus_cmt_construct (GType object_type);
static void fso_gsm_plus_cmt_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error);
static void fso_gsm_plus_cmt_finalize (GObject* obj);
GType fso_gsm_plus_cmti_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMTI_DUMMY_PROPERTY
};
FsoGsmPlusCMTI* fso_gsm_plus_cmti_new (void);
FsoGsmPlusCMTI* fso_gsm_plus_cmti_construct (GType object_type);
static void fso_gsm_plus_cmti_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
static void fso_gsm_plus_cmti_finalize (GObject* obj);
GType fso_gsm_plus_cmms_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMMS_DUMMY_PROPERTY
};
FsoGsmPlusCMMS* fso_gsm_plus_cmms_new (void);
FsoGsmPlusCMMS* fso_gsm_plus_cmms_construct (GType object_type);
GType fso_gsm_plus_cmut_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CMUT_DUMMY_PROPERTY
};
FsoGsmPlusCMUT* fso_gsm_plus_cmut_new (void);
FsoGsmPlusCMUT* fso_gsm_plus_cmut_construct (GType object_type);
GType fso_gsm_plus_cnma_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CNMA_DUMMY_PROPERTY
};
FsoGsmPlusCNMA* fso_gsm_plus_cnma_new (void);
FsoGsmPlusCNMA* fso_gsm_plus_cnma_construct (GType object_type);
GType fso_gsm_plus_cnmi_get_type (void) G_GNUC_CONST;
#define FSO_GSM_PLUS_CNMI_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FSO_GSM_TYPE_PLUS_CNMI, FsoGsmPlusCNMIPrivate))
enum  {
	FSO_GSM_PLUS_CNMI_DUMMY_PROPERTY,
	FSO_GSM_PLUS_CNMI_MODE,
	FSO_GSM_PLUS_CNMI_MT,
	FSO_GSM_PLUS_CNMI_BM,
	FSO_GSM_PLUS_CNMI_DS,
	FSO_GSM_PLUS_CNMI_BFR,
	FSO_GSM_PLUS_CNMI_SUPPORTED_OPTS
};
FsoGsmPlusCNMI* fso_gsm_plus_cnmi_new (void);
FsoGsmPlusCNMI* fso_gsm_plus_cnmi_construct (GType object_type);
static void fso_gsm_plus_cnmi_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
static void fso_gsm_plus_cnmi_set_mode (FsoGsmPlusCNMI* self, gint value);
static void fso_gsm_plus_cnmi_set_mt (FsoGsmPlusCNMI* self, gint value);
static void fso_gsm_plus_cnmi_set_bm (FsoGsmPlusCNMI* self, gint value);
static void fso_gsm_plus_cnmi_set_ds (FsoGsmPlusCNMI* self, gint value);
static void fso_gsm_plus_cnmi_set_bfr (FsoGsmPlusCNMI* self, gint value);
static void fso_gsm_plus_cnmi_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
FsoGsmAtResultIter* fso_gsm_at_result_iter_new (gchar** lines, int lines_length1);
FsoGsmAtResultIter* fso_gsm_at_result_iter_construct (GType object_type, gchar** lines, int lines_length1);
gpointer fso_gsm_at_result_iter_ref (gpointer instance);
void fso_gsm_at_result_iter_unref (gpointer instance);
GParamSpec* fso_gsm_param_spec_at_result_iter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void fso_gsm_value_set_at_result_iter (GValue* value, gpointer v_object);
void fso_gsm_value_take_at_result_iter (GValue* value, gpointer v_object);
gpointer fso_gsm_value_get_at_result_iter (const GValue* value);
GType fso_gsm_at_result_iter_get_type (void) G_GNUC_CONST;
static void _g_object_unref0_ (gpointer var);
static void fso_gsm_plus_cnmi_set_supported_opts (FsoGsmPlusCNMI* self, GHashTable* value);
gboolean fso_gsm_at_result_iter_next (FsoGsmAtResultIter* self, const gchar* prefix);
gboolean fso_gsm_at_result_iter_open_list (FsoGsmAtResultIter* self);
GHashTable* fso_gsm_plus_cnmi_get_supported_opts (FsoGsmPlusCNMI* self);
gboolean fso_gsm_at_result_iter_next_number (FsoGsmAtResultIter* self, gint* number);
gboolean fso_gsm_at_result_iter_close_list (FsoGsmAtResultIter* self);
gchar* fso_gsm_plus_cnmi_query (FsoGsmPlusCNMI* self);
gchar* fso_gsm_plus_cnmi_test (FsoGsmPlusCNMI* self);
gchar* fso_gsm_plus_cnmi_issue (FsoGsmPlusCNMI* self, gint mode, gint mt, gint bm, gint ds, gint bfr);
gint fso_gsm_plus_cnmi_get_mode (FsoGsmPlusCNMI* self);
gint fso_gsm_plus_cnmi_get_mt (FsoGsmPlusCNMI* self);
gint fso_gsm_plus_cnmi_get_bm (FsoGsmPlusCNMI* self);
gint fso_gsm_plus_cnmi_get_ds (FsoGsmPlusCNMI* self);
gint fso_gsm_plus_cnmi_get_bfr (FsoGsmPlusCNMI* self);
static void fso_gsm_plus_cnmi_finalize (GObject* obj);
static void _vala_fso_gsm_plus_cnmi_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_fso_gsm_plus_cnmi_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType fso_gsm_plus_copn_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_COPN_DUMMY_PROPERTY
};
FsoGsmPlusCOPN* fso_gsm_plus_copn_new (void);
FsoGsmPlusCOPN* fso_gsm_plus_copn_construct (GType object_type);
static void fso_gsm_plus_copn_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error);
gchar* fso_gsm_at_command_decodeString (FsoGsmAtCommand* self, const gchar* str);
gchar* fso_gsm_plus_copn_execute (FsoGsmPlusCOPN* self);
static guint fso_gsm_plus_copn_real_get_timeout (FsoGsmAbstractAtCommand* base);
static void fso_gsm_plus_copn_finalize (GObject* obj);
GType fso_gsm_plus_cops_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_COPS_DUMMY_PROPERTY
};
GType fso_gsm_plus_cops_action_get_type (void) G_GNUC_CONST;
GType fso_gsm_plus_cops_format_get_type (void) G_GNUC_CONST;
static void _vala_FreeSmartphoneGSMNetworkProvider_array_free (FreeSmartphoneGSMNetworkProvider* array, gint array_length);
FsoGsmPlusCOPS* fso_gsm_plus_cops_new (void);
FsoGsmPlusCOPS* fso_gsm_plus_cops_construct (GType object_type);
static void fso_gsm_plus_cops_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_constants_networkProviderActToString (gint code);
static void fso_gsm_plus_cops_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_constants_networkProviderStatusToString (gint code);
static void _vala_array_add2 (FreeSmartphoneGSMNetworkProvider** array, int* length, int* size, const FreeSmartphoneGSMNetworkProvider* value);
static FreeSmartphoneGSMNetworkProvider* _vala_array_dup2 (FreeSmartphoneGSMNetworkProvider* self, int length);
gchar* fso_gsm_plus_cops_issue (FsoGsmPlusCOPS* self, FsoGsmPlusCOPSAction action, FsoGsmPlusCOPSFormat format, gint param);
gchar* fso_gsm_plus_cops_query (FsoGsmPlusCOPS* self, FsoGsmPlusCOPSFormat format);
gchar* fso_gsm_plus_cops_test (FsoGsmPlusCOPS* self);
static guint fso_gsm_plus_cops_real_get_timeout (FsoGsmAbstractAtCommand* base);
static void fso_gsm_plus_cops_finalize (GObject* obj);
GType fso_gsm_plus_cpbr_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CPBR_DUMMY_PROPERTY
};
static void _vala_FreeSmartphoneGSMSIMEntry_array_free (FreeSmartphoneGSMSIMEntry* array, gint array_length);
FsoGsmPlusCPBR* fso_gsm_plus_cpbr_new (void);
FsoGsmPlusCPBR* fso_gsm_plus_cpbr_construct (GType object_type);
static void fso_gsm_plus_cpbr_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error);
static void _vala_array_add3 (FreeSmartphoneGSMSIMEntry** array, int* length, int* size, const FreeSmartphoneGSMSIMEntry* value);
static FreeSmartphoneGSMSIMEntry* _vala_array_dup3 (FreeSmartphoneGSMSIMEntry* self, int length);
static void fso_gsm_plus_cpbr_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_cpbr_issue (FsoGsmPlusCPBR* self, const gchar* cat, gint first, gint last);
gchar* fso_gsm_plus_cpbr_test (FsoGsmPlusCPBR* self, const gchar* cat);
static void fso_gsm_plus_cpbr_finalize (GObject* obj);
GType fso_gsm_plus_cpbs_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CPBS_DUMMY_PROPERTY
};
FsoGsmPlusCPBS* fso_gsm_plus_cpbs_new (void);
FsoGsmPlusCPBS* fso_gsm_plus_cpbs_construct (GType object_type);
static void fso_gsm_plus_cpbs_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
static void _vala_array_add4 (gchar*** array, int* length, int* size, gchar* value);
static gchar** _vala_array_dup4 (gchar** self, int length);
gchar* fso_gsm_plus_cpbs_test (FsoGsmPlusCPBS* self);
static void fso_gsm_plus_cpbs_finalize (GObject* obj);
GType fso_gsm_plus_cpbw_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CPBW_DUMMY_PROPERTY
};
FsoGsmPlusCPBW* fso_gsm_plus_cpbw_new (void);
FsoGsmPlusCPBW* fso_gsm_plus_cpbw_construct (GType object_type);
static void fso_gsm_plus_cpbw_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_cpbw_issue (FsoGsmPlusCPBW* self, const gchar* cat, gint location, const gchar* number, const gchar* name);
gchar* fso_gsm_constants_phonenumberStringToTuple (const gchar* number);
gchar* fso_gsm_at_command_encodeString (FsoGsmAtCommand* self, const gchar* str);
gchar* fso_gsm_plus_cpbw_test (FsoGsmPlusCPBW* self, const gchar* cat);
static void fso_gsm_plus_cpbw_finalize (GObject* obj);
GType fso_gsm_plus_cpin_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CPIN_DUMMY_PROPERTY
};
FsoGsmPlusCPIN* fso_gsm_plus_cpin_new (void);
FsoGsmPlusCPIN* fso_gsm_plus_cpin_construct (GType object_type);
static void fso_gsm_plus_cpin_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
FreeSmartphoneGSMSIMAuthStatus fso_gsm_constants_simAuthStatusToEnum (const gchar* status);
gchar* fso_gsm_plus_cpin_issue (FsoGsmPlusCPIN* self, const gchar* pin, const gchar* new_pin);
gchar* fso_gsm_plus_cpin_query (FsoGsmPlusCPIN* self);
static guint fso_gsm_plus_cpin_real_get_timeout (FsoGsmAbstractAtCommand* base);
static void fso_gsm_plus_cpin_finalize (GObject* obj);
GType fso_gsm_plus_cpms_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CPMS_DUMMY_PROPERTY
};
FsoGsmPlusCPMS* fso_gsm_plus_cpms_new (void);
FsoGsmPlusCPMS* fso_gsm_plus_cpms_construct (GType object_type);
static void fso_gsm_plus_cpms_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_cpms_query (FsoGsmPlusCPMS* self);
gchar* fso_gsm_plus_cpms_issue (FsoGsmPlusCPMS* self, const gchar* s1, const gchar* s2, const gchar* s3);
static void fso_gsm_plus_cpms_finalize (GObject* obj);
GType fso_gsm_plus_cpwd_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CPWD_DUMMY_PROPERTY
};
FsoGsmPlusCPWD* fso_gsm_plus_cpwd_new (void);
FsoGsmPlusCPWD* fso_gsm_plus_cpwd_construct (GType object_type);
static void fso_gsm_plus_cpwd_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_cpwd_issue (FsoGsmPlusCPWD* self, const gchar* facility, const gchar* p1, const gchar* p2);
gchar* fso_gsm_plus_cpwd_query (FsoGsmPlusCPWD* self);
GType fso_gsm_plus_creg_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CREG_DUMMY_PROPERTY
};
GType fso_gsm_plus_creg_mode_get_type (void) G_GNUC_CONST;
FsoGsmPlusCREG* fso_gsm_plus_creg_new (void);
FsoGsmPlusCREG* fso_gsm_plus_creg_construct (GType object_type);
static void fso_gsm_plus_creg_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_creg_query (FsoGsmPlusCREG* self);
gchar* fso_gsm_plus_creg_issue (FsoGsmPlusCREG* self, FsoGsmPlusCREGMode mode);
static void fso_gsm_plus_creg_finalize (GObject* obj);
GType fso_gsm_plus_crsm_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CRSM_DUMMY_PROPERTY
};
FsoGsmPlusCRSM* fso_gsm_plus_crsm_new (void);
FsoGsmPlusCRSM* fso_gsm_plus_crsm_construct (GType object_type);
static void fso_gsm_plus_crsm_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_crsm_issue (FsoGsmPlusCRSM* self, gint command, gint p1, gint p2, gint offset, gint length);
static void fso_gsm_plus_crsm_finalize (GObject* obj);
GType fso_gsm_plus_csca_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CSCA_DUMMY_PROPERTY
};
FsoGsmPlusCSCA* fso_gsm_plus_csca_new (void);
FsoGsmPlusCSCA* fso_gsm_plus_csca_construct (GType object_type);
#define FSO_GSM_CONSTANTS_PHONE_DIGITS_RE "[0-9A-D\\*#\\+pw]"
static void fso_gsm_plus_csca_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_csca_query (FsoGsmPlusCSCA* self);
gchar* fso_gsm_plus_csca_issue (FsoGsmPlusCSCA* self, const gchar* number);
static void fso_gsm_plus_csca_finalize (GObject* obj);
GType fso_gsm_plus_cscb_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CSCB_DUMMY_PROPERTY
};
GType fso_gsm_plus_cscb_mode_get_type (void) G_GNUC_CONST;
FsoGsmPlusCSCB* fso_gsm_plus_cscb_new (void);
FsoGsmPlusCSCB* fso_gsm_plus_cscb_construct (GType object_type);
static void fso_gsm_plus_cscb_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_cscb_query (FsoGsmPlusCSCB* self);
gchar* fso_gsm_plus_cscb_issue (FsoGsmPlusCSCB* self, FsoGsmPlusCSCBMode m);
static void fso_gsm_plus_cscb_finalize (GObject* obj);
GType fso_gsm_plus_cscs_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CSCS_DUMMY_PROPERTY
};
FsoGsmPlusCSCS* fso_gsm_plus_cscs_new (void);
FsoGsmPlusCSCS* fso_gsm_plus_cscs_construct (GType object_type);
GType fso_gsm_plus_csq_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CSQ_DUMMY_PROPERTY
};
FsoGsmPlusCSQ* fso_gsm_plus_csq_new (void);
FsoGsmPlusCSQ* fso_gsm_plus_csq_construct (GType object_type);
static void fso_gsm_plus_csq_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gint fso_gsm_constants_networkSignalToPercentage (gint sig);
gchar* fso_gsm_plus_csq_execute (FsoGsmPlusCSQ* self);
static void fso_gsm_plus_csq_finalize (GObject* obj);
GType fso_gsm_plus_cssi_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CSSI_DUMMY_PROPERTY
};
FsoGsmPlusCSSI* fso_gsm_plus_cssi_new (void);
FsoGsmPlusCSSI* fso_gsm_plus_cssi_construct (GType object_type);
GType fso_gsm_plus_cssu_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CSSU_DUMMY_PROPERTY
};
FsoGsmPlusCSSU* fso_gsm_plus_cssu_new (void);
FsoGsmPlusCSSU* fso_gsm_plus_cssu_construct (GType object_type);
GType fso_gsm_plus_cusd_get_type (void) G_GNUC_CONST;
GType fso_gsm_plus_cusd_mode_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CUSD_DUMMY_PROPERTY
};
FsoGsmPlusCUSD* fso_gsm_plus_cusd_new (void);
FsoGsmPlusCUSD* fso_gsm_plus_cusd_construct (GType object_type);
static void fso_gsm_plus_cusd_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
gchar* fso_gsm_plus_cusd_query (FsoGsmPlusCUSD* self, const gchar* request);
gchar* fso_gsm_plus_cusd_issue (FsoGsmPlusCUSD* self, gboolean enable);
static void fso_gsm_plus_cusd_finalize (GObject* obj);
GType fso_gsm_plus_fclass_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_FCLASS_DUMMY_PROPERTY
};
FsoGsmPlusFCLASS* fso_gsm_plus_fclass_new (void);
FsoGsmPlusFCLASS* fso_gsm_plus_fclass_construct (GType object_type);
GType fso_gsm_plus_gcap_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_GCAP_DUMMY_PROPERTY
};
FsoGsmPlusGCAP* fso_gsm_plus_gcap_new (void);
FsoGsmPlusGCAP* fso_gsm_plus_gcap_construct (GType object_type);
GType fso_gsm_plus_vts_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_VTS_DUMMY_PROPERTY
};
gchar* fso_gsm_plus_vts_issue (FsoGsmPlusVTS* self, const gchar* tones);
FsoGsmPlusVTS* fso_gsm_plus_vts_new (void);
FsoGsmPlusVTS* fso_gsm_plus_vts_construct (GType object_type);
GType fso_gsm_v250ter_command_get_type (void) G_GNUC_CONST;
GType fso_gsm_v250_a_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_V250_A_DUMMY_PROPERTY
};
FsoGsmV250A* fso_gsm_v250_a_new (void);
FsoGsmV250A* fso_gsm_v250_a_construct (GType object_type);
FsoGsmV250terCommand* fso_gsm_v250ter_command_new (const gchar* name);
FsoGsmV250terCommand* fso_gsm_v250ter_command_construct (GType object_type, const gchar* name);
GType fso_gsm_v250_d_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_V250_D_DUMMY_PROPERTY
};
FsoGsmV250D* fso_gsm_v250_d_new (void);
FsoGsmV250D* fso_gsm_v250_d_construct (GType object_type);
gchar* fso_gsm_v250_d_issue (FsoGsmV250D* self, const gchar* number, gboolean voice);
gchar* fso_gsm_constants_cleanPhoneNumber (const gchar* number);
static guint fso_gsm_v250_d_real_get_timeout (FsoGsmAbstractAtCommand* base);
GType fso_gsm_v250_h_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_V250_H_DUMMY_PROPERTY
};
FsoGsmV250H* fso_gsm_v250_h_new (void);
FsoGsmV250H* fso_gsm_v250_h_construct (GType object_type);
GType fso_gsm_plus_ccfc_get_type (void) G_GNUC_CONST;
GType fso_gsm_constants_bearer_class_get_type (void) G_GNUC_CONST;
#define FSO_GSM_PLUS_CCFC_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FSO_GSM_TYPE_PLUS_CCFC, FsoGsmPlusCCFCPrivate))
enum  {
	FSO_GSM_PLUS_CCFC_DUMMY_PROPERTY,
	FSO_GSM_PLUS_CCFC_ACTIVE,
	FSO_GSM_PLUS_CCFC_CLASS1,
	FSO_GSM_PLUS_CCFC_NUMBER,
	FSO_GSM_PLUS_CCFC_NUMBER_TYPE,
	FSO_GSM_PLUS_CCFC_SUBADDR,
	FSO_GSM_PLUS_CCFC_SATYPE,
	FSO_GSM_PLUS_CCFC_TIMEOUT
};
FsoGsmPlusCCFC* fso_gsm_plus_ccfc_new (void);
FsoGsmPlusCCFC* fso_gsm_plus_ccfc_construct (GType object_type);
static void fso_gsm_plus_ccfc_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
static void fso_gsm_plus_ccfc_set_active (FsoGsmPlusCCFC* self, gboolean value);
static void fso_gsm_plus_ccfc_set_class1 (FsoGsmPlusCCFC* self, FsoGsmConstantsBearerClass value);
static void fso_gsm_plus_ccfc_set_number (FsoGsmPlusCCFC* self, const gchar* value);
static void fso_gsm_plus_ccfc_set_number_type (FsoGsmPlusCCFC* self, gint value);
static void fso_gsm_plus_ccfc_set_subaddr (FsoGsmPlusCCFC* self, const gchar* value);
static void fso_gsm_plus_ccfc_set_satype (FsoGsmPlusCCFC* self, gint value);
static void fso_gsm_plus_ccfc_set_timeout (FsoGsmPlusCCFC* self, gint value);
GType fso_gsm_constants_call_forwarding_type_get_type (void) G_GNUC_CONST;
gchar* fso_gsm_plus_ccfc_query (FsoGsmPlusCCFC* self, FsoGsmConstantsCallForwardingType type, FsoGsmConstantsBearerClass cls);
GType fso_gsm_constants_call_forwarding_mode_get_type (void) G_GNUC_CONST;
gchar* fso_gsm_plus_ccfc_issue (FsoGsmPlusCCFC* self, FsoGsmConstantsCallForwardingMode mode, FsoGsmConstantsCallForwardingType type, FsoGsmConstantsBearerClass cls);
gchar* fso_gsm_plus_ccfc_issue_ext (FsoGsmPlusCCFC* self, FsoGsmConstantsCallForwardingMode mode, FsoGsmConstantsCallForwardingType type, FsoGsmConstantsBearerClass cls, const gchar* number, gint time);
guint8 fso_gsm_constants_determinePhoneNumberType (const gchar* number);
gboolean fso_gsm_plus_ccfc_get_active (FsoGsmPlusCCFC* self);
FsoGsmConstantsBearerClass fso_gsm_plus_ccfc_get_class1 (FsoGsmPlusCCFC* self);
const gchar* fso_gsm_plus_ccfc_get_number (FsoGsmPlusCCFC* self);
gint fso_gsm_plus_ccfc_get_number_type (FsoGsmPlusCCFC* self);
const gchar* fso_gsm_plus_ccfc_get_subaddr (FsoGsmPlusCCFC* self);
gint fso_gsm_plus_ccfc_get_satype (FsoGsmPlusCCFC* self);
gint fso_gsm_plus_ccfc_get_timeout (FsoGsmPlusCCFC* self);
static void fso_gsm_plus_ccfc_finalize (GObject* obj);
static void _vala_fso_gsm_plus_ccfc_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_fso_gsm_plus_ccfc_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType fso_gsm_plus_ctfr_get_type (void) G_GNUC_CONST;
enum  {
	FSO_GSM_PLUS_CTFR_DUMMY_PROPERTY
};
gchar* fso_gsm_plus_ctfr_issue (FsoGsmPlusCTFR* self, const gchar* number, gint number_type);
FsoGsmPlusCTFR* fso_gsm_plus_ctfr_new (void);
FsoGsmPlusCTFR* fso_gsm_plus_ctfr_construct (GType object_type);
GType fso_gsm_plus_csms_get_type (void) G_GNUC_CONST;
#define FSO_GSM_PLUS_CSMS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FSO_GSM_TYPE_PLUS_CSMS, FsoGsmPlusCSMSPrivate))
enum  {
	FSO_GSM_PLUS_CSMS_DUMMY_PROPERTY,
	FSO_GSM_PLUS_CSMS_MT,
	FSO_GSM_PLUS_CSMS_MO,
	FSO_GSM_PLUS_CSMS_BM
};
FsoGsmPlusCSMS* fso_gsm_plus_csms_new (void);
FsoGsmPlusCSMS* fso_gsm_plus_csms_construct (GType object_type);
static void fso_gsm_plus_csms_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
static void fso_gsm_plus_csms_set_mt (FsoGsmPlusCSMS* self, gint value);
static void fso_gsm_plus_csms_set_mo (FsoGsmPlusCSMS* self, gint value);
static void fso_gsm_plus_csms_set_bm (FsoGsmPlusCSMS* self, gint value);
static void fso_gsm_plus_csms_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
static void fso_gsm_plus_csms_set_supported_services (FsoGsmPlusCSMS* self, gint* value, int value_length1);
static void _vala_array_add5 (gint** array, int* length, int* size, gint value);
gchar* fso_gsm_plus_csms_issue (FsoGsmPlusCSMS* self, gint service);
gchar* fso_gsm_plus_csms_query (FsoGsmPlusCSMS* self);
gchar* fso_gsm_plus_csms_test (FsoGsmPlusCSMS* self);
gint fso_gsm_plus_csms_get_mt (FsoGsmPlusCSMS* self);
gint fso_gsm_plus_csms_get_mo (FsoGsmPlusCSMS* self);
gint fso_gsm_plus_csms_get_bm (FsoGsmPlusCSMS* self);
gint* fso_gsm_plus_csms_get_supported_services (FsoGsmPlusCSMS* self, int* result_length1);
static gint* _vala_array_dup5 (gint* self, int length);
static void fso_gsm_plus_csms_finalize (GObject* obj);
static void _vala_fso_gsm_plus_csms_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_fso_gsm_plus_csms_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType fso_gsm_plus_cmgf_get_type (void) G_GNUC_CONST;
#define FSO_GSM_PLUS_CMGF_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FSO_GSM_TYPE_PLUS_CMGF, FsoGsmPlusCMGFPrivate))
enum  {
	FSO_GSM_PLUS_CMGF_DUMMY_PROPERTY,
	FSO_GSM_PLUS_CMGF_MODE
};
FsoGsmPlusCMGF* fso_gsm_plus_cmgf_new (void);
FsoGsmPlusCMGF* fso_gsm_plus_cmgf_construct (GType object_type);
static void fso_gsm_plus_cmgf_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
static void fso_gsm_plus_cmgf_set_mode (FsoGsmPlusCMGF* self, gint value);
static void fso_gsm_plus_cmgf_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error);
static void _vala_array_add6 (gint** array, int* length, int* size, gint value);
static void fso_gsm_plus_cmgf_set_supported_modes (FsoGsmPlusCMGF* self, gint* value, int value_length1);
gchar* fso_gsm_plus_cmgf_issue (FsoGsmPlusCMGF* self, gint mode);
gchar* fso_gsm_plus_cmgf_test (FsoGsmPlusCMGF* self);
gchar* fso_gsm_plus_cmgf_query (FsoGsmPlusCMGF* self);
gint fso_gsm_plus_cmgf_get_mode (FsoGsmPlusCMGF* self);
gint* fso_gsm_plus_cmgf_get_supported_modes (FsoGsmPlusCMGF* self, int* result_length1);
static gint* _vala_array_dup6 (gint* self, int length);
static void fso_gsm_plus_cmgf_finalize (GObject* obj);
static void _vala_fso_gsm_plus_cmgf_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_fso_gsm_plus_cmgf_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
void fso_gsm_registerGenericAtCommands (GeeHashMap* table);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


FsoGsmPlusCALA* fso_gsm_plus_cala_construct (GType object_type) {
	FsoGsmPlusCALA * self = NULL;
	gchar* _tmp0_;
	gchar* str;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp6_;
	gchar** _tmp7_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCALA*) fso_gsm_abstract_at_command_construct (object_type);
	_tmp0_ = g_strdup ("\\+CALA: \"?(?P<year>\\d?\\d)/(?P<month>\\d?\\d)/(?P<day>\\d?\\d),(?P<" \
"hour>\\d?\\d):(?P<minute>\\d?\\d):(?P<second>\\d?\\d)(?:[\\+-](?P<tzof" \
"fset>\\d\\d))?\"?,0,0,");
	str = _tmp0_;
	_tmp1_ = str;
	_tmp2_ = g_strconcat (_tmp1_, "\"(?P<mccmnc>[^\"]*)\"", NULL);
	_g_free0 (str);
	str = _tmp2_;
	{
		const gchar* _tmp3_;
		GRegex* _tmp4_;
		GRegex* _tmp5_;
		_tmp3_ = str;
		_tmp4_ = g_regex_new (_tmp3_, 0, 0, &_inner_error_);
		_tmp5_ = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch8_g_regex_error;
			}
			_g_free0 (str);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp5_;
	}
	goto __finally8;
	__catch8_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally8:
	if (_inner_error_ != NULL) {
		_g_free0 (str);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp6_ = g_strdup ("+CALA: ");
	_tmp7_ = g_new0 (gchar*, 1 + 1);
	_tmp7_[0] = _tmp6_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp7_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	_g_free0 (str);
	return self;
}


FsoGsmPlusCALA* fso_gsm_plus_cala_new (void) {
	return fso_gsm_plus_cala_construct (FSO_GSM_TYPE_PLUS_CALA);
}


static void fso_gsm_plus_cala_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCALA * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCALA*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cala_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "year");
	self->year = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "month");
	self->month = _tmp2_;
	_tmp3_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "day");
	self->day = _tmp3_;
	_tmp4_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "hour");
	self->hour = _tmp4_;
	_tmp5_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "minute");
	self->minute = _tmp5_;
	_tmp6_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "second");
	self->second = _tmp6_;
	_tmp7_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "tzoffset");
	self->tzoffset = _tmp7_;
}


gchar* fso_gsm_plus_cala_issue (FsoGsmPlusCALA* self, gint year, gint month, gint day, gint hour, gint minute, gint second, gint tzoffset) {
	gchar* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = year;
	_tmp1_ = month;
	_tmp2_ = day;
	_tmp3_ = hour;
	_tmp4_ = minute;
	_tmp5_ = second;
	_tmp6_ = g_strdup_printf ("+CALA=\"%02d/%02d/%02d,%02d:%02d:%02d\",0,0,\"Dr.Mickey rocks!\"", _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_, _tmp5_);
	result = _tmp6_;
	return result;
}


gchar* fso_gsm_plus_cala_clear (FsoGsmPlusCALA* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CALA=\"\"");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_cala_query (FsoGsmPlusCALA* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CALA?");
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cala_class_init (FsoGsmPlusCALAClass * klass) {
	fso_gsm_plus_cala_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cala_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cala_finalize;
}


static void fso_gsm_plus_cala_instance_init (FsoGsmPlusCALA * self) {
}


static void fso_gsm_plus_cala_finalize (GObject* obj) {
	FsoGsmPlusCALA * self;
	self = FSO_GSM_PLUS_CALA (obj);
	G_OBJECT_CLASS (fso_gsm_plus_cala_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cala_get_type (void) {
	static volatile gsize fso_gsm_plus_cala_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cala_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCALAClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cala_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCALA), 0, (GInstanceInitFunc) fso_gsm_plus_cala_instance_init, NULL };
		GType fso_gsm_plus_cala_type_id;
		fso_gsm_plus_cala_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCALA", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cala_type_id__volatile, fso_gsm_plus_cala_type_id);
	}
	return fso_gsm_plus_cala_type_id__volatile;
}


GType fso_gsm_plus_cbc_status_get_type (void) {
	static volatile gsize fso_gsm_plus_cbc_status_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cbc_status_type_id__volatile)) {
		static const GEnumValue values[] = {{FSO_GSM_PLUS_CBC_STATUS_DISCHARGING, "FSO_GSM_PLUS_CBC_STATUS_DISCHARGING", "discharging"}, {FSO_GSM_PLUS_CBC_STATUS_CHARGING, "FSO_GSM_PLUS_CBC_STATUS_CHARGING", "charging"}, {FSO_GSM_PLUS_CBC_STATUS_AC, "FSO_GSM_PLUS_CBC_STATUS_AC", "ac"}, {FSO_GSM_PLUS_CBC_STATUS_UNKNOWN, "FSO_GSM_PLUS_CBC_STATUS_UNKNOWN", "unknown"}, {0, NULL, NULL}};
		GType fso_gsm_plus_cbc_status_type_id;
		fso_gsm_plus_cbc_status_type_id = g_enum_register_static ("FsoGsmPlusCBCStatus", values);
		g_once_init_leave (&fso_gsm_plus_cbc_status_type_id__volatile, fso_gsm_plus_cbc_status_type_id);
	}
	return fso_gsm_plus_cbc_status_type_id__volatile;
}


FsoGsmPlusCBC* fso_gsm_plus_cbc_construct (GType object_type) {
	FsoGsmPlusCBC * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCBC*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CBC: (?P<status>[0123]),(?P<level>\\d+)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch9_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally9;
	__catch9_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally9:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CBC: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCBC* fso_gsm_plus_cbc_new (void) {
	return fso_gsm_plus_cbc_construct (FSO_GSM_TYPE_PLUS_CBC);
}


static void fso_gsm_plus_cbc_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCBC * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCBC*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cbc_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "status");
	self->status = (FsoGsmPlusCBCStatus) _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "level");
	self->level = _tmp2_;
}


gchar* fso_gsm_plus_cbc_execute (FsoGsmPlusCBC* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CBC");
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cbc_class_init (FsoGsmPlusCBCClass * klass) {
	fso_gsm_plus_cbc_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cbc_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cbc_finalize;
}


static void fso_gsm_plus_cbc_instance_init (FsoGsmPlusCBC * self) {
}


static void fso_gsm_plus_cbc_finalize (GObject* obj) {
	FsoGsmPlusCBC * self;
	self = FSO_GSM_PLUS_CBC (obj);
	G_OBJECT_CLASS (fso_gsm_plus_cbc_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cbc_get_type (void) {
	static volatile gsize fso_gsm_plus_cbc_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cbc_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCBCClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cbc_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCBC), 0, (GInstanceInitFunc) fso_gsm_plus_cbc_instance_init, NULL };
		GType fso_gsm_plus_cbc_type_id;
		fso_gsm_plus_cbc_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCBC", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cbc_type_id__volatile, fso_gsm_plus_cbc_type_id);
	}
	return fso_gsm_plus_cbc_type_id__volatile;
}


FsoGsmPlusCBM* fso_gsm_plus_cbm_construct (GType object_type) {
	FsoGsmPlusCBM * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCBM*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CBM: (?P<tpdulen>\\d+)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch10_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally10;
	__catch10_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally10:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CBM: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	((FsoGsmAbstractAtCommand*) self)->length = 2;
	return self;
}


FsoGsmPlusCBM* fso_gsm_plus_cbm_new (void) {
	return fso_gsm_plus_cbm_construct (FSO_GSM_TYPE_PLUS_CBM);
}


static void fso_gsm_plus_cbm_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error) {
	FsoGsmPlusCBM * self;
	gchar** _tmp0_;
	gint _tmp0__length1;
	const gchar* _tmp1_;
	gint _tmp2_ = 0;
	gchar** _tmp3_;
	gint _tmp3__length1;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCBM*) base;
	_tmp0_ = response;
	_tmp0__length1 = response_length1;
	_tmp1_ = _tmp0_[0];
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cbm_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp1_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "tpdulen");
	self->tpdulen = _tmp2_;
	_tmp3_ = response;
	_tmp3__length1 = response_length1;
	_tmp4_ = _tmp3_[1];
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->hexpdu);
	self->hexpdu = _tmp5_;
}


static void fso_gsm_plus_cbm_class_init (FsoGsmPlusCBMClass * klass) {
	fso_gsm_plus_cbm_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseMulti = fso_gsm_plus_cbm_real_parseMulti;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cbm_finalize;
}


static void fso_gsm_plus_cbm_instance_init (FsoGsmPlusCBM * self) {
}


static void fso_gsm_plus_cbm_finalize (GObject* obj) {
	FsoGsmPlusCBM * self;
	self = FSO_GSM_PLUS_CBM (obj);
	_g_free0 (self->hexpdu);
	G_OBJECT_CLASS (fso_gsm_plus_cbm_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cbm_get_type (void) {
	static volatile gsize fso_gsm_plus_cbm_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cbm_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCBMClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cbm_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCBM), 0, (GInstanceInitFunc) fso_gsm_plus_cbm_instance_init, NULL };
		GType fso_gsm_plus_cbm_type_id;
		fso_gsm_plus_cbm_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCBM", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cbm_type_id__volatile, fso_gsm_plus_cbm_type_id);
	}
	return fso_gsm_plus_cbm_type_id__volatile;
}


FsoGsmPlusCCLK* fso_gsm_plus_cclk_construct (GType object_type) {
	FsoGsmPlusCCLK * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCCLK*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CCLK: \"?(?P<year>\\d?\\d)/(?P<month>\\d?\\d)/(?P<day>\\d?\\d),(?P<" \
"hour>\\d?\\d):(?P<minute>\\d?\\d):(?P<second>\\d?\\d)(?:[\\+-](?P<tzof" \
"fset>\\d\\d))?\"?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch11_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally11;
	__catch11_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally11:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CCLK: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCCLK* fso_gsm_plus_cclk_new (void) {
	return fso_gsm_plus_cclk_construct (FSO_GSM_TYPE_PLUS_CCLK);
}


static void fso_gsm_plus_cclk_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCCLK * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCCLK*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cclk_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "year");
	self->year = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "month");
	self->month = _tmp2_;
	_tmp3_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "day");
	self->day = _tmp3_;
	_tmp4_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "hour");
	self->hour = _tmp4_;
	_tmp5_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "minute");
	self->minute = _tmp5_;
	_tmp6_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "second");
	self->second = _tmp6_;
	_tmp7_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "tzoffset");
	self->tzoffset = _tmp7_;
}


gchar* fso_gsm_plus_cclk_issue (FsoGsmPlusCCLK* self, gint year, gint month, gint day, gint hour, gint minute, gint second, gint tzoffset) {
	gchar* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = year;
	_tmp1_ = month;
	_tmp2_ = day;
	_tmp3_ = hour;
	_tmp4_ = minute;
	_tmp5_ = second;
	_tmp6_ = g_strdup_printf ("+CCLK=\"%02d/%02d/%02d,%02d:%02d:%02d\"", _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_, _tmp5_);
	result = _tmp6_;
	return result;
}


gchar* fso_gsm_plus_cclk_query (FsoGsmPlusCCLK* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CCLK?");
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cclk_class_init (FsoGsmPlusCCLKClass * klass) {
	fso_gsm_plus_cclk_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cclk_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cclk_finalize;
}


static void fso_gsm_plus_cclk_instance_init (FsoGsmPlusCCLK * self) {
}


static void fso_gsm_plus_cclk_finalize (GObject* obj) {
	FsoGsmPlusCCLK * self;
	self = FSO_GSM_PLUS_CCLK (obj);
	G_OBJECT_CLASS (fso_gsm_plus_cclk_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cclk_get_type (void) {
	static volatile gsize fso_gsm_plus_cclk_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cclk_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCCLKClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cclk_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCCLK), 0, (GInstanceInitFunc) fso_gsm_plus_cclk_instance_init, NULL };
		GType fso_gsm_plus_cclk_type_id;
		fso_gsm_plus_cclk_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCCLK", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cclk_type_id__volatile, fso_gsm_plus_cclk_type_id);
	}
	return fso_gsm_plus_cclk_type_id__volatile;
}


FsoGsmPlusCDS* fso_gsm_plus_cds_construct (GType object_type) {
	FsoGsmPlusCDS * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCDS*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CDS: (?P<tpdulen>\\d+)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch12_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally12;
	__catch12_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally12:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CDS: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	((FsoGsmAbstractAtCommand*) self)->length = 2;
	return self;
}


FsoGsmPlusCDS* fso_gsm_plus_cds_new (void) {
	return fso_gsm_plus_cds_construct (FSO_GSM_TYPE_PLUS_CDS);
}


static void fso_gsm_plus_cds_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error) {
	FsoGsmPlusCDS * self;
	gchar** _tmp0_;
	gint _tmp0__length1;
	const gchar* _tmp1_;
	gint _tmp2_ = 0;
	gchar** _tmp3_;
	gint _tmp3__length1;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCDS*) base;
	_tmp0_ = response;
	_tmp0__length1 = response_length1;
	_tmp1_ = _tmp0_[0];
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cds_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp1_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "tpdulen");
	self->tpdulen = _tmp2_;
	_tmp3_ = response;
	_tmp3__length1 = response_length1;
	_tmp4_ = _tmp3_[1];
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->hexpdu);
	self->hexpdu = _tmp5_;
}


static void fso_gsm_plus_cds_class_init (FsoGsmPlusCDSClass * klass) {
	fso_gsm_plus_cds_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseMulti = fso_gsm_plus_cds_real_parseMulti;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cds_finalize;
}


static void fso_gsm_plus_cds_instance_init (FsoGsmPlusCDS * self) {
}


static void fso_gsm_plus_cds_finalize (GObject* obj) {
	FsoGsmPlusCDS * self;
	self = FSO_GSM_PLUS_CDS (obj);
	_g_free0 (self->hexpdu);
	G_OBJECT_CLASS (fso_gsm_plus_cds_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cds_get_type (void) {
	static volatile gsize fso_gsm_plus_cds_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cds_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCDSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cds_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCDS), 0, (GInstanceInitFunc) fso_gsm_plus_cds_instance_init, NULL };
		GType fso_gsm_plus_cds_type_id;
		fso_gsm_plus_cds_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCDS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cds_type_id__volatile, fso_gsm_plus_cds_type_id);
	}
	return fso_gsm_plus_cds_type_id__volatile;
}


FsoGsmPlusCEER* fso_gsm_plus_ceer_construct (GType object_type) {
	FsoGsmPlusCEER * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCEER*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CEER: (?:(?P<v0>\\d+),)?(?P<v1>\\d+),(?P<v2>\\d+),(?P<v3>\\d+)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch13_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally13;
	__catch13_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally13:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CEER: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCEER* fso_gsm_plus_ceer_new (void) {
	return fso_gsm_plus_ceer_construct (FSO_GSM_TYPE_PLUS_CEER);
}


static void fso_gsm_plus_ceer_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCEER * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint v0;
	gint _tmp2_ = 0;
	gint v1;
	gint _tmp3_ = 0;
	gint v2;
	gint _tmp4_ = 0;
	gint v3;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	gint _tmp8_;
	gboolean _tmp10_;
	gboolean _tmp12_;
	gboolean _tmp14_;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCEER*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_ceer_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "v0");
	v0 = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "v1");
	v1 = _tmp2_;
	_tmp3_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "v2");
	v2 = _tmp3_;
	_tmp4_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "v3");
	v3 = _tmp4_;
	_tmp8_ = v0;
	if (_tmp8_ == 0) {
		gint _tmp9_;
		_tmp9_ = v1;
		_tmp7_ = _tmp9_ == 0;
	} else {
		_tmp7_ = FALSE;
	}
	_tmp10_ = _tmp7_;
	if (_tmp10_) {
		gint _tmp11_;
		_tmp11_ = v2;
		_tmp6_ = _tmp11_ != 0;
	} else {
		_tmp6_ = FALSE;
	}
	_tmp12_ = _tmp6_;
	if (_tmp12_) {
		gint _tmp13_;
		_tmp13_ = v3;
		_tmp5_ = _tmp13_ != 0;
	} else {
		_tmp5_ = FALSE;
	}
	_tmp14_ = _tmp5_;
	if (_tmp14_) {
		gint _tmp15_;
		gint _tmp16_;
		gint _tmp17_;
		gchar* _tmp18_ = NULL;
		_tmp15_ = v1;
		_tmp16_ = v2;
		_tmp17_ = v3;
		_tmp18_ = fso_gsm_constants_ceerCauseToString (_tmp15_, _tmp16_, _tmp17_);
		_g_free0 (self->reason);
		self->reason = _tmp18_;
	} else {
		gint _tmp19_;
		gint _tmp20_;
		gint _tmp21_;
		gchar* _tmp22_ = NULL;
		_tmp19_ = v0;
		_tmp20_ = v1;
		_tmp21_ = v3;
		_tmp22_ = fso_gsm_constants_ceerCauseToString (_tmp19_, _tmp20_, _tmp21_);
		_g_free0 (self->reason);
		self->reason = _tmp22_;
	}
}


gchar* fso_gsm_plus_ceer_execute (FsoGsmPlusCEER* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CEER");
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_ceer_class_init (FsoGsmPlusCEERClass * klass) {
	fso_gsm_plus_ceer_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_ceer_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_ceer_finalize;
}


static void fso_gsm_plus_ceer_instance_init (FsoGsmPlusCEER * self) {
}


static void fso_gsm_plus_ceer_finalize (GObject* obj) {
	FsoGsmPlusCEER * self;
	self = FSO_GSM_PLUS_CEER (obj);
	_g_free0 (self->reason);
	G_OBJECT_CLASS (fso_gsm_plus_ceer_parent_class)->finalize (obj);
}


GType fso_gsm_plus_ceer_get_type (void) {
	static volatile gsize fso_gsm_plus_ceer_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_ceer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCEERClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_ceer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCEER), 0, (GInstanceInitFunc) fso_gsm_plus_ceer_instance_init, NULL };
		GType fso_gsm_plus_ceer_type_id;
		fso_gsm_plus_ceer_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCEER", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_ceer_type_id__volatile, fso_gsm_plus_ceer_type_id);
	}
	return fso_gsm_plus_ceer_type_id__volatile;
}


FsoGsmPlusCFUN* fso_gsm_plus_cfun_construct (GType object_type) {
	FsoGsmPlusCFUN * self = NULL;
	self = (FsoGsmPlusCFUN*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CFUN", FALSE);
	return self;
}


FsoGsmPlusCFUN* fso_gsm_plus_cfun_new (void) {
	return fso_gsm_plus_cfun_construct (FSO_GSM_TYPE_PLUS_CFUN);
}


static guint fso_gsm_plus_cfun_real_get_timeout (FsoGsmAbstractAtCommand* base) {
	FsoGsmPlusCFUN * self;
	guint result = 0U;
	self = (FsoGsmPlusCFUN*) base;
	result = FSO_GSM_SIM_COMM_TIMEOUT;
	return result;
}


static void fso_gsm_plus_cfun_class_init (FsoGsmPlusCFUNClass * klass) {
	fso_gsm_plus_cfun_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->get_timeout = fso_gsm_plus_cfun_real_get_timeout;
}


static void fso_gsm_plus_cfun_instance_init (FsoGsmPlusCFUN * self) {
}


GType fso_gsm_plus_cfun_get_type (void) {
	static volatile gsize fso_gsm_plus_cfun_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cfun_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCFUNClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cfun_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCFUN), 0, (GInstanceInitFunc) fso_gsm_plus_cfun_instance_init, NULL };
		GType fso_gsm_plus_cfun_type_id;
		fso_gsm_plus_cfun_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCFUN", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cfun_type_id__volatile, fso_gsm_plus_cfun_type_id);
	}
	return fso_gsm_plus_cfun_type_id__volatile;
}


FsoGsmPlusCGACT* fso_gsm_plus_cgact_construct (GType object_type) {
	FsoGsmPlusCGACT * self = NULL;
	self = (FsoGsmPlusCGACT*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CGACT", FALSE);
	return self;
}


FsoGsmPlusCGACT* fso_gsm_plus_cgact_new (void) {
	return fso_gsm_plus_cgact_construct (FSO_GSM_TYPE_PLUS_CGACT);
}


static void fso_gsm_plus_cgact_class_init (FsoGsmPlusCGACTClass * klass) {
	fso_gsm_plus_cgact_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cgact_instance_init (FsoGsmPlusCGACT * self) {
}


GType fso_gsm_plus_cgact_get_type (void) {
	static volatile gsize fso_gsm_plus_cgact_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cgact_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCGACTClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cgact_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCGACT), 0, (GInstanceInitFunc) fso_gsm_plus_cgact_instance_init, NULL };
		GType fso_gsm_plus_cgact_type_id;
		fso_gsm_plus_cgact_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCGACT", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cgact_type_id__volatile, fso_gsm_plus_cgact_type_id);
	}
	return fso_gsm_plus_cgact_type_id__volatile;
}


FsoGsmPlusCGATT* fso_gsm_plus_cgatt_construct (GType object_type) {
	FsoGsmPlusCGATT * self = NULL;
	self = (FsoGsmPlusCGATT*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CGATT", FALSE);
	return self;
}


FsoGsmPlusCGATT* fso_gsm_plus_cgatt_new (void) {
	return fso_gsm_plus_cgatt_construct (FSO_GSM_TYPE_PLUS_CGATT);
}


static void fso_gsm_plus_cgatt_class_init (FsoGsmPlusCGATTClass * klass) {
	fso_gsm_plus_cgatt_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cgatt_instance_init (FsoGsmPlusCGATT * self) {
}


GType fso_gsm_plus_cgatt_get_type (void) {
	static volatile gsize fso_gsm_plus_cgatt_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cgatt_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCGATTClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cgatt_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCGATT), 0, (GInstanceInitFunc) fso_gsm_plus_cgatt_instance_init, NULL };
		GType fso_gsm_plus_cgatt_type_id;
		fso_gsm_plus_cgatt_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCGATT", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cgatt_type_id__volatile, fso_gsm_plus_cgatt_type_id);
	}
	return fso_gsm_plus_cgatt_type_id__volatile;
}


FsoGsmPlusCGCLASS* fso_gsm_plus_cgclass_construct (GType object_type) {
	FsoGsmPlusCGCLASS * self = NULL;
	self = (FsoGsmPlusCGCLASS*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "+CGCLASS", FALSE);
	return self;
}


FsoGsmPlusCGCLASS* fso_gsm_plus_cgclass_new (void) {
	return fso_gsm_plus_cgclass_construct (FSO_GSM_TYPE_PLUS_CGCLASS);
}


static void fso_gsm_plus_cgclass_class_init (FsoGsmPlusCGCLASSClass * klass) {
	fso_gsm_plus_cgclass_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cgclass_instance_init (FsoGsmPlusCGCLASS * self) {
}


GType fso_gsm_plus_cgclass_get_type (void) {
	static volatile gsize fso_gsm_plus_cgclass_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cgclass_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCGCLASSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cgclass_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCGCLASS), 0, (GInstanceInitFunc) fso_gsm_plus_cgclass_instance_init, NULL };
		GType fso_gsm_plus_cgclass_type_id;
		fso_gsm_plus_cgclass_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCGCLASS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cgclass_type_id__volatile, fso_gsm_plus_cgclass_type_id);
	}
	return fso_gsm_plus_cgclass_type_id__volatile;
}


FsoGsmPlusCGDCONT* fso_gsm_plus_cgdcont_construct (GType object_type) {
	FsoGsmPlusCGDCONT * self = NULL;
	gchar* _tmp0_;
	gchar** _tmp1_ = NULL;
	self = (FsoGsmPlusCGDCONT*) fso_gsm_abstract_at_command_construct (object_type);
	_tmp0_ = g_strdup ("+CGDCONT: ");
	_tmp1_ = g_new0 (gchar*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp1_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCGDCONT* fso_gsm_plus_cgdcont_new (void) {
	return fso_gsm_plus_cgdcont_construct (FSO_GSM_TYPE_PLUS_CGDCONT);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


gchar* fso_gsm_plus_cgdcont_issue (FsoGsmPlusCGDCONT* self, const gchar* apn) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (apn != NULL, NULL);
	_tmp0_ = apn;
	_tmp1_ = string_to_string (_tmp0_);
	_tmp2_ = g_strconcat ("+CGDCONT=1,\"IP\",\"", _tmp1_, "\"", NULL);
	result = _tmp2_;
	return result;
}


static void fso_gsm_plus_cgdcont_class_init (FsoGsmPlusCGDCONTClass * klass) {
	fso_gsm_plus_cgdcont_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cgdcont_instance_init (FsoGsmPlusCGDCONT * self) {
}


GType fso_gsm_plus_cgdcont_get_type (void) {
	static volatile gsize fso_gsm_plus_cgdcont_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cgdcont_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCGDCONTClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cgdcont_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCGDCONT), 0, (GInstanceInitFunc) fso_gsm_plus_cgdcont_instance_init, NULL };
		GType fso_gsm_plus_cgdcont_type_id;
		fso_gsm_plus_cgdcont_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCGDCONT", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cgdcont_type_id__volatile, fso_gsm_plus_cgdcont_type_id);
	}
	return fso_gsm_plus_cgdcont_type_id__volatile;
}


FsoGsmPlusCGMI* fso_gsm_plus_cgmi_construct (GType object_type) {
	FsoGsmPlusCGMI * self = NULL;
	self = (FsoGsmPlusCGMI*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "+CGMI", TRUE);
	return self;
}


FsoGsmPlusCGMI* fso_gsm_plus_cgmi_new (void) {
	return fso_gsm_plus_cgmi_construct (FSO_GSM_TYPE_PLUS_CGMI);
}


static void fso_gsm_plus_cgmi_class_init (FsoGsmPlusCGMIClass * klass) {
	fso_gsm_plus_cgmi_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cgmi_instance_init (FsoGsmPlusCGMI * self) {
}


GType fso_gsm_plus_cgmi_get_type (void) {
	static volatile gsize fso_gsm_plus_cgmi_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cgmi_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCGMIClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cgmi_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCGMI), 0, (GInstanceInitFunc) fso_gsm_plus_cgmi_instance_init, NULL };
		GType fso_gsm_plus_cgmi_type_id;
		fso_gsm_plus_cgmi_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCGMI", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cgmi_type_id__volatile, fso_gsm_plus_cgmi_type_id);
	}
	return fso_gsm_plus_cgmi_type_id__volatile;
}


FsoGsmPlusCGMM* fso_gsm_plus_cgmm_construct (GType object_type) {
	FsoGsmPlusCGMM * self = NULL;
	self = (FsoGsmPlusCGMM*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "+CGMM", TRUE);
	return self;
}


FsoGsmPlusCGMM* fso_gsm_plus_cgmm_new (void) {
	return fso_gsm_plus_cgmm_construct (FSO_GSM_TYPE_PLUS_CGMM);
}


static void fso_gsm_plus_cgmm_class_init (FsoGsmPlusCGMMClass * klass) {
	fso_gsm_plus_cgmm_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cgmm_instance_init (FsoGsmPlusCGMM * self) {
}


GType fso_gsm_plus_cgmm_get_type (void) {
	static volatile gsize fso_gsm_plus_cgmm_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cgmm_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCGMMClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cgmm_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCGMM), 0, (GInstanceInitFunc) fso_gsm_plus_cgmm_instance_init, NULL };
		GType fso_gsm_plus_cgmm_type_id;
		fso_gsm_plus_cgmm_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCGMM", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cgmm_type_id__volatile, fso_gsm_plus_cgmm_type_id);
	}
	return fso_gsm_plus_cgmm_type_id__volatile;
}


FsoGsmPlusCGMR* fso_gsm_plus_cgmr_construct (GType object_type) {
	FsoGsmPlusCGMR * self = NULL;
	self = (FsoGsmPlusCGMR*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "+CGMR", TRUE);
	return self;
}


FsoGsmPlusCGMR* fso_gsm_plus_cgmr_new (void) {
	return fso_gsm_plus_cgmr_construct (FSO_GSM_TYPE_PLUS_CGMR);
}


static void fso_gsm_plus_cgmr_class_init (FsoGsmPlusCGMRClass * klass) {
	fso_gsm_plus_cgmr_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cgmr_instance_init (FsoGsmPlusCGMR * self) {
}


GType fso_gsm_plus_cgmr_get_type (void) {
	static volatile gsize fso_gsm_plus_cgmr_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cgmr_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCGMRClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cgmr_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCGMR), 0, (GInstanceInitFunc) fso_gsm_plus_cgmr_instance_init, NULL };
		GType fso_gsm_plus_cgmr_type_id;
		fso_gsm_plus_cgmr_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCGMR", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cgmr_type_id__volatile, fso_gsm_plus_cgmr_type_id);
	}
	return fso_gsm_plus_cgmr_type_id__volatile;
}


FsoGsmPlusCGREG* fso_gsm_plus_cgreg_construct (GType object_type) {
	FsoGsmPlusCGREG * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCGREG*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CGREG: (?P<mode>\\d),(?P<status>\\d)(?:,\"?(?P<lac>[0-9A-F]*)\"?,\"" \
"?(?P<cid>[0-9A-F]*)\"?)?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch14_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally14;
	__catch14_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally14:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CGREG: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCGREG* fso_gsm_plus_cgreg_new (void) {
	return fso_gsm_plus_cgreg_construct (FSO_GSM_TYPE_PLUS_CGREG);
}


static void fso_gsm_plus_cgreg_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCGREG * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCGREG*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cgreg_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mode");
	self->mode = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "status");
	self->status = _tmp2_;
	_tmp3_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "lac");
	_g_free0 (self->lac);
	self->lac = _tmp3_;
	_tmp4_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "cid");
	_g_free0 (self->cid);
	self->cid = _tmp4_;
}


gchar* fso_gsm_plus_cgreg_query (FsoGsmPlusCGREG* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CGREG?");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_cgreg_issue (FsoGsmPlusCGREG* self, gint mode) {
	gchar* result = NULL;
	gint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = mode;
	_tmp1_ = g_strdup_printf ("%i", _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("+CGREG=", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


gchar* fso_gsm_plus_cgreg_queryFull (FsoGsmPlusCGREG* self, gint restoreMode) {
	gchar* result = NULL;
	gint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = restoreMode;
	_tmp1_ = g_strdup_printf ("%i", _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("+CGREG=2;+CGREG?;+CGREG=", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


static void fso_gsm_plus_cgreg_class_init (FsoGsmPlusCGREGClass * klass) {
	fso_gsm_plus_cgreg_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cgreg_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cgreg_finalize;
}


static void fso_gsm_plus_cgreg_instance_init (FsoGsmPlusCGREG * self) {
}


static void fso_gsm_plus_cgreg_finalize (GObject* obj) {
	FsoGsmPlusCGREG * self;
	self = FSO_GSM_PLUS_CGREG (obj);
	_g_free0 (self->lac);
	_g_free0 (self->cid);
	G_OBJECT_CLASS (fso_gsm_plus_cgreg_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cgreg_get_type (void) {
	static volatile gsize fso_gsm_plus_cgreg_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cgreg_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCGREGClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cgreg_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCGREG), 0, (GInstanceInitFunc) fso_gsm_plus_cgreg_instance_init, NULL };
		GType fso_gsm_plus_cgreg_type_id;
		fso_gsm_plus_cgreg_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCGREG", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cgreg_type_id__volatile, fso_gsm_plus_cgreg_type_id);
	}
	return fso_gsm_plus_cgreg_type_id__volatile;
}


FsoGsmPlusCGSN* fso_gsm_plus_cgsn_construct (GType object_type) {
	FsoGsmPlusCGSN * self = NULL;
	self = (FsoGsmPlusCGSN*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "+CGSN", TRUE);
	return self;
}


FsoGsmPlusCGSN* fso_gsm_plus_cgsn_new (void) {
	return fso_gsm_plus_cgsn_construct (FSO_GSM_TYPE_PLUS_CGSN);
}


static void fso_gsm_plus_cgsn_class_init (FsoGsmPlusCGSNClass * klass) {
	fso_gsm_plus_cgsn_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cgsn_instance_init (FsoGsmPlusCGSN * self) {
}


GType fso_gsm_plus_cgsn_get_type (void) {
	static volatile gsize fso_gsm_plus_cgsn_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cgsn_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCGSNClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cgsn_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCGSN), 0, (GInstanceInitFunc) fso_gsm_plus_cgsn_instance_init, NULL };
		GType fso_gsm_plus_cgsn_type_id;
		fso_gsm_plus_cgsn_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCGSN", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cgsn_type_id__volatile, fso_gsm_plus_cgsn_type_id);
	}
	return fso_gsm_plus_cgsn_type_id__volatile;
}


GType fso_gsm_plus_chld_action_get_type (void) {
	static volatile gsize fso_gsm_plus_chld_action_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_chld_action_type_id__volatile)) {
		static const GEnumValue values[] = {{FSO_GSM_PLUS_CHLD_ACTION_DROP_ALL_OR_SEND_BUSY, "FSO_GSM_PLUS_CHLD_ACTION_DROP_ALL_OR_SEND_BUSY", "drop-all-or-send-busy"}, {FSO_GSM_PLUS_CHLD_ACTION_DROP_ALL_AND_ACCEPT_WAITING_OR_HELD, "FSO_GSM_PLUS_CHLD_ACTION_DROP_ALL_AND_ACCEPT_WAITING_OR_HELD", "drop-all-and-accept-waiting-or-held"}, {FSO_GSM_PLUS_CHLD_ACTION_DROP_SPECIFIC_AND_ACCEPT_WAITING_OR_HELD, "FSO_GSM_PLUS_CHLD_ACTION_DROP_SPECIFIC_AND_ACCEPT_WAITING_OR_HELD", "drop-specific-and-accept-waiting-or-held"}, {FSO_GSM_PLUS_CHLD_ACTION_HOLD_ALL_AND_ACCEPT_WAITING_OR_HELD, "FSO_GSM_PLUS_CHLD_ACTION_HOLD_ALL_AND_ACCEPT_WAITING_OR_HELD", "hold-all-and-accept-waiting-or-held"}, {FSO_GSM_PLUS_CHLD_ACTION_HOLD_SPECIFIC_AND_ACCEPT_WAITING_OR_HELD, "FSO_GSM_PLUS_CHLD_ACTION_HOLD_SPECIFIC_AND_ACCEPT_WAITING_OR_HELD", "hold-specific-and-accept-waiting-or-held"}, {FSO_GSM_PLUS_CHLD_ACTION_ACTIVATE_HELD, "FSO_GSM_PLUS_CHLD_ACTION_ACTIVATE_HELD", "activate-held"}, {FSO_GSM_PLUS_CHLD_ACTION_DROP_SELF_AND_CONNECT_ACTIVE, "FSO_GSM_PLUS_CHLD_ACTION_DROP_SELF_AND_CONNECT_ACTIVE", "drop-self-and-connect-active"}, {0, NULL, NULL}};
		GType fso_gsm_plus_chld_action_type_id;
		fso_gsm_plus_chld_action_type_id = g_enum_register_static ("FsoGsmPlusCHLDAction", values);
		g_once_init_leave (&fso_gsm_plus_chld_action_type_id__volatile, fso_gsm_plus_chld_action_type_id);
	}
	return fso_gsm_plus_chld_action_type_id__volatile;
}


gchar* fso_gsm_plus_chld_issue (FsoGsmPlusCHLD* self, FsoGsmPlusCHLDAction action, gint cid) {
	gchar* result = NULL;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = cid;
	if (_tmp0_ > 0) {
		FsoGsmPlusCHLDAction _tmp1_;
		gint _tmp2_;
		gchar* _tmp3_ = NULL;
		_tmp1_ = action;
		_tmp2_ = cid;
		_tmp3_ = g_strdup_printf ("+CHLD=%d%d", (gint) _tmp1_, _tmp2_);
		result = _tmp3_;
		return result;
	} else {
		FsoGsmPlusCHLDAction _tmp4_;
		gchar* _tmp5_ = NULL;
		_tmp4_ = action;
		_tmp5_ = g_strdup_printf ("+CHLD=%d", (gint) _tmp4_);
		result = _tmp5_;
		return result;
	}
}


FsoGsmPlusCHLD* fso_gsm_plus_chld_construct (GType object_type) {
	FsoGsmPlusCHLD * self = NULL;
	self = (FsoGsmPlusCHLD*) fso_gsm_abstract_at_command_construct (object_type);
	return self;
}


FsoGsmPlusCHLD* fso_gsm_plus_chld_new (void) {
	return fso_gsm_plus_chld_construct (FSO_GSM_TYPE_PLUS_CHLD);
}


static void fso_gsm_plus_chld_class_init (FsoGsmPlusCHLDClass * klass) {
	fso_gsm_plus_chld_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_chld_instance_init (FsoGsmPlusCHLD * self) {
}


GType fso_gsm_plus_chld_get_type (void) {
	static volatile gsize fso_gsm_plus_chld_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_chld_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCHLDClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_chld_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCHLD), 0, (GInstanceInitFunc) fso_gsm_plus_chld_instance_init, NULL };
		GType fso_gsm_plus_chld_type_id;
		fso_gsm_plus_chld_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCHLD", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_chld_type_id__volatile, fso_gsm_plus_chld_type_id);
	}
	return fso_gsm_plus_chld_type_id__volatile;
}


FsoGsmPlusCIEV* fso_gsm_plus_ciev_construct (GType object_type) {
	FsoGsmPlusCIEV * self = NULL;
	self = (FsoGsmPlusCIEV*) fso_gsm_two_params_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, G_TYPE_INT, NULL, NULL, "+CIEV", FALSE);
	return self;
}


FsoGsmPlusCIEV* fso_gsm_plus_ciev_new (void) {
	return fso_gsm_plus_ciev_construct (FSO_GSM_TYPE_PLUS_CIEV);
}


static void fso_gsm_plus_ciev_class_init (FsoGsmPlusCIEVClass * klass) {
	fso_gsm_plus_ciev_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_ciev_instance_init (FsoGsmPlusCIEV * self) {
}


GType fso_gsm_plus_ciev_get_type (void) {
	static volatile gsize fso_gsm_plus_ciev_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_ciev_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCIEVClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_ciev_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCIEV), 0, (GInstanceInitFunc) fso_gsm_plus_ciev_instance_init, NULL };
		GType fso_gsm_plus_ciev_type_id;
		fso_gsm_plus_ciev_type_id = g_type_register_static (FSO_GSM_TYPE_TWO_PARAMS_AT_COMMAND, "FsoGsmPlusCIEV", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_ciev_type_id__volatile, fso_gsm_plus_ciev_type_id);
	}
	return fso_gsm_plus_ciev_type_id__volatile;
}


FsoGsmPlusCIMI* fso_gsm_plus_cimi_construct (GType object_type) {
	FsoGsmPlusCIMI * self = NULL;
	self = (FsoGsmPlusCIMI*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "+CIMI", TRUE);
	return self;
}


FsoGsmPlusCIMI* fso_gsm_plus_cimi_new (void) {
	return fso_gsm_plus_cimi_construct (FSO_GSM_TYPE_PLUS_CIMI);
}


static void fso_gsm_plus_cimi_class_init (FsoGsmPlusCIMIClass * klass) {
	fso_gsm_plus_cimi_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cimi_instance_init (FsoGsmPlusCIMI * self) {
}


GType fso_gsm_plus_cimi_get_type (void) {
	static volatile gsize fso_gsm_plus_cimi_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cimi_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCIMIClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cimi_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCIMI), 0, (GInstanceInitFunc) fso_gsm_plus_cimi_instance_init, NULL };
		GType fso_gsm_plus_cimi_type_id;
		fso_gsm_plus_cimi_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCIMI", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cimi_type_id__volatile, fso_gsm_plus_cimi_type_id);
	}
	return fso_gsm_plus_cimi_type_id__volatile;
}


static void _vala_FreeSmartphoneGSMCallDetail_array_free (FreeSmartphoneGSMCallDetail* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			free_smartphone_gsm_call_detail_destroy (&array[i]);
		}
	}
	g_free (array);
}


FsoGsmPlusCLCC* fso_gsm_plus_clcc_construct (GType object_type) {
	FsoGsmPlusCLCC * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCLCC*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CLCC: (?P<id>\\d),(?P<dir>\\d),(?P<stat>\\d),(?P<mode>\\d),(?P<mpty" \
">\\d)(?:,\"(?P<number>[\\+0-9*#w]+)\",(?P<typ>\\d+)(?:,\"(?P<name>[^\"" \
"]*)\")?)?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch15_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally15;
	__catch15_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally15:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CLCC: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCLCC* fso_gsm_plus_clcc_new (void) {
	return fso_gsm_plus_clcc_construct (FSO_GSM_TYPE_PLUS_CLCC);
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_variant_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_variant_unref (var), NULL));
}


static GVariant* _variant_new3 (gchar* value) {
	return g_variant_ref_sink (g_variant_new_string (value));
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


static GVariant* _variant_new4 (gchar* value) {
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant* _variant_new5 (gchar* value) {
	return g_variant_ref_sink (g_variant_new_string (value));
}


static void _vala_array_add1 (FreeSmartphoneGSMCallDetail** array, int* length, int* size, const FreeSmartphoneGSMCallDetail* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (FreeSmartphoneGSMCallDetail, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static FreeSmartphoneGSMCallDetail* _vala_array_dup1 (FreeSmartphoneGSMCallDetail* self, int length) {
	FreeSmartphoneGSMCallDetail* result;
	int i;
	result = g_new0 (FreeSmartphoneGSMCallDetail, length);
	for (i = 0; i < length; i++) {
		FreeSmartphoneGSMCallDetail _tmp0_ = {0};
		free_smartphone_gsm_call_detail_copy (&self[i], &_tmp0_);
		result[i] = _tmp0_;
	}
	return result;
}


static void fso_gsm_plus_clcc_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error) {
	FsoGsmPlusCLCC * self;
	FreeSmartphoneGSMCallDetail* _tmp0_ = NULL;
	FreeSmartphoneGSMCallDetail* c;
	gint c_length1;
	gint _c_size_;
	gchar** _tmp1_;
	gint _tmp1__length1;
	FreeSmartphoneGSMCallDetail* _tmp43_;
	gint _tmp43__length1;
	FreeSmartphoneGSMCallDetail* _tmp44_;
	gint _tmp44__length1;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCLCC*) base;
	_tmp0_ = g_new0 (FreeSmartphoneGSMCallDetail, 0);
	c = _tmp0_;
	c_length1 = 0;
	_c_size_ = c_length1;
	_tmp1_ = response;
	_tmp1__length1 = response_length1;
	{
		gchar** line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp1_;
		line_collection_length1 = _tmp1__length1;
		for (line_it = 0; line_it < _tmp1__length1; line_it = line_it + 1) {
			gchar* _tmp2_;
			gchar* line = NULL;
			_tmp2_ = g_strdup (line_collection[line_it]);
			line = _tmp2_;
			{
				const gchar* _tmp3_;
				gint _tmp4_ = 0;
				gint _tmp5_ = 0;
				FreeSmartphoneGSMCallStatus _tmp6_ = 0;
				GHashFunc _tmp7_;
				GEqualFunc _tmp8_;
				GHashTable* _tmp9_;
				GHashTable* _tmp10_;
				FreeSmartphoneGSMCallDetail entry = {0};
				GVariant* strvalue = NULL;
				gint _tmp11_ = 0;
				gchar* _tmp12_ = NULL;
				gchar* _tmp13_;
				GVariant* _tmp14_;
				FreeSmartphoneGSMCallDetail _tmp15_;
				GHashTable* _tmp16_;
				gchar* _tmp17_;
				GVariant* _tmp18_;
				GVariant* _tmp19_;
				gchar* _tmp20_ = NULL;
				gchar* _tmp21_;
				gint _tmp22_ = 0;
				gchar* _tmp23_ = NULL;
				gchar* _tmp24_;
				GVariant* _tmp25_;
				FreeSmartphoneGSMCallDetail _tmp26_;
				GHashTable* _tmp27_;
				gchar* _tmp28_;
				GVariant* _tmp29_;
				GVariant* _tmp30_;
				gint _tmp31_ = 0;
				gchar* _tmp32_ = NULL;
				gchar* _tmp33_;
				GVariant* _tmp34_;
				FreeSmartphoneGSMCallDetail _tmp35_;
				GHashTable* _tmp36_;
				gchar* _tmp37_;
				GVariant* _tmp38_;
				GVariant* _tmp39_;
				FreeSmartphoneGSMCallDetail* _tmp40_;
				gint _tmp40__length1;
				FreeSmartphoneGSMCallDetail _tmp41_;
				FreeSmartphoneGSMCallDetail _tmp42_ = {0};
				_tmp3_ = line;
				FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_clcc_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp3_, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_free0 (line);
						c = (_vala_FreeSmartphoneGSMCallDetail_array_free (c, c_length1), NULL);
						return;
					} else {
						_g_free0 (line);
						c = (_vala_FreeSmartphoneGSMCallDetail_array_free (c, c_length1), NULL);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				_tmp4_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "id");
				_tmp5_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "stat");
				_tmp6_ = fso_gsm_constants_callStatusToEnum (_tmp5_);
				_tmp7_ = g_str_hash;
				_tmp8_ = g_str_equal;
				_tmp9_ = g_hash_table_new_full (_tmp7_, _tmp8_, _g_free0_, _g_variant_unref0_);
				_tmp10_ = _tmp9_;
				free_smartphone_gsm_call_detail_init (&entry, _tmp4_, _tmp6_, _tmp10_);
				_g_hash_table_unref0 (_tmp10_);
				_tmp11_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "dir");
				_tmp12_ = fso_gsm_constants_callDirectionToString (_tmp11_);
				_tmp13_ = _tmp12_;
				_tmp14_ = _variant_new3 (_tmp13_);
				_g_variant_unref0 (strvalue);
				strvalue = _tmp14_;
				_g_free0 (_tmp13_);
				_tmp15_ = entry;
				_tmp16_ = _tmp15_.properties;
				_tmp17_ = g_strdup ("direction");
				_tmp18_ = strvalue;
				_tmp19_ = _g_variant_ref0 (_tmp18_);
				g_hash_table_insert (_tmp16_, _tmp17_, _tmp19_);
				_tmp20_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "number");
				_tmp21_ = _tmp20_;
				_tmp22_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "typ");
				_tmp23_ = fso_gsm_constants_phonenumberTupleToString (_tmp21_, _tmp22_);
				_tmp24_ = _tmp23_;
				_tmp25_ = _variant_new4 (_tmp24_);
				_g_variant_unref0 (strvalue);
				strvalue = _tmp25_;
				_g_free0 (_tmp24_);
				_g_free0 (_tmp21_);
				_tmp26_ = entry;
				_tmp27_ = _tmp26_.properties;
				_tmp28_ = g_strdup ("peer");
				_tmp29_ = strvalue;
				_tmp30_ = _g_variant_ref0 (_tmp29_);
				g_hash_table_insert (_tmp27_, _tmp28_, _tmp30_);
				_tmp31_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mode");
				_tmp32_ = fso_gsm_constants_callTypeToString (_tmp31_);
				_tmp33_ = _tmp32_;
				_tmp34_ = _variant_new5 (_tmp33_);
				_g_variant_unref0 (strvalue);
				strvalue = _tmp34_;
				_g_free0 (_tmp33_);
				_tmp35_ = entry;
				_tmp36_ = _tmp35_.properties;
				_tmp37_ = g_strdup ("type");
				_tmp38_ = strvalue;
				_tmp39_ = _g_variant_ref0 (_tmp38_);
				g_hash_table_insert (_tmp36_, _tmp37_, _tmp39_);
				_tmp40_ = c;
				_tmp40__length1 = c_length1;
				_tmp41_ = entry;
				free_smartphone_gsm_call_detail_copy (&_tmp41_, &_tmp42_);
				_vala_array_add1 (&c, &c_length1, &_c_size_, &_tmp42_);
				_g_variant_unref0 (strvalue);
				free_smartphone_gsm_call_detail_destroy (&entry);
				_g_free0 (line);
			}
		}
	}
	_tmp43_ = c;
	_tmp43__length1 = c_length1;
	_tmp44_ = (_tmp43_ != NULL) ? _vala_array_dup1 (_tmp43_, _tmp43__length1) : ((gpointer) _tmp43_);
	_tmp44__length1 = _tmp43__length1;
	self->calls = (_vala_FreeSmartphoneGSMCallDetail_array_free (self->calls, self->calls_length1), NULL);
	self->calls = _tmp44_;
	self->calls_length1 = _tmp44__length1;
	c = (_vala_FreeSmartphoneGSMCallDetail_array_free (c, c_length1), NULL);
}


gchar* fso_gsm_plus_clcc_execute (FsoGsmPlusCLCC* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CLCC");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_clcc_query (FsoGsmPlusCLCC* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CLCC?");
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_clcc_class_init (FsoGsmPlusCLCCClass * klass) {
	fso_gsm_plus_clcc_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseMulti = fso_gsm_plus_clcc_real_parseMulti;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_clcc_finalize;
}


static void fso_gsm_plus_clcc_instance_init (FsoGsmPlusCLCC * self) {
}


static void fso_gsm_plus_clcc_finalize (GObject* obj) {
	FsoGsmPlusCLCC * self;
	self = FSO_GSM_PLUS_CLCC (obj);
	self->calls = (_vala_FreeSmartphoneGSMCallDetail_array_free (self->calls, self->calls_length1), NULL);
	G_OBJECT_CLASS (fso_gsm_plus_clcc_parent_class)->finalize (obj);
}


GType fso_gsm_plus_clcc_get_type (void) {
	static volatile gsize fso_gsm_plus_clcc_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_clcc_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCLCCClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_clcc_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCLCC), 0, (GInstanceInitFunc) fso_gsm_plus_clcc_instance_init, NULL };
		GType fso_gsm_plus_clcc_type_id;
		fso_gsm_plus_clcc_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCLCC", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_clcc_type_id__volatile, fso_gsm_plus_clcc_type_id);
	}
	return fso_gsm_plus_clcc_type_id__volatile;
}


GType fso_gsm_plus_clck_mode_get_type (void) {
	static volatile gsize fso_gsm_plus_clck_mode_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_clck_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{FSO_GSM_PLUS_CLCK_MODE_DISABLE, "FSO_GSM_PLUS_CLCK_MODE_DISABLE", "disable"}, {FSO_GSM_PLUS_CLCK_MODE_ENABLE, "FSO_GSM_PLUS_CLCK_MODE_ENABLE", "enable"}, {FSO_GSM_PLUS_CLCK_MODE_QUERY, "FSO_GSM_PLUS_CLCK_MODE_QUERY", "query"}, {0, NULL, NULL}};
		GType fso_gsm_plus_clck_mode_type_id;
		fso_gsm_plus_clck_mode_type_id = g_enum_register_static ("FsoGsmPlusCLCKMode", values);
		g_once_init_leave (&fso_gsm_plus_clck_mode_type_id__volatile, fso_gsm_plus_clck_mode_type_id);
	}
	return fso_gsm_plus_clck_mode_type_id__volatile;
}


FsoGsmPlusCLCK* fso_gsm_plus_clck_construct (GType object_type) {
	FsoGsmPlusCLCK * self = NULL;
	gchar* _tmp4_;
	gchar** _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCLCK*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		GRegex* _tmp2_;
		GRegex* _tmp3_;
		_tmp0_ = g_regex_new ("\\+CLCK: (?P<enabled>[01])(?:,(?P<class>\\d+))?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch16_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
		_tmp2_ = g_regex_new ("\\+CLCK: \\((?P<facilities>[^\\)]*)\\)", 0, 0, &_inner_error_);
		_tmp3_ = _tmp2_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch16_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->tere);
		((FsoGsmAbstractAtCommand*) self)->tere = _tmp3_;
	}
	goto __finally16;
	__catch16_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally16:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = g_strdup ("+CLCK: ");
	_tmp5_ = g_new0 (gchar*, 1 + 1);
	_tmp5_[0] = _tmp4_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp5_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCLCK* fso_gsm_plus_clck_new (void) {
	return fso_gsm_plus_clck_construct (FSO_GSM_TYPE_PLUS_CLCK);
}


static void fso_gsm_plus_clck_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCLCK * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCLCK*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_clck_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "enabled");
	self->enabled = _tmp1_ == 1;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "class");
	self->klass = _tmp2_;
}


static void fso_gsm_plus_clck_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCLCK * self;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCLCK*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_clck_parent_class)->parseTest (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "facilities");
	_g_free0 (self->facilities);
	self->facilities = _tmp1_;
}


gchar* fso_gsm_plus_clck_query (FsoGsmPlusCLCK* self, const gchar* facility) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (facility != NULL, NULL);
	_tmp0_ = facility;
	_tmp1_ = g_strdup_printf ("+CLCK=\"%s\",%d", _tmp0_, (gint) FSO_GSM_PLUS_CLCK_MODE_QUERY);
	result = _tmp1_;
	return result;
}


gchar* fso_gsm_plus_clck_issue (FsoGsmPlusCLCK* self, const gchar* facility, gboolean enable, const gchar* pin) {
	gchar* result = NULL;
	gint _tmp0_ = 0;
	gboolean _tmp1_;
	const gchar* _tmp2_;
	gint _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (facility != NULL, NULL);
	g_return_val_if_fail (pin != NULL, NULL);
	_tmp1_ = enable;
	if (_tmp1_) {
		_tmp0_ = (gint) FSO_GSM_PLUS_CLCK_MODE_ENABLE;
	} else {
		_tmp0_ = (gint) FSO_GSM_PLUS_CLCK_MODE_DISABLE;
	}
	_tmp2_ = facility;
	_tmp3_ = _tmp0_;
	_tmp4_ = pin;
	_tmp5_ = g_strdup_printf ("+CLCK=\"%s\",%d,\"%s\"", _tmp2_, _tmp3_, _tmp4_);
	result = _tmp5_;
	return result;
}


gchar* fso_gsm_plus_clck_test (FsoGsmPlusCLCK* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CLCK=?");
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_clck_class_init (FsoGsmPlusCLCKClass * klass) {
	fso_gsm_plus_clck_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_clck_real_parse;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseTest = fso_gsm_plus_clck_real_parseTest;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_clck_finalize;
}


static void fso_gsm_plus_clck_instance_init (FsoGsmPlusCLCK * self) {
}


static void fso_gsm_plus_clck_finalize (GObject* obj) {
	FsoGsmPlusCLCK * self;
	self = FSO_GSM_PLUS_CLCK (obj);
	_g_free0 (self->facilities);
	G_OBJECT_CLASS (fso_gsm_plus_clck_parent_class)->finalize (obj);
}


GType fso_gsm_plus_clck_get_type (void) {
	static volatile gsize fso_gsm_plus_clck_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_clck_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCLCKClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_clck_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCLCK), 0, (GInstanceInitFunc) fso_gsm_plus_clck_instance_init, NULL };
		GType fso_gsm_plus_clck_type_id;
		fso_gsm_plus_clck_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCLCK", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_clck_type_id__volatile, fso_gsm_plus_clck_type_id);
	}
	return fso_gsm_plus_clck_type_id__volatile;
}


FsoGsmPlusCLIR* fso_gsm_plus_clir_construct (GType object_type) {
	FsoGsmPlusCLIR * self = NULL;
	self = (FsoGsmPlusCLIR*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CLIR", FALSE);
	return self;
}


FsoGsmPlusCLIR* fso_gsm_plus_clir_new (void) {
	return fso_gsm_plus_clir_construct (FSO_GSM_TYPE_PLUS_CLIR);
}


static void fso_gsm_plus_clir_class_init (FsoGsmPlusCLIRClass * klass) {
	fso_gsm_plus_clir_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_clir_instance_init (FsoGsmPlusCLIR * self) {
}


GType fso_gsm_plus_clir_get_type (void) {
	static volatile gsize fso_gsm_plus_clir_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_clir_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCLIRClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_clir_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCLIR), 0, (GInstanceInitFunc) fso_gsm_plus_clir_instance_init, NULL };
		GType fso_gsm_plus_clir_type_id;
		fso_gsm_plus_clir_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCLIR", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_clir_type_id__volatile, fso_gsm_plus_clir_type_id);
	}
	return fso_gsm_plus_clir_type_id__volatile;
}


FsoGsmPlusCLVL* fso_gsm_plus_clvl_construct (GType object_type) {
	FsoGsmPlusCLVL * self = NULL;
	self = (FsoGsmPlusCLVL*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CLVL", FALSE);
	return self;
}


FsoGsmPlusCLVL* fso_gsm_plus_clvl_new (void) {
	return fso_gsm_plus_clvl_construct (FSO_GSM_TYPE_PLUS_CLVL);
}


static void fso_gsm_plus_clvl_class_init (FsoGsmPlusCLVLClass * klass) {
	fso_gsm_plus_clvl_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_clvl_instance_init (FsoGsmPlusCLVL * self) {
}


GType fso_gsm_plus_clvl_get_type (void) {
	static volatile gsize fso_gsm_plus_clvl_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_clvl_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCLVLClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_clvl_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCLVL), 0, (GInstanceInitFunc) fso_gsm_plus_clvl_instance_init, NULL };
		GType fso_gsm_plus_clvl_type_id;
		fso_gsm_plus_clvl_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCLVL", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_clvl_type_id__volatile, fso_gsm_plus_clvl_type_id);
	}
	return fso_gsm_plus_clvl_type_id__volatile;
}


FsoGsmPlusCMGD* fso_gsm_plus_cmgd_construct (GType object_type) {
	FsoGsmPlusCMGD * self = NULL;
	self = (FsoGsmPlusCMGD*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CMGD", FALSE);
	return self;
}


FsoGsmPlusCMGD* fso_gsm_plus_cmgd_new (void) {
	return fso_gsm_plus_cmgd_construct (FSO_GSM_TYPE_PLUS_CMGD);
}


static void fso_gsm_plus_cmgd_class_init (FsoGsmPlusCMGDClass * klass) {
	fso_gsm_plus_cmgd_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cmgd_instance_init (FsoGsmPlusCMGD * self) {
}


GType fso_gsm_plus_cmgd_get_type (void) {
	static volatile gsize fso_gsm_plus_cmgd_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmgd_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMGDClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmgd_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMGD), 0, (GInstanceInitFunc) fso_gsm_plus_cmgd_instance_init, NULL };
		GType fso_gsm_plus_cmgd_type_id;
		fso_gsm_plus_cmgd_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCMGD", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmgd_type_id__volatile, fso_gsm_plus_cmgd_type_id);
	}
	return fso_gsm_plus_cmgd_type_id__volatile;
}


GType fso_gsm_plus_cmgl_mode_get_type (void) {
	static volatile gsize fso_gsm_plus_cmgl_mode_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmgl_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{FSO_GSM_PLUS_CMGL_MODE_INVALID, "FSO_GSM_PLUS_CMGL_MODE_INVALID", "invalid"}, {FSO_GSM_PLUS_CMGL_MODE_REC_UNREAD, "FSO_GSM_PLUS_CMGL_MODE_REC_UNREAD", "rec-unread"}, {FSO_GSM_PLUS_CMGL_MODE_REC_READ, "FSO_GSM_PLUS_CMGL_MODE_REC_READ", "rec-read"}, {FSO_GSM_PLUS_CMGL_MODE_STO_UNSENT, "FSO_GSM_PLUS_CMGL_MODE_STO_UNSENT", "sto-unsent"}, {FSO_GSM_PLUS_CMGL_MODE_STO_SENT, "FSO_GSM_PLUS_CMGL_MODE_STO_SENT", "sto-sent"}, {FSO_GSM_PLUS_CMGL_MODE_ALL, "FSO_GSM_PLUS_CMGL_MODE_ALL", "all"}, {0, NULL, NULL}};
		GType fso_gsm_plus_cmgl_mode_type_id;
		fso_gsm_plus_cmgl_mode_type_id = g_enum_register_static ("FsoGsmPlusCMGLMode", values);
		g_once_init_leave (&fso_gsm_plus_cmgl_mode_type_id__volatile, fso_gsm_plus_cmgl_mode_type_id);
	}
	return fso_gsm_plus_cmgl_mode_type_id__volatile;
}


FsoGsmPlusCMGL* fso_gsm_plus_cmgl_construct (GType object_type) {
	FsoGsmPlusCMGL * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGL*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CMGL: (?P<id>\\d+),(?P<stat>\\d),(?:\"(?P<alpha>[0-9ABCDEF]*)\")?,(" \
"?P<tpdulen>\\d+)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch17_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally17;
	__catch17_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally17:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CMGL: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCMGL* fso_gsm_plus_cmgl_new (void) {
	return fso_gsm_plus_cmgl_construct (FSO_GSM_TYPE_PLUS_CMGL);
}


static struct sms* sms_newFromHexPdu (const gchar* hexpdu, gint tpdulen) {
	struct sms* result = NULL;
	glong items_written;
	gchar* _tmp0_ = NULL;
	gchar* binpdu;
	gint binpdu_length1;
	gint _binpdu_size_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gint _tmp2__length1;
	glong _tmp3_ = 0L;
	glong _tmp4_;
	struct sms* _tmp5_;
	struct sms* sms;
	gchar* _tmp6_;
	gint _tmp6__length1;
	gint _tmp7_;
	struct sms* _tmp8_;
	gboolean _tmp9_ = FALSE;
	gboolean res;
	gboolean _tmp10_;
	g_return_val_if_fail (hexpdu != NULL, NULL);
	items_written = (glong) (-1);
	_tmp0_ = g_new0 (gchar, 1024);
	binpdu = _tmp0_;
	binpdu_length1 = 1024;
	_binpdu_size_ = binpdu_length1;
	_tmp1_ = hexpdu;
	_tmp2_ = binpdu;
	_tmp2__length1 = binpdu_length1;
	decode_hex_own_buf (_tmp1_, (glong) (-1), &_tmp3_, (gchar) 0, _tmp2_);
	items_written = _tmp3_;
	_tmp4_ = items_written;
	g_assert (_tmp4_ != ((glong) (-1)));
	_tmp5_ = sms_new ();
	sms = _tmp5_;
	_tmp6_ = binpdu;
	_tmp6__length1 = binpdu_length1;
	_tmp7_ = tpdulen;
	_tmp8_ = sms;
	_tmp9_ = sms_decode (_tmp6_, _tmp6__length1, FALSE, _tmp7_, _tmp8_);
	res = _tmp9_;
	_tmp10_ = res;
	if (!_tmp10_) {
		gint _tmp11_;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_;
		const gchar* _tmp14_;
		const gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		_tmp11_ = tpdulen;
		_tmp12_ = g_strdup_printf ("%i", _tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = hexpdu;
		_tmp15_ = string_to_string (_tmp14_);
		_tmp16_ = g_strconcat ("Sms.Message::newFromHexPdu: could not decode message w/ tpdulen ", _tmp13_, " and hexpdu ", _tmp15_, NULL);
		_tmp17_ = _tmp16_;
		g_warning ("fsogsm3rdparty.vapi:602: %s", _tmp17_);
		_g_free0 (_tmp17_);
		_g_free0 (_tmp13_);
		result = NULL;
		_sms_free0 (sms);
		binpdu = (g_free (binpdu), NULL);
		return result;
	} else {
		result = sms;
		binpdu = (g_free (binpdu), NULL);
		return result;
	}
	_sms_free0 (sms);
	binpdu = (g_free (binpdu), NULL);
}


static void fso_gsm_plus_cmgl_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error) {
	FsoGsmPlusCMGL * self;
	GeeArrayList* _tmp0_;
	gint tpdulen;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGL*) base;
	_tmp0_ = gee_array_list_new (TYPE_WRAP_SMS, (GBoxedCopyFunc) wrap_sms_ref, wrap_sms_unref, NULL);
	_g_object_unref0 (self->messagebook);
	self->messagebook = _tmp0_;
	tpdulen = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gchar** _tmp5_;
				gint _tmp5__length1;
				gint _tmp6_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = response;
				_tmp5__length1 = response_length1;
				if (!(_tmp4_ < _tmp5__length1)) {
					break;
				}
				_tmp6_ = i;
				if ((_tmp6_ % 2) == 0) {
					gchar** _tmp7_;
					gint _tmp7__length1;
					gint _tmp8_;
					const gchar* _tmp9_;
					gint _tmp10_ = 0;
					_tmp7_ = response;
					_tmp7__length1 = response_length1;
					_tmp8_ = i;
					_tmp9_ = _tmp7_[_tmp8_];
					FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cmgl_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp9_, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
							g_propagate_error (error, _inner_error_);
							return;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					_tmp10_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "tpdulen");
					tpdulen = _tmp10_;
				} else {
					gchar** _tmp11_;
					gint _tmp11__length1;
					gint _tmp12_;
					const gchar* _tmp13_;
					gint _tmp14_;
					struct sms* _tmp15_ = NULL;
					struct sms* sms;
					struct sms* _tmp16_;
					_tmp11_ = response;
					_tmp11__length1 = response_length1;
					_tmp12_ = i;
					_tmp13_ = _tmp11_[_tmp12_];
					_tmp14_ = tpdulen;
					_tmp15_ = sms_newFromHexPdu (_tmp13_, _tmp14_);
					sms = _tmp15_;
					_tmp16_ = sms;
					if (_tmp16_ != NULL) {
						GeeArrayList* _tmp17_;
						struct sms* _tmp18_;
						gint _tmp19_ = 0;
						WrapSms* _tmp20_;
						WrapSms* _tmp21_;
						_tmp17_ = self->messagebook;
						_tmp18_ = sms;
						sms = NULL;
						_tmp19_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "id");
						_tmp20_ = wrap_sms_new (_tmp18_, _tmp19_);
						_tmp21_ = _tmp20_;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp17_, _tmp21_);
						_wrap_sms_unref0 (_tmp21_);
					}
					_sms_free0 (sms);
				}
			}
		}
	}
}


gchar* fso_gsm_plus_cmgl_issue (FsoGsmPlusCMGL* self, FsoGsmPlusCMGLMode mode) {
	gchar* result = NULL;
	FsoGsmPlusCMGLMode _tmp0_;
	FsoGsmPlusCMGLMode _tmp1_;
	gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = mode;
	g_assert (_tmp0_ != FSO_GSM_PLUS_CMGL_MODE_INVALID);
	_tmp1_ = mode;
	_tmp2_ = g_strdup_printf ("+CMGL=%d", (gint) _tmp1_);
	result = _tmp2_;
	return result;
}


static void fso_gsm_plus_cmgl_class_init (FsoGsmPlusCMGLClass * klass) {
	fso_gsm_plus_cmgl_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseMulti = fso_gsm_plus_cmgl_real_parseMulti;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cmgl_finalize;
}


static void fso_gsm_plus_cmgl_instance_init (FsoGsmPlusCMGL * self) {
}


static void fso_gsm_plus_cmgl_finalize (GObject* obj) {
	FsoGsmPlusCMGL * self;
	self = FSO_GSM_PLUS_CMGL (obj);
	_g_object_unref0 (self->messagebook);
	G_OBJECT_CLASS (fso_gsm_plus_cmgl_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cmgl_get_type (void) {
	static volatile gsize fso_gsm_plus_cmgl_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmgl_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMGLClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmgl_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMGL), 0, (GInstanceInitFunc) fso_gsm_plus_cmgl_instance_init, NULL };
		GType fso_gsm_plus_cmgl_type_id;
		fso_gsm_plus_cmgl_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCMGL", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmgl_type_id__volatile, fso_gsm_plus_cmgl_type_id);
	}
	return fso_gsm_plus_cmgl_type_id__volatile;
}


FsoGsmPlusCMGR* fso_gsm_plus_cmgr_construct (GType object_type) {
	FsoGsmPlusCMGR * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGR*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CMGR: (?P<stat>\\d),(?:\"(?P<alpha>[0-9ABCDEF]*)\")?,(?P<tpdulen>\\" \
"d+)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch18_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally18;
	__catch18_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally18:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CMGR: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	((FsoGsmAbstractAtCommand*) self)->length = 2;
	return self;
}


FsoGsmPlusCMGR* fso_gsm_plus_cmgr_new (void) {
	return fso_gsm_plus_cmgr_construct (FSO_GSM_TYPE_PLUS_CMGR);
}


static void fso_gsm_plus_cmgr_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error) {
	FsoGsmPlusCMGR * self;
	gchar** _tmp0_;
	gint _tmp0__length1;
	const gchar* _tmp1_;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gchar** _tmp4_;
	gint _tmp4__length1;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGR*) base;
	_tmp0_ = response;
	_tmp0__length1 = response_length1;
	_tmp1_ = _tmp0_[0];
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cmgr_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp1_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "stat");
	self->status = (FsoGsmPlusCMGLMode) _tmp2_;
	_tmp3_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "tpdulen");
	self->tpdulen = _tmp3_;
	_tmp4_ = response;
	_tmp4__length1 = response_length1;
	_tmp5_ = _tmp4_[1];
	_tmp6_ = g_strdup (_tmp5_);
	_g_free0 (self->hexpdu);
	self->hexpdu = _tmp6_;
}


gchar* fso_gsm_plus_cmgr_issue (FsoGsmPlusCMGR* self, guint index) {
	gchar* result = NULL;
	guint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = index;
	_tmp1_ = g_strdup_printf ("%u", _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("+CMGR=", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


static void fso_gsm_plus_cmgr_class_init (FsoGsmPlusCMGRClass * klass) {
	fso_gsm_plus_cmgr_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseMulti = fso_gsm_plus_cmgr_real_parseMulti;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cmgr_finalize;
}


static void fso_gsm_plus_cmgr_instance_init (FsoGsmPlusCMGR * self) {
}


static void fso_gsm_plus_cmgr_finalize (GObject* obj) {
	FsoGsmPlusCMGR * self;
	self = FSO_GSM_PLUS_CMGR (obj);
	_g_free0 (self->hexpdu);
	G_OBJECT_CLASS (fso_gsm_plus_cmgr_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cmgr_get_type (void) {
	static volatile gsize fso_gsm_plus_cmgr_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmgr_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMGRClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmgr_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMGR), 0, (GInstanceInitFunc) fso_gsm_plus_cmgr_instance_init, NULL };
		GType fso_gsm_plus_cmgr_type_id;
		fso_gsm_plus_cmgr_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCMGR", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmgr_type_id__volatile, fso_gsm_plus_cmgr_type_id);
	}
	return fso_gsm_plus_cmgr_type_id__volatile;
}


FsoGsmPlusCMGS* fso_gsm_plus_cmgs_construct (GType object_type) {
	FsoGsmPlusCMGS * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGS*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CMGS: (?P<id>\\d+)(?:,\"(?P<name>[0-9ABCDEF]*)\")?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch19_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally19;
	__catch19_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally19:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CMGS: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCMGS* fso_gsm_plus_cmgs_new (void) {
	return fso_gsm_plus_cmgs_construct (FSO_GSM_TYPE_PLUS_CMGS);
}


static void fso_gsm_plus_cmgs_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCMGS * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGS*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cmgs_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "id");
	self->refnum = _tmp1_;
}


gchar* fso_gsm_plus_cmgs_issue (FsoGsmPlusCMGS* self, WrapHexPdu* pdu) {
	gchar* result = NULL;
	WrapHexPdu* _tmp0_;
	guint _tmp1_;
	WrapHexPdu* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (pdu != NULL, NULL);
	_tmp0_ = pdu;
	_tmp1_ = _tmp0_->tpdulen;
	_tmp2_ = pdu;
	_tmp3_ = _tmp2_->hexpdu;
	_tmp4_ = g_strdup_printf ("AT+CMGS=%u\r\n%s%c", _tmp1_, _tmp3_, (gint) '\x1A');
	result = _tmp4_;
	return result;
}


static gchar* fso_gsm_plus_cmgs_real_get_prefix (FsoGsmAbstractAtCommand* base) {
	FsoGsmPlusCMGS * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (FsoGsmPlusCMGS*) base;
	_tmp0_ = g_strdup ("");
	result = _tmp0_;
	return result;
}


static gchar* fso_gsm_plus_cmgs_real_get_postfix (FsoGsmAbstractAtCommand* base) {
	FsoGsmPlusCMGS * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (FsoGsmPlusCMGS*) base;
	_tmp0_ = g_strdup ("");
	result = _tmp0_;
	return result;
}


static guint fso_gsm_plus_cmgs_real_get_timeout (FsoGsmAbstractAtCommand* base) {
	FsoGsmPlusCMGS * self;
	guint result = 0U;
	self = (FsoGsmPlusCMGS*) base;
	result = FSO_GSM_NETWORK_COMM_TIMEOUT;
	return result;
}


static void fso_gsm_plus_cmgs_class_init (FsoGsmPlusCMGSClass * klass) {
	fso_gsm_plus_cmgs_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cmgs_real_parse;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->get_prefix = fso_gsm_plus_cmgs_real_get_prefix;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->get_postfix = fso_gsm_plus_cmgs_real_get_postfix;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->get_timeout = fso_gsm_plus_cmgs_real_get_timeout;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cmgs_finalize;
}


static void fso_gsm_plus_cmgs_instance_init (FsoGsmPlusCMGS * self) {
}


static void fso_gsm_plus_cmgs_finalize (GObject* obj) {
	FsoGsmPlusCMGS * self;
	self = FSO_GSM_PLUS_CMGS (obj);
	G_OBJECT_CLASS (fso_gsm_plus_cmgs_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cmgs_get_type (void) {
	static volatile gsize fso_gsm_plus_cmgs_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmgs_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMGSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmgs_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMGS), 0, (GInstanceInitFunc) fso_gsm_plus_cmgs_instance_init, NULL };
		GType fso_gsm_plus_cmgs_type_id;
		fso_gsm_plus_cmgs_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCMGS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmgs_type_id__volatile, fso_gsm_plus_cmgs_type_id);
	}
	return fso_gsm_plus_cmgs_type_id__volatile;
}


FsoGsmPlusCMGW* fso_gsm_plus_cmgw_construct (GType object_type) {
	FsoGsmPlusCMGW * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGW*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CMGW: (?P<id>\\d+)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch20_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally20;
	__catch20_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally20:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CMGW: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCMGW* fso_gsm_plus_cmgw_new (void) {
	return fso_gsm_plus_cmgw_construct (FSO_GSM_TYPE_PLUS_CMGW);
}


gchar* fso_gsm_plus_cmgw_issue (FsoGsmPlusCMGW* self, WrapHexPdu* pdu) {
	gchar* result = NULL;
	WrapHexPdu* _tmp0_;
	guint _tmp1_;
	WrapHexPdu* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (pdu != NULL, NULL);
	_tmp0_ = pdu;
	_tmp1_ = _tmp0_->tpdulen;
	_tmp2_ = pdu;
	_tmp3_ = _tmp2_->hexpdu;
	_tmp4_ = g_strdup_printf ("AT+CMGW=%u\r\n%s%c", _tmp1_, _tmp3_, (gint) '\x1A');
	result = _tmp4_;
	return result;
}


static void fso_gsm_plus_cmgw_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCMGW * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGW*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cmgw_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "id");
	self->memory_index = _tmp1_;
}


static gchar* fso_gsm_plus_cmgw_real_get_prefix (FsoGsmAbstractAtCommand* base) {
	FsoGsmPlusCMGW * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (FsoGsmPlusCMGW*) base;
	_tmp0_ = g_strdup ("");
	result = _tmp0_;
	return result;
}


static gchar* fso_gsm_plus_cmgw_real_get_postfix (FsoGsmAbstractAtCommand* base) {
	FsoGsmPlusCMGW * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (FsoGsmPlusCMGW*) base;
	_tmp0_ = g_strdup ("");
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cmgw_class_init (FsoGsmPlusCMGWClass * klass) {
	fso_gsm_plus_cmgw_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cmgw_real_parse;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->get_prefix = fso_gsm_plus_cmgw_real_get_prefix;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->get_postfix = fso_gsm_plus_cmgw_real_get_postfix;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cmgw_finalize;
}


static void fso_gsm_plus_cmgw_instance_init (FsoGsmPlusCMGW * self) {
}


static void fso_gsm_plus_cmgw_finalize (GObject* obj) {
	FsoGsmPlusCMGW * self;
	self = FSO_GSM_PLUS_CMGW (obj);
	G_OBJECT_CLASS (fso_gsm_plus_cmgw_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cmgw_get_type (void) {
	static volatile gsize fso_gsm_plus_cmgw_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmgw_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMGWClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmgw_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMGW), 0, (GInstanceInitFunc) fso_gsm_plus_cmgw_instance_init, NULL };
		GType fso_gsm_plus_cmgw_type_id;
		fso_gsm_plus_cmgw_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCMGW", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmgw_type_id__volatile, fso_gsm_plus_cmgw_type_id);
	}
	return fso_gsm_plus_cmgw_type_id__volatile;
}


FsoGsmPlusCMICKEY* fso_gsm_plus_cmickey_construct (GType object_type) {
	FsoGsmPlusCMICKEY * self = NULL;
	self = (FsoGsmPlusCMICKEY*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CMICKEY", FALSE);
	return self;
}


FsoGsmPlusCMICKEY* fso_gsm_plus_cmickey_new (void) {
	return fso_gsm_plus_cmickey_construct (FSO_GSM_TYPE_PLUS_CMICKEY);
}


static void fso_gsm_plus_cmickey_class_init (FsoGsmPlusCMICKEYClass * klass) {
	fso_gsm_plus_cmickey_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cmickey_instance_init (FsoGsmPlusCMICKEY * self) {
}


GType fso_gsm_plus_cmickey_get_type (void) {
	static volatile gsize fso_gsm_plus_cmickey_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmickey_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMICKEYClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmickey_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMICKEY), 0, (GInstanceInitFunc) fso_gsm_plus_cmickey_instance_init, NULL };
		GType fso_gsm_plus_cmickey_type_id;
		fso_gsm_plus_cmickey_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCMICKEY", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmickey_type_id__volatile, fso_gsm_plus_cmickey_type_id);
	}
	return fso_gsm_plus_cmickey_type_id__volatile;
}


FsoGsmPlusCMSS* fso_gsm_plus_cmss_construct (GType object_type) {
	FsoGsmPlusCMSS * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMSS*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CMSS: (?P<id>\\d)(?:,\"(?P<name>[0-9ABCDEF]*)\")?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch21_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally21;
	__catch21_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally21:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CMSS: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCMSS* fso_gsm_plus_cmss_new (void) {
	return fso_gsm_plus_cmss_construct (FSO_GSM_TYPE_PLUS_CMSS);
}


static void fso_gsm_plus_cmss_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCMSS * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMSS*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cmss_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "id");
	self->refnum = _tmp1_;
}


gchar* fso_gsm_plus_cmss_issue (FsoGsmPlusCMSS* self, gint index) {
	gchar* result = NULL;
	gint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = index;
	_tmp1_ = g_strdup_printf ("%i", _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("+CMSS=", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


static void fso_gsm_plus_cmss_class_init (FsoGsmPlusCMSSClass * klass) {
	fso_gsm_plus_cmss_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cmss_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cmss_finalize;
}


static void fso_gsm_plus_cmss_instance_init (FsoGsmPlusCMSS * self) {
}


static void fso_gsm_plus_cmss_finalize (GObject* obj) {
	FsoGsmPlusCMSS * self;
	self = FSO_GSM_PLUS_CMSS (obj);
	G_OBJECT_CLASS (fso_gsm_plus_cmss_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cmss_get_type (void) {
	static volatile gsize fso_gsm_plus_cmss_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmss_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMSSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmss_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMSS), 0, (GInstanceInitFunc) fso_gsm_plus_cmss_instance_init, NULL };
		GType fso_gsm_plus_cmss_type_id;
		fso_gsm_plus_cmss_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCMSS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmss_type_id__volatile, fso_gsm_plus_cmss_type_id);
	}
	return fso_gsm_plus_cmss_type_id__volatile;
}


FsoGsmPlusCMT* fso_gsm_plus_cmt_construct (GType object_type) {
	FsoGsmPlusCMT * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMT*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CMT: (?:\"[0-9A-F]*\")?,?(?P<tpdulen>\\d+)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch22_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally22;
	__catch22_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally22:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CMT: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	((FsoGsmAbstractAtCommand*) self)->length = 2;
	return self;
}


FsoGsmPlusCMT* fso_gsm_plus_cmt_new (void) {
	return fso_gsm_plus_cmt_construct (FSO_GSM_TYPE_PLUS_CMT);
}


static void fso_gsm_plus_cmt_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error) {
	FsoGsmPlusCMT * self;
	gchar** _tmp0_;
	gint _tmp0__length1;
	const gchar* _tmp1_;
	gint _tmp2_ = 0;
	gchar** _tmp3_;
	gint _tmp3__length1;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMT*) base;
	_tmp0_ = response;
	_tmp0__length1 = response_length1;
	_tmp1_ = _tmp0_[0];
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cmt_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp1_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "tpdulen");
	self->tpdulen = _tmp2_;
	_tmp3_ = response;
	_tmp3__length1 = response_length1;
	_tmp4_ = _tmp3_[1];
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->hexpdu);
	self->hexpdu = _tmp5_;
}


static void fso_gsm_plus_cmt_class_init (FsoGsmPlusCMTClass * klass) {
	fso_gsm_plus_cmt_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseMulti = fso_gsm_plus_cmt_real_parseMulti;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cmt_finalize;
}


static void fso_gsm_plus_cmt_instance_init (FsoGsmPlusCMT * self) {
}


static void fso_gsm_plus_cmt_finalize (GObject* obj) {
	FsoGsmPlusCMT * self;
	self = FSO_GSM_PLUS_CMT (obj);
	_g_free0 (self->hexpdu);
	G_OBJECT_CLASS (fso_gsm_plus_cmt_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cmt_get_type (void) {
	static volatile gsize fso_gsm_plus_cmt_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmt_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMTClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmt_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMT), 0, (GInstanceInitFunc) fso_gsm_plus_cmt_instance_init, NULL };
		GType fso_gsm_plus_cmt_type_id;
		fso_gsm_plus_cmt_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCMT", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmt_type_id__volatile, fso_gsm_plus_cmt_type_id);
	}
	return fso_gsm_plus_cmt_type_id__volatile;
}


FsoGsmPlusCMTI* fso_gsm_plus_cmti_construct (GType object_type) {
	FsoGsmPlusCMTI * self = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMTI*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CMTI: \"(?P<storage>[^\"]*)\",(?P<id>\\d+)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch23_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally23;
	__catch23_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally23:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


FsoGsmPlusCMTI* fso_gsm_plus_cmti_new (void) {
	return fso_gsm_plus_cmti_construct (FSO_GSM_TYPE_PLUS_CMTI);
}


static void fso_gsm_plus_cmti_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCMTI * self;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMTI*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cmti_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "storage");
	_g_free0 (self->storage);
	self->storage = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "id");
	self->index = _tmp2_;
}


static void fso_gsm_plus_cmti_class_init (FsoGsmPlusCMTIClass * klass) {
	fso_gsm_plus_cmti_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cmti_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cmti_finalize;
}


static void fso_gsm_plus_cmti_instance_init (FsoGsmPlusCMTI * self) {
}


static void fso_gsm_plus_cmti_finalize (GObject* obj) {
	FsoGsmPlusCMTI * self;
	self = FSO_GSM_PLUS_CMTI (obj);
	_g_free0 (self->storage);
	G_OBJECT_CLASS (fso_gsm_plus_cmti_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cmti_get_type (void) {
	static volatile gsize fso_gsm_plus_cmti_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmti_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMTIClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmti_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMTI), 0, (GInstanceInitFunc) fso_gsm_plus_cmti_instance_init, NULL };
		GType fso_gsm_plus_cmti_type_id;
		fso_gsm_plus_cmti_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCMTI", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmti_type_id__volatile, fso_gsm_plus_cmti_type_id);
	}
	return fso_gsm_plus_cmti_type_id__volatile;
}


FsoGsmPlusCMMS* fso_gsm_plus_cmms_construct (GType object_type) {
	FsoGsmPlusCMMS * self = NULL;
	self = (FsoGsmPlusCMMS*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CMMS", FALSE);
	return self;
}


FsoGsmPlusCMMS* fso_gsm_plus_cmms_new (void) {
	return fso_gsm_plus_cmms_construct (FSO_GSM_TYPE_PLUS_CMMS);
}


static void fso_gsm_plus_cmms_class_init (FsoGsmPlusCMMSClass * klass) {
	fso_gsm_plus_cmms_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cmms_instance_init (FsoGsmPlusCMMS * self) {
}


GType fso_gsm_plus_cmms_get_type (void) {
	static volatile gsize fso_gsm_plus_cmms_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmms_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMMSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmms_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMMS), 0, (GInstanceInitFunc) fso_gsm_plus_cmms_instance_init, NULL };
		GType fso_gsm_plus_cmms_type_id;
		fso_gsm_plus_cmms_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCMMS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmms_type_id__volatile, fso_gsm_plus_cmms_type_id);
	}
	return fso_gsm_plus_cmms_type_id__volatile;
}


FsoGsmPlusCMUT* fso_gsm_plus_cmut_construct (GType object_type) {
	FsoGsmPlusCMUT * self = NULL;
	self = (FsoGsmPlusCMUT*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CMUT", FALSE);
	return self;
}


FsoGsmPlusCMUT* fso_gsm_plus_cmut_new (void) {
	return fso_gsm_plus_cmut_construct (FSO_GSM_TYPE_PLUS_CMUT);
}


static void fso_gsm_plus_cmut_class_init (FsoGsmPlusCMUTClass * klass) {
	fso_gsm_plus_cmut_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cmut_instance_init (FsoGsmPlusCMUT * self) {
}


GType fso_gsm_plus_cmut_get_type (void) {
	static volatile gsize fso_gsm_plus_cmut_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmut_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMUTClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmut_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMUT), 0, (GInstanceInitFunc) fso_gsm_plus_cmut_instance_init, NULL };
		GType fso_gsm_plus_cmut_type_id;
		fso_gsm_plus_cmut_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCMUT", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmut_type_id__volatile, fso_gsm_plus_cmut_type_id);
	}
	return fso_gsm_plus_cmut_type_id__volatile;
}


FsoGsmPlusCNMA* fso_gsm_plus_cnma_construct (GType object_type) {
	FsoGsmPlusCNMA * self = NULL;
	self = (FsoGsmPlusCNMA*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CNMA", FALSE);
	return self;
}


FsoGsmPlusCNMA* fso_gsm_plus_cnma_new (void) {
	return fso_gsm_plus_cnma_construct (FSO_GSM_TYPE_PLUS_CNMA);
}


static void fso_gsm_plus_cnma_class_init (FsoGsmPlusCNMAClass * klass) {
	fso_gsm_plus_cnma_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cnma_instance_init (FsoGsmPlusCNMA * self) {
}


GType fso_gsm_plus_cnma_get_type (void) {
	static volatile gsize fso_gsm_plus_cnma_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cnma_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCNMAClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cnma_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCNMA), 0, (GInstanceInitFunc) fso_gsm_plus_cnma_instance_init, NULL };
		GType fso_gsm_plus_cnma_type_id;
		fso_gsm_plus_cnma_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCNMA", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cnma_type_id__volatile, fso_gsm_plus_cnma_type_id);
	}
	return fso_gsm_plus_cnma_type_id__volatile;
}


FsoGsmPlusCNMI* fso_gsm_plus_cnmi_construct (GType object_type) {
	FsoGsmPlusCNMI * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCNMI*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CNMI: (?P<mode>\\d),(?P<mt>\\d),(?P<bm>\\d),(?P<ds>\\d),(?P<bfr>\\d" \
")", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch24_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally24;
	__catch24_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally24:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CNMI: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCNMI* fso_gsm_plus_cnmi_new (void) {
	return fso_gsm_plus_cnmi_construct (FSO_GSM_TYPE_PLUS_CNMI);
}


static void fso_gsm_plus_cnmi_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCNMI * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCNMI*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cnmi_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mode");
	fso_gsm_plus_cnmi_set_mode (self, _tmp1_);
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mt");
	fso_gsm_plus_cnmi_set_mt (self, _tmp2_);
	_tmp3_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "bm");
	fso_gsm_plus_cnmi_set_bm (self, _tmp3_);
	_tmp4_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "ds");
	fso_gsm_plus_cnmi_set_ds (self, _tmp4_);
	_tmp5_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "bfr");
	fso_gsm_plus_cnmi_set_bfr (self, _tmp5_);
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void fso_gsm_plus_cnmi_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCNMI * self;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_;
	gint _tmp3__length1;
	FsoGsmAtResultIter* _tmp4_;
	FsoGsmAtResultIter* _tmp5_;
	FsoGsmAtResultIter* iter;
	GHashTable* _tmp6_;
	GHashTable* _tmp7_;
	FsoGsmAtResultIter* _tmp8_;
	gboolean _tmp9_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCNMI*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	_tmp1_ = g_strdup (_tmp0_);
	_tmp2_ = g_new0 (gchar*, 1 + 1);
	_tmp2_[0] = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp3__length1 = 1;
	_tmp4_ = fso_gsm_at_result_iter_new (_tmp3_, 1);
	_tmp5_ = _tmp4_;
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	iter = _tmp5_;
	_tmp6_ = g_hash_table_new_full (NULL, NULL, NULL, _g_object_unref0_);
	_tmp7_ = _tmp6_;
	fso_gsm_plus_cnmi_set_supported_opts (self, _tmp7_);
	_g_hash_table_unref0 (_tmp7_);
	_tmp8_ = iter;
	_tmp9_ = fso_gsm_at_result_iter_next (_tmp8_, "+CNMI:");
	if (!_tmp9_) {
		GError* _tmp10_;
		_tmp10_ = g_error_new_literal (FSO_GSM_AT_COMMAND_ERROR, FSO_GSM_AT_COMMAND_ERROR_UNABLE_TO_PARSE, "Expected prefix +CNMI");
		_inner_error_ = _tmp10_;
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			_fso_gsm_at_result_iter_unref0 (iter);
			return;
		} else {
			_fso_gsm_at_result_iter_unref0 (iter);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	{
		gint n;
		n = 0;
		{
			gboolean _tmp11_;
			_tmp11_ = TRUE;
			while (TRUE) {
				gboolean _tmp12_;
				gint _tmp14_;
				gint num;
				FsoGsmAtResultIter* _tmp15_;
				gboolean _tmp16_ = FALSE;
				GHashTable* _tmp17_;
				gint _tmp18_;
				GeeArrayList* _tmp19_;
				FsoGsmAtResultIter* _tmp27_;
				gboolean _tmp28_ = FALSE;
				_tmp12_ = _tmp11_;
				if (!_tmp12_) {
					gint _tmp13_;
					_tmp13_ = n;
					n = _tmp13_ + 1;
				}
				_tmp11_ = FALSE;
				_tmp14_ = n;
				if (!(_tmp14_ < 5)) {
					break;
				}
				num = 0;
				_tmp15_ = iter;
				_tmp16_ = fso_gsm_at_result_iter_open_list (_tmp15_);
				if (!_tmp16_) {
					_fso_gsm_at_result_iter_unref0 (iter);
					return;
				}
				_tmp17_ = self->priv->_supported_opts;
				_tmp18_ = n;
				_tmp19_ = gee_array_list_new (G_TYPE_INT, NULL, NULL, NULL);
				g_hash_table_insert (_tmp17_, GINT_TO_POINTER (_tmp18_), _tmp19_);
				while (TRUE) {
					FsoGsmAtResultIter* _tmp20_;
					gint _tmp21_ = 0;
					gboolean _tmp22_ = FALSE;
					GHashTable* _tmp23_;
					gint _tmp24_;
					gconstpointer _tmp25_ = NULL;
					gint _tmp26_;
					_tmp20_ = iter;
					_tmp22_ = fso_gsm_at_result_iter_next_number (_tmp20_, &_tmp21_);
					num = _tmp21_;
					if (!_tmp22_) {
						break;
					}
					_tmp23_ = self->priv->_supported_opts;
					_tmp24_ = n;
					_tmp25_ = g_hash_table_lookup (_tmp23_, GINT_TO_POINTER (_tmp24_));
					_tmp26_ = num;
					gee_abstract_collection_add ((GeeAbstractCollection*) ((GeeArrayList*) _tmp25_), GINT_TO_POINTER (_tmp26_));
				}
				_tmp27_ = iter;
				_tmp28_ = fso_gsm_at_result_iter_close_list (_tmp27_);
				if (!_tmp28_) {
					_fso_gsm_at_result_iter_unref0 (iter);
					return;
				}
			}
		}
	}
	_fso_gsm_at_result_iter_unref0 (iter);
}


gchar* fso_gsm_plus_cnmi_query (FsoGsmPlusCNMI* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CNMI?");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_cnmi_test (FsoGsmPlusCNMI* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CNMI=?");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_cnmi_issue (FsoGsmPlusCNMI* self, gint mode, gint mt, gint bm, gint ds, gint bfr) {
	gchar* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gchar* _tmp5_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = mode;
	_tmp1_ = mt;
	_tmp2_ = bm;
	_tmp3_ = ds;
	_tmp4_ = bfr;
	_tmp5_ = g_strdup_printf ("+CNMI=%d,%d,%d,%d,%d", _tmp0_, _tmp1_, _tmp2_, _tmp3_, _tmp4_);
	result = _tmp5_;
	return result;
}


gint fso_gsm_plus_cnmi_get_mode (FsoGsmPlusCNMI* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_mode;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cnmi_set_mode (FsoGsmPlusCNMI* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_mode = _tmp0_;
	g_object_notify ((GObject *) self, "mode");
}


gint fso_gsm_plus_cnmi_get_mt (FsoGsmPlusCNMI* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_mt;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cnmi_set_mt (FsoGsmPlusCNMI* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_mt = _tmp0_;
	g_object_notify ((GObject *) self, "mt");
}


gint fso_gsm_plus_cnmi_get_bm (FsoGsmPlusCNMI* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_bm;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cnmi_set_bm (FsoGsmPlusCNMI* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_bm = _tmp0_;
	g_object_notify ((GObject *) self, "bm");
}


gint fso_gsm_plus_cnmi_get_ds (FsoGsmPlusCNMI* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_ds;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cnmi_set_ds (FsoGsmPlusCNMI* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_ds = _tmp0_;
	g_object_notify ((GObject *) self, "ds");
}


gint fso_gsm_plus_cnmi_get_bfr (FsoGsmPlusCNMI* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_bfr;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cnmi_set_bfr (FsoGsmPlusCNMI* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_bfr = _tmp0_;
	g_object_notify ((GObject *) self, "bfr");
}


GHashTable* fso_gsm_plus_cnmi_get_supported_opts (FsoGsmPlusCNMI* self) {
	GHashTable* result;
	GHashTable* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_supported_opts;
	result = _tmp0_;
	return result;
}


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


static void fso_gsm_plus_cnmi_set_supported_opts (FsoGsmPlusCNMI* self, GHashTable* value) {
	GHashTable* _tmp0_;
	GHashTable* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_hash_table_ref0 (_tmp0_);
	_g_hash_table_unref0 (self->priv->_supported_opts);
	self->priv->_supported_opts = _tmp1_;
	g_object_notify ((GObject *) self, "supported-opts");
}


static void fso_gsm_plus_cnmi_class_init (FsoGsmPlusCNMIClass * klass) {
	fso_gsm_plus_cnmi_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FsoGsmPlusCNMIPrivate));
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cnmi_real_parse;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseTest = fso_gsm_plus_cnmi_real_parseTest;
	G_OBJECT_CLASS (klass)->get_property = _vala_fso_gsm_plus_cnmi_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_fso_gsm_plus_cnmi_set_property;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cnmi_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CNMI_MODE, g_param_spec_int ("mode", "mode", "mode", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CNMI_MT, g_param_spec_int ("mt", "mt", "mt", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CNMI_BM, g_param_spec_int ("bm", "bm", "bm", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CNMI_DS, g_param_spec_int ("ds", "ds", "ds", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CNMI_BFR, g_param_spec_int ("bfr", "bfr", "bfr", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CNMI_SUPPORTED_OPTS, g_param_spec_boxed ("supported-opts", "supported-opts", "supported-opts", G_TYPE_HASH_TABLE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void fso_gsm_plus_cnmi_instance_init (FsoGsmPlusCNMI * self) {
	self->priv = FSO_GSM_PLUS_CNMI_GET_PRIVATE (self);
}


static void fso_gsm_plus_cnmi_finalize (GObject* obj) {
	FsoGsmPlusCNMI * self;
	self = FSO_GSM_PLUS_CNMI (obj);
	_g_hash_table_unref0 (self->priv->_supported_opts);
	G_OBJECT_CLASS (fso_gsm_plus_cnmi_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cnmi_get_type (void) {
	static volatile gsize fso_gsm_plus_cnmi_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cnmi_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCNMIClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cnmi_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCNMI), 0, (GInstanceInitFunc) fso_gsm_plus_cnmi_instance_init, NULL };
		GType fso_gsm_plus_cnmi_type_id;
		fso_gsm_plus_cnmi_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCNMI", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cnmi_type_id__volatile, fso_gsm_plus_cnmi_type_id);
	}
	return fso_gsm_plus_cnmi_type_id__volatile;
}


static void _vala_fso_gsm_plus_cnmi_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FsoGsmPlusCNMI * self;
	self = FSO_GSM_PLUS_CNMI (object);
	switch (property_id) {
		case FSO_GSM_PLUS_CNMI_MODE:
		g_value_set_int (value, fso_gsm_plus_cnmi_get_mode (self));
		break;
		case FSO_GSM_PLUS_CNMI_MT:
		g_value_set_int (value, fso_gsm_plus_cnmi_get_mt (self));
		break;
		case FSO_GSM_PLUS_CNMI_BM:
		g_value_set_int (value, fso_gsm_plus_cnmi_get_bm (self));
		break;
		case FSO_GSM_PLUS_CNMI_DS:
		g_value_set_int (value, fso_gsm_plus_cnmi_get_ds (self));
		break;
		case FSO_GSM_PLUS_CNMI_BFR:
		g_value_set_int (value, fso_gsm_plus_cnmi_get_bfr (self));
		break;
		case FSO_GSM_PLUS_CNMI_SUPPORTED_OPTS:
		g_value_set_boxed (value, fso_gsm_plus_cnmi_get_supported_opts (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_fso_gsm_plus_cnmi_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FsoGsmPlusCNMI * self;
	self = FSO_GSM_PLUS_CNMI (object);
	switch (property_id) {
		case FSO_GSM_PLUS_CNMI_MODE:
		fso_gsm_plus_cnmi_set_mode (self, g_value_get_int (value));
		break;
		case FSO_GSM_PLUS_CNMI_MT:
		fso_gsm_plus_cnmi_set_mt (self, g_value_get_int (value));
		break;
		case FSO_GSM_PLUS_CNMI_BM:
		fso_gsm_plus_cnmi_set_bm (self, g_value_get_int (value));
		break;
		case FSO_GSM_PLUS_CNMI_DS:
		fso_gsm_plus_cnmi_set_ds (self, g_value_get_int (value));
		break;
		case FSO_GSM_PLUS_CNMI_BFR:
		fso_gsm_plus_cnmi_set_bfr (self, g_value_get_int (value));
		break;
		case FSO_GSM_PLUS_CNMI_SUPPORTED_OPTS:
		fso_gsm_plus_cnmi_set_supported_opts (self, g_value_get_boxed (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


FsoGsmPlusCOPN* fso_gsm_plus_copn_construct (GType object_type) {
	FsoGsmPlusCOPN * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCOPN*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+COPN: \"(?P<mccmnc>[^\"]*)\",\"(?P<name>[^\"]*)\"", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch25_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally25;
	__catch25_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally25:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+COPN: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCOPN* fso_gsm_plus_copn_new (void) {
	return fso_gsm_plus_copn_construct (FSO_GSM_TYPE_PLUS_COPN);
}


static void fso_gsm_plus_copn_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error) {
	FsoGsmPlusCOPN * self;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCOPN*) base;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _g_free0_);
	_g_hash_table_unref0 (self->operators);
	self->operators = _tmp2_;
	_tmp3_ = response;
	_tmp3__length1 = response_length1;
	{
		gchar** line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp3_;
		line_collection_length1 = _tmp3__length1;
		for (line_it = 0; line_it < _tmp3__length1; line_it = line_it + 1) {
			gchar* _tmp4_;
			gchar* line = NULL;
			_tmp4_ = g_strdup (line_collection[line_it]);
			line = _tmp4_;
			{
				const gchar* _tmp5_;
				gchar* _tmp6_ = NULL;
				gchar* mccmnc;
				gchar* _tmp7_ = NULL;
				gchar* _tmp8_;
				gchar* _tmp9_ = NULL;
				gchar* _tmp10_;
				gchar* name;
				const gchar* _tmp11_;
				const gchar* _tmp12_ = NULL;
				const gchar* _tmp13_;
				const gchar* _tmp14_ = NULL;
				gchar* _tmp15_ = NULL;
				gchar* _tmp16_;
				GHashTable* _tmp17_;
				gchar* _tmp18_ = NULL;
				gchar* _tmp19_ = NULL;
				_tmp5_ = line;
				FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_copn_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp5_, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_free0 (line);
						return;
					} else {
						_g_free0 (line);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				_tmp6_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "mccmnc");
				mccmnc = _tmp6_;
				_tmp7_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "name");
				_tmp8_ = _tmp7_;
				_tmp9_ = fso_gsm_at_command_decodeString ((FsoGsmAtCommand*) self, _tmp8_);
				_tmp10_ = _tmp9_;
				_g_free0 (_tmp8_);
				name = _tmp10_;
				_tmp11_ = mccmnc;
				_tmp12_ = string_to_string (_tmp11_);
				_tmp13_ = name;
				_tmp14_ = string_to_string (_tmp13_);
				_tmp15_ = g_strconcat ("adding operator ", _tmp12_, " = ", _tmp14_, NULL);
				_tmp16_ = _tmp15_;
				g_message ("atcommands.vala:952: %s", _tmp16_);
				_g_free0 (_tmp16_);
				_tmp17_ = self->operators;
				_tmp18_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "mccmnc");
				_tmp19_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "name");
				g_hash_table_insert (_tmp17_, _tmp18_, _tmp19_);
				_g_free0 (name);
				_g_free0 (mccmnc);
				_g_free0 (line);
			}
		}
	}
}


gchar* fso_gsm_plus_copn_execute (FsoGsmPlusCOPN* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+COPN");
	result = _tmp0_;
	return result;
}


static guint fso_gsm_plus_copn_real_get_timeout (FsoGsmAbstractAtCommand* base) {
	FsoGsmPlusCOPN * self;
	guint result = 0U;
	self = (FsoGsmPlusCOPN*) base;
	result = FSO_GSM_SIM_COMM_TIMEOUT;
	return result;
}


static void fso_gsm_plus_copn_class_init (FsoGsmPlusCOPNClass * klass) {
	fso_gsm_plus_copn_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseMulti = fso_gsm_plus_copn_real_parseMulti;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->get_timeout = fso_gsm_plus_copn_real_get_timeout;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_copn_finalize;
}


static void fso_gsm_plus_copn_instance_init (FsoGsmPlusCOPN * self) {
}


static void fso_gsm_plus_copn_finalize (GObject* obj) {
	FsoGsmPlusCOPN * self;
	self = FSO_GSM_PLUS_COPN (obj);
	_g_hash_table_unref0 (self->operators);
	G_OBJECT_CLASS (fso_gsm_plus_copn_parent_class)->finalize (obj);
}


GType fso_gsm_plus_copn_get_type (void) {
	static volatile gsize fso_gsm_plus_copn_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_copn_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCOPNClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_copn_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCOPN), 0, (GInstanceInitFunc) fso_gsm_plus_copn_instance_init, NULL };
		GType fso_gsm_plus_copn_type_id;
		fso_gsm_plus_copn_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCOPN", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_copn_type_id__volatile, fso_gsm_plus_copn_type_id);
	}
	return fso_gsm_plus_copn_type_id__volatile;
}


GType fso_gsm_plus_cops_action_get_type (void) {
	static volatile gsize fso_gsm_plus_cops_action_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cops_action_type_id__volatile)) {
		static const GEnumValue values[] = {{FSO_GSM_PLUS_COPS_ACTION_REGISTER_WITH_BEST_PROVIDER, "FSO_GSM_PLUS_COPS_ACTION_REGISTER_WITH_BEST_PROVIDER", "register-with-best-provider"}, {FSO_GSM_PLUS_COPS_ACTION_REGISTER_WITH_SPECIFIC_PROVIDER, "FSO_GSM_PLUS_COPS_ACTION_REGISTER_WITH_SPECIFIC_PROVIDER", "register-with-specific-provider"}, {FSO_GSM_PLUS_COPS_ACTION_UNREGISTER, "FSO_GSM_PLUS_COPS_ACTION_UNREGISTER", "unregister"}, {FSO_GSM_PLUS_COPS_ACTION_SET_FORMAT, "FSO_GSM_PLUS_COPS_ACTION_SET_FORMAT", "set-format"}, {0, NULL, NULL}};
		GType fso_gsm_plus_cops_action_type_id;
		fso_gsm_plus_cops_action_type_id = g_enum_register_static ("FsoGsmPlusCOPSAction", values);
		g_once_init_leave (&fso_gsm_plus_cops_action_type_id__volatile, fso_gsm_plus_cops_action_type_id);
	}
	return fso_gsm_plus_cops_action_type_id__volatile;
}


GType fso_gsm_plus_cops_format_get_type (void) {
	static volatile gsize fso_gsm_plus_cops_format_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cops_format_type_id__volatile)) {
		static const GEnumValue values[] = {{FSO_GSM_PLUS_COPS_FORMAT_ALPHANUMERIC, "FSO_GSM_PLUS_COPS_FORMAT_ALPHANUMERIC", "alphanumeric"}, {FSO_GSM_PLUS_COPS_FORMAT_ALPHANUMERIC_SHORT, "FSO_GSM_PLUS_COPS_FORMAT_ALPHANUMERIC_SHORT", "alphanumeric-short"}, {FSO_GSM_PLUS_COPS_FORMAT_NUMERIC, "FSO_GSM_PLUS_COPS_FORMAT_NUMERIC", "numeric"}, {0, NULL, NULL}};
		GType fso_gsm_plus_cops_format_type_id;
		fso_gsm_plus_cops_format_type_id = g_enum_register_static ("FsoGsmPlusCOPSFormat", values);
		g_once_init_leave (&fso_gsm_plus_cops_format_type_id__volatile, fso_gsm_plus_cops_format_type_id);
	}
	return fso_gsm_plus_cops_format_type_id__volatile;
}


static void _vala_FreeSmartphoneGSMNetworkProvider_array_free (FreeSmartphoneGSMNetworkProvider* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			free_smartphone_gsm_network_provider_destroy (&array[i]);
		}
	}
	g_free (array);
}


FsoGsmPlusCOPS* fso_gsm_plus_cops_construct (GType object_type) {
	FsoGsmPlusCOPS * self = NULL;
	gchar* _tmp4_;
	gchar** _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCOPS*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		GRegex* _tmp2_;
		GRegex* _tmp3_;
		_tmp0_ = g_regex_new ("\\+COPS:\\ (?P<mode>\\d)(,(?P<format>\\d)?(,\"(?P<oper>[^\"]*)\")?)?(?" \
":,(?P<act>\\d))?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch26_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
		_tmp2_ = g_regex_new ("\\((?P<status>\\d),(?:\"(?P<longname>[^\"]*)\")?,(?:\"(?P<shortname>[^" \
"\"]*)\")?,\"(?P<mccmnc>[^\"]*)\"(?:,(?P<act>\\d))?\\)", 0, 0, &_inner_error_);
		_tmp3_ = _tmp2_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch26_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->tere);
		((FsoGsmAbstractAtCommand*) self)->tere = _tmp3_;
	}
	goto __finally26;
	__catch26_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally26:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = g_strdup ("+COPS: ");
	_tmp5_ = g_new0 (gchar*, 1 + 1);
	_tmp5_[0] = _tmp4_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp5_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCOPS* fso_gsm_plus_cops_new (void) {
	return fso_gsm_plus_cops_construct (FSO_GSM_TYPE_PLUS_COPS);
}


static void fso_gsm_plus_cops_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCOPS * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gint _tmp5_;
	gboolean _tmp7_;
	gint _tmp10_ = 0;
	gchar* _tmp11_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCOPS*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cops_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mode");
	self->mode = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "format");
	self->format = _tmp2_;
	_tmp3_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "oper");
	_g_free0 (self->oper);
	self->oper = _tmp3_;
	_tmp5_ = self->format;
	if (_tmp5_ != ((gint) FSO_GSM_PLUS_COPS_FORMAT_NUMERIC)) {
		gboolean _tmp6_;
		_tmp6_ = fso_gsm_plus_cops_providerNameDeliveredInConfiguredCharset;
		_tmp4_ = _tmp6_;
	} else {
		_tmp4_ = FALSE;
	}
	_tmp7_ = _tmp4_;
	if (_tmp7_) {
		const gchar* _tmp8_;
		gchar* _tmp9_ = NULL;
		_tmp8_ = self->oper;
		_tmp9_ = fso_gsm_at_command_decodeString ((FsoGsmAtCommand*) self, _tmp8_);
		_g_free0 (self->oper);
		self->oper = _tmp9_;
	}
	_tmp10_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "act");
	_tmp11_ = fso_gsm_constants_networkProviderActToString (_tmp10_);
	_g_free0 (self->act);
	self->act = _tmp11_;
}


static void _vala_array_add2 (FreeSmartphoneGSMNetworkProvider** array, int* length, int* size, const FreeSmartphoneGSMNetworkProvider* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (FreeSmartphoneGSMNetworkProvider, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static FreeSmartphoneGSMNetworkProvider* _vala_array_dup2 (FreeSmartphoneGSMNetworkProvider* self, int length) {
	FreeSmartphoneGSMNetworkProvider* result;
	int i;
	result = g_new0 (FreeSmartphoneGSMNetworkProvider, length);
	for (i = 0; i < length; i++) {
		FreeSmartphoneGSMNetworkProvider _tmp0_ = {0};
		free_smartphone_gsm_network_provider_copy (&self[i], &_tmp0_);
		result[i] = _tmp0_;
	}
	return result;
}


static void fso_gsm_plus_cops_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCOPS * self;
	const gchar* _tmp0_;
	FreeSmartphoneGSMNetworkProvider* _tmp1_ = NULL;
	FreeSmartphoneGSMNetworkProvider* providers;
	gint providers_length1;
	gint _providers_size_;
	FreeSmartphoneGSMNetworkProvider* _tmp31_;
	gint _tmp31__length1;
	FreeSmartphoneGSMNetworkProvider* _tmp32_;
	gint _tmp32__length1;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCOPS*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cops_parent_class)->parseTest (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = g_new0 (FreeSmartphoneGSMNetworkProvider, 0);
	providers = _tmp1_;
	providers_length1 = 0;
	_providers_size_ = providers_length1;
	{
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_;
				gint _tmp7_ = 0;
				gchar* _tmp8_ = NULL;
				gchar* _tmp9_;
				gchar* _tmp10_ = NULL;
				gchar* _tmp11_;
				gchar* _tmp12_ = NULL;
				gchar* _tmp13_;
				gchar* _tmp14_ = NULL;
				gchar* _tmp15_;
				gint _tmp16_ = 0;
				gchar* _tmp17_ = NULL;
				gchar* _tmp18_;
				FreeSmartphoneGSMNetworkProvider p = {0};
				FreeSmartphoneGSMNetworkProvider* _tmp19_;
				gint _tmp19__length1;
				FreeSmartphoneGSMNetworkProvider _tmp20_;
				FreeSmartphoneGSMNetworkProvider _tmp21_ = {0};
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					GMatchInfo* _tmp4_;
					gboolean _tmp5_ = FALSE;
					gboolean _tmp6_;
					_tmp4_ = ((FsoGsmAbstractAtCommand*) self)->mi;
					_tmp5_ = g_match_info_next (_tmp4_, &_inner_error_);
					_tmp6_ = _tmp5_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == G_REGEX_ERROR) {
							goto __catch27_g_regex_error;
						}
						providers = (_vala_FreeSmartphoneGSMNetworkProvider_array_free (providers, providers_length1), NULL);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					if (!_tmp6_) {
						break;
					}
				}
				_tmp2_ = FALSE;
				_tmp7_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "status");
				_tmp8_ = fso_gsm_constants_networkProviderStatusToString (_tmp7_);
				_tmp9_ = _tmp8_;
				_tmp10_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "shortname");
				_tmp11_ = _tmp10_;
				_tmp12_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "longname");
				_tmp13_ = _tmp12_;
				_tmp14_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "mccmnc");
				_tmp15_ = _tmp14_;
				_tmp16_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "act");
				_tmp17_ = fso_gsm_constants_networkProviderActToString (_tmp16_);
				_tmp18_ = _tmp17_;
				free_smartphone_gsm_network_provider_init (&p, _tmp9_, _tmp11_, _tmp13_, _tmp15_, _tmp18_);
				_g_free0 (_tmp18_);
				_g_free0 (_tmp15_);
				_g_free0 (_tmp13_);
				_g_free0 (_tmp11_);
				_g_free0 (_tmp9_);
				_tmp19_ = providers;
				_tmp19__length1 = providers_length1;
				_tmp20_ = p;
				free_smartphone_gsm_network_provider_copy (&_tmp20_, &_tmp21_);
				_vala_array_add2 (&providers, &providers_length1, &_providers_size_, &_tmp21_);
				free_smartphone_gsm_network_provider_destroy (&p);
			}
		}
	}
	goto __finally27;
	__catch27_g_regex_error:
	{
		GError* e = NULL;
		FsoFrameworkLogger* _tmp22_;
		GError* _tmp23_;
		const gchar* _tmp24_;
		const gchar* _tmp25_ = NULL;
		gchar* _tmp26_ = NULL;
		gchar* _tmp27_;
		GError* _tmp28_;
		const gchar* _tmp29_;
		GError* _tmp30_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp22_ = fso_framework_theLogger;
		_tmp23_ = e;
		_tmp24_ = _tmp23_->message;
		_tmp25_ = string_to_string (_tmp24_);
		_tmp26_ = g_strconcat ("Regex error: ", _tmp25_, NULL);
		_tmp27_ = _tmp26_;
		fso_framework_logger_error (_tmp22_, _tmp27_);
		_g_free0 (_tmp27_);
		_tmp28_ = e;
		_tmp29_ = _tmp28_->message;
		_tmp30_ = g_error_new_literal (FSO_GSM_AT_COMMAND_ERROR, FSO_GSM_AT_COMMAND_ERROR_UNABLE_TO_PARSE, _tmp29_);
		_inner_error_ = _tmp30_;
		_g_error_free0 (e);
		goto __finally27;
	}
	__finally27:
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			providers = (_vala_FreeSmartphoneGSMNetworkProvider_array_free (providers, providers_length1), NULL);
			return;
		} else {
			providers = (_vala_FreeSmartphoneGSMNetworkProvider_array_free (providers, providers_length1), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp31_ = providers;
	_tmp31__length1 = providers_length1;
	_tmp32_ = (_tmp31_ != NULL) ? _vala_array_dup2 (_tmp31_, _tmp31__length1) : ((gpointer) _tmp31_);
	_tmp32__length1 = _tmp31__length1;
	self->providers = (_vala_FreeSmartphoneGSMNetworkProvider_array_free (self->providers, self->providers_length1), NULL);
	self->providers = _tmp32_;
	self->providers_length1 = _tmp32__length1;
	providers = (_vala_FreeSmartphoneGSMNetworkProvider_array_free (providers, providers_length1), NULL);
}


gchar* fso_gsm_plus_cops_issue (FsoGsmPlusCOPS* self, FsoGsmPlusCOPSAction action, FsoGsmPlusCOPSFormat format, gint param) {
	gchar* result = NULL;
	FsoGsmPlusCOPSAction _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = action;
	if (_tmp0_ == FSO_GSM_PLUS_COPS_ACTION_REGISTER_WITH_BEST_PROVIDER) {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("+COPS=0,0");
		result = _tmp1_;
		return result;
	} else {
		FsoGsmPlusCOPSAction _tmp2_;
		FsoGsmPlusCOPSFormat _tmp3_;
		gint _tmp4_;
		gchar* _tmp5_ = NULL;
		_tmp2_ = action;
		_tmp3_ = format;
		_tmp4_ = param;
		_tmp5_ = g_strdup_printf ("+COPS=%d,%d,\"%d\"", (gint) _tmp2_, (gint) _tmp3_, (gint) _tmp4_);
		result = _tmp5_;
		return result;
	}
}


gchar* fso_gsm_plus_cops_query (FsoGsmPlusCOPS* self, FsoGsmPlusCOPSFormat format) {
	gchar* result = NULL;
	FsoGsmPlusCOPSFormat _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = format;
	_tmp1_ = g_strdup_printf ("+COPS=%d,%d;+COPS?", (gint) FSO_GSM_PLUS_COPS_ACTION_SET_FORMAT, (gint) _tmp0_);
	result = _tmp1_;
	return result;
}


gchar* fso_gsm_plus_cops_test (FsoGsmPlusCOPS* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+COPS=?");
	result = _tmp0_;
	return result;
}


static guint fso_gsm_plus_cops_real_get_timeout (FsoGsmAbstractAtCommand* base) {
	FsoGsmPlusCOPS * self;
	guint result = 0U;
	self = (FsoGsmPlusCOPS*) base;
	result = FSO_GSM_NETWORK_COMM_TIMEOUT;
	return result;
}


static void fso_gsm_plus_cops_class_init (FsoGsmPlusCOPSClass * klass) {
	fso_gsm_plus_cops_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cops_real_parse;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseTest = fso_gsm_plus_cops_real_parseTest;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->get_timeout = fso_gsm_plus_cops_real_get_timeout;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cops_finalize;
}


static void fso_gsm_plus_cops_instance_init (FsoGsmPlusCOPS * self) {
}


static void fso_gsm_plus_cops_finalize (GObject* obj) {
	FsoGsmPlusCOPS * self;
	self = FSO_GSM_PLUS_COPS (obj);
	_g_free0 (self->oper);
	_g_free0 (self->act);
	self->providers = (_vala_FreeSmartphoneGSMNetworkProvider_array_free (self->providers, self->providers_length1), NULL);
	G_OBJECT_CLASS (fso_gsm_plus_cops_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cops_get_type (void) {
	static volatile gsize fso_gsm_plus_cops_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cops_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCOPSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cops_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCOPS), 0, (GInstanceInitFunc) fso_gsm_plus_cops_instance_init, NULL };
		GType fso_gsm_plus_cops_type_id;
		fso_gsm_plus_cops_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCOPS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cops_type_id__volatile, fso_gsm_plus_cops_type_id);
	}
	return fso_gsm_plus_cops_type_id__volatile;
}


static void _vala_FreeSmartphoneGSMSIMEntry_array_free (FreeSmartphoneGSMSIMEntry* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			free_smartphone_gsm_sim_entry_destroy (&array[i]);
		}
	}
	g_free (array);
}


FsoGsmPlusCPBR* fso_gsm_plus_cpbr_construct (GType object_type) {
	FsoGsmPlusCPBR * self = NULL;
	gchar* _tmp4_;
	gchar** _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPBR*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		GRegex* _tmp2_;
		GRegex* _tmp3_;
		_tmp0_ = g_regex_new ("\\+CPBR: (?P<id>\\d+),\"(?P<number>[\\+0-9*#w]*)\",(?P<typ>\\d+)(?:,\"" \
"(?P<name>[^\"]*)\")?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch28_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
		_tmp2_ = g_regex_new ("\\+CPBR: \\((?P<min>\\d+)-(?P<max>\\d+)\\),\\d+,\\d+", 0, 0, &_inner_error_);
		_tmp3_ = _tmp2_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch28_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->tere);
		((FsoGsmAbstractAtCommand*) self)->tere = _tmp3_;
	}
	goto __finally28;
	__catch28_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally28:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = g_strdup ("+CPBR: ");
	_tmp5_ = g_new0 (gchar*, 1 + 1);
	_tmp5_[0] = _tmp4_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp5_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCPBR* fso_gsm_plus_cpbr_new (void) {
	return fso_gsm_plus_cpbr_construct (FSO_GSM_TYPE_PLUS_CPBR);
}


static void _vala_array_add3 (FreeSmartphoneGSMSIMEntry** array, int* length, int* size, const FreeSmartphoneGSMSIMEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (FreeSmartphoneGSMSIMEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static FreeSmartphoneGSMSIMEntry* _vala_array_dup3 (FreeSmartphoneGSMSIMEntry* self, int length) {
	FreeSmartphoneGSMSIMEntry* result;
	int i;
	result = g_new0 (FreeSmartphoneGSMSIMEntry, length);
	for (i = 0; i < length; i++) {
		FreeSmartphoneGSMSIMEntry _tmp0_ = {0};
		free_smartphone_gsm_sim_entry_copy (&self[i], &_tmp0_);
		result[i] = _tmp0_;
	}
	return result;
}


static void fso_gsm_plus_cpbr_real_parseMulti (FsoGsmAbstractAtCommand* base, gchar** response, int response_length1, GError** error) {
	FsoGsmPlusCPBR * self;
	FreeSmartphoneGSMSIMEntry* _tmp0_ = NULL;
	FreeSmartphoneGSMSIMEntry* phonebook;
	gint phonebook_length1;
	gint _phonebook_size_;
	gchar** _tmp1_;
	gint _tmp1__length1;
	FreeSmartphoneGSMSIMEntry* _tmp18_;
	gint _tmp18__length1;
	FreeSmartphoneGSMSIMEntry* _tmp19_;
	gint _tmp19__length1;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPBR*) base;
	_tmp0_ = g_new0 (FreeSmartphoneGSMSIMEntry, 0);
	phonebook = _tmp0_;
	phonebook_length1 = 0;
	_phonebook_size_ = phonebook_length1;
	_tmp1_ = response;
	_tmp1__length1 = response_length1;
	{
		gchar** line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp1_;
		line_collection_length1 = _tmp1__length1;
		for (line_it = 0; line_it < _tmp1__length1; line_it = line_it + 1) {
			gchar* _tmp2_;
			gchar* line = NULL;
			_tmp2_ = g_strdup (line_collection[line_it]);
			line = _tmp2_;
			{
				const gchar* _tmp3_;
				gchar* _tmp4_ = NULL;
				gchar* _tmp5_;
				gint _tmp6_ = 0;
				gchar* _tmp7_ = NULL;
				gchar* _tmp8_;
				gchar* number;
				gint _tmp9_ = 0;
				gchar* _tmp10_ = NULL;
				gchar* _tmp11_;
				gchar* _tmp12_ = NULL;
				gchar* _tmp13_;
				const gchar* _tmp14_;
				FreeSmartphoneGSMSIMEntry entry = {0};
				FreeSmartphoneGSMSIMEntry* _tmp15_;
				gint _tmp15__length1;
				FreeSmartphoneGSMSIMEntry _tmp16_;
				FreeSmartphoneGSMSIMEntry _tmp17_ = {0};
				_tmp3_ = line;
				FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cpbr_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp3_, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_free0 (line);
						phonebook = (_vala_FreeSmartphoneGSMSIMEntry_array_free (phonebook, phonebook_length1), NULL);
						return;
					} else {
						_g_free0 (line);
						phonebook = (_vala_FreeSmartphoneGSMSIMEntry_array_free (phonebook, phonebook_length1), NULL);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				_tmp4_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "number");
				_tmp5_ = _tmp4_;
				_tmp6_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "typ");
				_tmp7_ = fso_gsm_constants_phonenumberTupleToString (_tmp5_, _tmp6_);
				_tmp8_ = _tmp7_;
				_g_free0 (_tmp5_);
				number = _tmp8_;
				_tmp9_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "id");
				_tmp10_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "name");
				_tmp11_ = _tmp10_;
				_tmp12_ = fso_gsm_at_command_decodeString ((FsoGsmAtCommand*) self, _tmp11_);
				_tmp13_ = _tmp12_;
				_tmp14_ = number;
				free_smartphone_gsm_sim_entry_init (&entry, _tmp9_, _tmp13_, _tmp14_);
				_g_free0 (_tmp13_);
				_g_free0 (_tmp11_);
				_tmp15_ = phonebook;
				_tmp15__length1 = phonebook_length1;
				_tmp16_ = entry;
				free_smartphone_gsm_sim_entry_copy (&_tmp16_, &_tmp17_);
				_vala_array_add3 (&phonebook, &phonebook_length1, &_phonebook_size_, &_tmp17_);
				free_smartphone_gsm_sim_entry_destroy (&entry);
				_g_free0 (number);
				_g_free0 (line);
			}
		}
	}
	_tmp18_ = phonebook;
	_tmp18__length1 = phonebook_length1;
	_tmp19_ = (_tmp18_ != NULL) ? _vala_array_dup3 (_tmp18_, _tmp18__length1) : ((gpointer) _tmp18_);
	_tmp19__length1 = _tmp18__length1;
	self->phonebook = (_vala_FreeSmartphoneGSMSIMEntry_array_free (self->phonebook, self->phonebook_length1), NULL);
	self->phonebook = _tmp19_;
	self->phonebook_length1 = _tmp19__length1;
	phonebook = (_vala_FreeSmartphoneGSMSIMEntry_array_free (phonebook, phonebook_length1), NULL);
}


static void fso_gsm_plus_cpbr_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCPBR * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPBR*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cpbr_parent_class)->parseTest (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "min");
	self->min = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "max");
	self->max = _tmp2_;
}


gchar* fso_gsm_plus_cpbr_issue (FsoGsmPlusCPBR* self, const gchar* cat, gint first, gint last) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (cat != NULL, NULL);
	_tmp0_ = cat;
	_tmp1_ = first;
	_tmp2_ = last;
	_tmp3_ = g_strdup_printf ("+CPBS=\"%s\";+CPBR=%d,%d", _tmp0_, _tmp1_, _tmp2_);
	result = _tmp3_;
	return result;
}


gchar* fso_gsm_plus_cpbr_test (FsoGsmPlusCPBR* self, const gchar* cat) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (cat != NULL, NULL);
	_tmp0_ = cat;
	_tmp1_ = g_strdup_printf ("+CPBS=\"%s\";+CPBR=?", _tmp0_);
	result = _tmp1_;
	return result;
}


static void fso_gsm_plus_cpbr_class_init (FsoGsmPlusCPBRClass * klass) {
	fso_gsm_plus_cpbr_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseMulti = fso_gsm_plus_cpbr_real_parseMulti;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseTest = fso_gsm_plus_cpbr_real_parseTest;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cpbr_finalize;
}


static void fso_gsm_plus_cpbr_instance_init (FsoGsmPlusCPBR * self) {
}


static void fso_gsm_plus_cpbr_finalize (GObject* obj) {
	FsoGsmPlusCPBR * self;
	self = FSO_GSM_PLUS_CPBR (obj);
	self->phonebook = (_vala_FreeSmartphoneGSMSIMEntry_array_free (self->phonebook, self->phonebook_length1), NULL);
	G_OBJECT_CLASS (fso_gsm_plus_cpbr_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cpbr_get_type (void) {
	static volatile gsize fso_gsm_plus_cpbr_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cpbr_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCPBRClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cpbr_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCPBR), 0, (GInstanceInitFunc) fso_gsm_plus_cpbr_instance_init, NULL };
		GType fso_gsm_plus_cpbr_type_id;
		fso_gsm_plus_cpbr_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCPBR", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cpbr_type_id__volatile, fso_gsm_plus_cpbr_type_id);
	}
	return fso_gsm_plus_cpbr_type_id__volatile;
}


FsoGsmPlusCPBS* fso_gsm_plus_cpbs_construct (GType object_type) {
	FsoGsmPlusCPBS * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPBS*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\\"(?P<book>[A-Z][A-Z])\\\"", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch29_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->tere);
		((FsoGsmAbstractAtCommand*) self)->tere = _tmp1_;
	}
	goto __finally29;
	__catch29_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally29:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CPBS: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCPBS* fso_gsm_plus_cpbs_new (void) {
	return fso_gsm_plus_cpbs_construct (FSO_GSM_TYPE_PLUS_CPBS);
}


static void _vala_array_add4 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gchar** _vala_array_dup4 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static void fso_gsm_plus_cpbs_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCPBS * self;
	const gchar* _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** books;
	gint books_length1;
	gint _books_size_;
	gchar** _tmp18_;
	gint _tmp18__length1;
	gchar** _tmp19_;
	gint _tmp19__length1;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPBS*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cpbs_parent_class)->parseTest (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = g_new0 (gchar*, 0 + 1);
	books = _tmp1_;
	books_length1 = 0;
	_books_size_ = books_length1;
	{
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_;
				gchar** _tmp7_;
				gint _tmp7__length1;
				gchar* _tmp8_ = NULL;
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					GMatchInfo* _tmp4_;
					gboolean _tmp5_ = FALSE;
					gboolean _tmp6_;
					_tmp4_ = ((FsoGsmAbstractAtCommand*) self)->mi;
					_tmp5_ = g_match_info_next (_tmp4_, &_inner_error_);
					_tmp6_ = _tmp5_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == G_REGEX_ERROR) {
							goto __catch30_g_regex_error;
						}
						books = (_vala_array_free (books, books_length1, (GDestroyNotify) g_free), NULL);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					if (!_tmp6_) {
						break;
					}
				}
				_tmp2_ = FALSE;
				_tmp7_ = books;
				_tmp7__length1 = books_length1;
				_tmp8_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "book");
				_vala_array_add4 (&books, &books_length1, &_books_size_, _tmp8_);
			}
		}
	}
	goto __finally30;
	__catch30_g_regex_error:
	{
		GError* e = NULL;
		FsoFrameworkLogger* _tmp9_;
		GError* _tmp10_;
		const gchar* _tmp11_;
		const gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		GError* _tmp15_;
		const gchar* _tmp16_;
		GError* _tmp17_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp9_ = fso_framework_theLogger;
		_tmp10_ = e;
		_tmp11_ = _tmp10_->message;
		_tmp12_ = string_to_string (_tmp11_);
		_tmp13_ = g_strconcat ("Regex error: ", _tmp12_, NULL);
		_tmp14_ = _tmp13_;
		fso_framework_logger_error (_tmp9_, _tmp14_);
		_g_free0 (_tmp14_);
		_tmp15_ = e;
		_tmp16_ = _tmp15_->message;
		_tmp17_ = g_error_new_literal (FSO_GSM_AT_COMMAND_ERROR, FSO_GSM_AT_COMMAND_ERROR_UNABLE_TO_PARSE, _tmp16_);
		_inner_error_ = _tmp17_;
		_g_error_free0 (e);
		goto __finally30;
	}
	__finally30:
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			books = (_vala_array_free (books, books_length1, (GDestroyNotify) g_free), NULL);
			return;
		} else {
			books = (_vala_array_free (books, books_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp18_ = books;
	_tmp18__length1 = books_length1;
	_tmp19_ = (_tmp18_ != NULL) ? _vala_array_dup4 (_tmp18_, _tmp18__length1) : ((gpointer) _tmp18_);
	_tmp19__length1 = _tmp18__length1;
	self->phonebooks = (_vala_array_free (self->phonebooks, self->phonebooks_length1, (GDestroyNotify) g_free), NULL);
	self->phonebooks = _tmp19_;
	self->phonebooks_length1 = _tmp19__length1;
	books = (_vala_array_free (books, books_length1, (GDestroyNotify) g_free), NULL);
}


gchar* fso_gsm_plus_cpbs_test (FsoGsmPlusCPBS* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CPBS=?");
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cpbs_class_init (FsoGsmPlusCPBSClass * klass) {
	fso_gsm_plus_cpbs_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseTest = fso_gsm_plus_cpbs_real_parseTest;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cpbs_finalize;
}


static void fso_gsm_plus_cpbs_instance_init (FsoGsmPlusCPBS * self) {
}


static void fso_gsm_plus_cpbs_finalize (GObject* obj) {
	FsoGsmPlusCPBS * self;
	self = FSO_GSM_PLUS_CPBS (obj);
	self->phonebooks = (_vala_array_free (self->phonebooks, self->phonebooks_length1, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (fso_gsm_plus_cpbs_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cpbs_get_type (void) {
	static volatile gsize fso_gsm_plus_cpbs_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cpbs_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCPBSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cpbs_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCPBS), 0, (GInstanceInitFunc) fso_gsm_plus_cpbs_instance_init, NULL };
		GType fso_gsm_plus_cpbs_type_id;
		fso_gsm_plus_cpbs_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCPBS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cpbs_type_id__volatile, fso_gsm_plus_cpbs_type_id);
	}
	return fso_gsm_plus_cpbs_type_id__volatile;
}


FsoGsmPlusCPBW* fso_gsm_plus_cpbw_construct (GType object_type) {
	FsoGsmPlusCPBW * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPBW*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CPBW: \\((?P<min>\\d+)-(?P<max>\\d+)\\),(?P<nlength>\\d*),\\((?P<mi" \
"ntype>\\d+)-(?P<maxtype>\\d+)\\),(?P<tlength>\\d*)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch31_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->tere);
		((FsoGsmAbstractAtCommand*) self)->tere = _tmp1_;
	}
	goto __finally31;
	__catch31_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally31:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CPBW: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCPBW* fso_gsm_plus_cpbw_new (void) {
	return fso_gsm_plus_cpbw_construct (FSO_GSM_TYPE_PLUS_CPBW);
}


static void fso_gsm_plus_cpbw_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCPBW * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPBW*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cpbw_parent_class)->parseTest (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "max");
	self->max = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "nlength");
	self->nlength = _tmp2_;
	_tmp3_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "tlength");
	self->tlength = _tmp3_;
}


gchar* fso_gsm_plus_cpbw_issue (FsoGsmPlusCPBW* self, const gchar* cat, gint location, const gchar* number, const gchar* name) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gchar* cmd;
	const gchar* _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (cat != NULL, NULL);
	g_return_val_if_fail (number != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = cat;
	_tmp1_ = string_to_string (_tmp0_);
	_tmp2_ = location;
	_tmp3_ = g_strdup_printf ("%i", _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat ("+CPBS=\"", _tmp1_, "\";+CPBW=", _tmp4_, NULL);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	cmd = _tmp6_;
	_tmp7_ = number;
	if (g_strcmp0 (_tmp7_, "") != 0) {
		const gchar* _tmp8_;
		const gchar* _tmp9_;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		const gchar* _tmp12_;
		gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_;
		gchar* _tmp17_;
		_tmp8_ = cmd;
		_tmp9_ = number;
		_tmp10_ = fso_gsm_constants_phonenumberStringToTuple (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = name;
		_tmp13_ = fso_gsm_at_command_encodeString ((FsoGsmAtCommand*) self, _tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_strdup_printf (",%s,\"%s\"", _tmp11_, _tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = g_strconcat (_tmp8_, _tmp16_, NULL);
		_g_free0 (cmd);
		cmd = _tmp17_;
		_g_free0 (_tmp16_);
		_g_free0 (_tmp14_);
		_g_free0 (_tmp11_);
	}
	result = cmd;
	return result;
}


gchar* fso_gsm_plus_cpbw_test (FsoGsmPlusCPBW* self, const gchar* cat) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (cat != NULL, NULL);
	_tmp0_ = cat;
	_tmp1_ = string_to_string (_tmp0_);
	_tmp2_ = g_strconcat ("+CPBS=\"", _tmp1_, "\";+CPBW=?", NULL);
	result = _tmp2_;
	return result;
}


static void fso_gsm_plus_cpbw_class_init (FsoGsmPlusCPBWClass * klass) {
	fso_gsm_plus_cpbw_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseTest = fso_gsm_plus_cpbw_real_parseTest;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cpbw_finalize;
}


static void fso_gsm_plus_cpbw_instance_init (FsoGsmPlusCPBW * self) {
}


static void fso_gsm_plus_cpbw_finalize (GObject* obj) {
	FsoGsmPlusCPBW * self;
	self = FSO_GSM_PLUS_CPBW (obj);
	G_OBJECT_CLASS (fso_gsm_plus_cpbw_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cpbw_get_type (void) {
	static volatile gsize fso_gsm_plus_cpbw_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cpbw_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCPBWClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cpbw_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCPBW), 0, (GInstanceInitFunc) fso_gsm_plus_cpbw_instance_init, NULL };
		GType fso_gsm_plus_cpbw_type_id;
		fso_gsm_plus_cpbw_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCPBW", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cpbw_type_id__volatile, fso_gsm_plus_cpbw_type_id);
	}
	return fso_gsm_plus_cpbw_type_id__volatile;
}


FsoGsmPlusCPIN* fso_gsm_plus_cpin_construct (GType object_type) {
	FsoGsmPlusCPIN * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPIN*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CPIN:\\ \"?(?P<status>[^\"]*)\"?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch32_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally32;
	__catch32_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally32:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CPIN: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCPIN* fso_gsm_plus_cpin_new (void) {
	return fso_gsm_plus_cpin_construct (FSO_GSM_TYPE_PLUS_CPIN);
}


static void fso_gsm_plus_cpin_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCPIN * self;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	FreeSmartphoneGSMSIMAuthStatus _tmp3_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPIN*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cpin_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "status");
	_tmp2_ = _tmp1_;
	_tmp3_ = fso_gsm_constants_simAuthStatusToEnum (_tmp2_);
	self->status = _tmp3_;
	_g_free0 (_tmp2_);
}


gchar* fso_gsm_plus_cpin_issue (FsoGsmPlusCPIN* self, const gchar* pin, const gchar* new_pin) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (pin != NULL, NULL);
	_tmp0_ = new_pin;
	if (_tmp0_ == NULL) {
		const gchar* _tmp1_;
		gchar* _tmp2_ = NULL;
		_tmp1_ = pin;
		_tmp2_ = g_strdup_printf ("+CPIN=\"%s\"", _tmp1_);
		result = _tmp2_;
		return result;
	} else {
		const gchar* _tmp3_;
		const gchar* _tmp4_;
		gchar* _tmp5_ = NULL;
		_tmp3_ = pin;
		_tmp4_ = new_pin;
		_tmp5_ = g_strdup_printf ("+CPIN=\"%s\",\"%s\"", _tmp3_, _tmp4_);
		result = _tmp5_;
		return result;
	}
}


gchar* fso_gsm_plus_cpin_query (FsoGsmPlusCPIN* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CPIN?");
	result = _tmp0_;
	return result;
}


static guint fso_gsm_plus_cpin_real_get_timeout (FsoGsmAbstractAtCommand* base) {
	FsoGsmPlusCPIN * self;
	guint result = 0U;
	self = (FsoGsmPlusCPIN*) base;
	result = FSO_GSM_SIM_COMM_TIMEOUT;
	return result;
}


static void fso_gsm_plus_cpin_class_init (FsoGsmPlusCPINClass * klass) {
	fso_gsm_plus_cpin_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cpin_real_parse;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->get_timeout = fso_gsm_plus_cpin_real_get_timeout;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cpin_finalize;
}


static void fso_gsm_plus_cpin_instance_init (FsoGsmPlusCPIN * self) {
}


static void fso_gsm_plus_cpin_finalize (GObject* obj) {
	FsoGsmPlusCPIN * self;
	self = FSO_GSM_PLUS_CPIN (obj);
	G_OBJECT_CLASS (fso_gsm_plus_cpin_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cpin_get_type (void) {
	static volatile gsize fso_gsm_plus_cpin_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cpin_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCPINClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cpin_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCPIN), 0, (GInstanceInitFunc) fso_gsm_plus_cpin_instance_init, NULL };
		GType fso_gsm_plus_cpin_type_id;
		fso_gsm_plus_cpin_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCPIN", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cpin_type_id__volatile, fso_gsm_plus_cpin_type_id);
	}
	return fso_gsm_plus_cpin_type_id__volatile;
}


FsoGsmPlusCPMS* fso_gsm_plus_cpms_construct (GType object_type) {
	FsoGsmPlusCPMS * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPMS*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CPMS: \"(?P<s1>[^\"]*)\",(?P<s1u>\\d*),(?P<s1t>\\d*),\"(?P<s2>[^\"]" \
"*)\",(?P<s2u>\\d*),(?P<s2t>\\d*),\"(?P<s3>[^\"]*)\",(?P<s3u>\\d*),(?P<" \
"s3t>\\d*)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch33_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally33;
	__catch33_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally33:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CPMS: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCPMS* fso_gsm_plus_cpms_new (void) {
	return fso_gsm_plus_cpms_construct (FSO_GSM_TYPE_PLUS_CPMS);
}


static void fso_gsm_plus_cpms_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCPMS * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPMS*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cpms_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "s1u");
	self->used = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "s1t");
	self->total = _tmp2_;
}


gchar* fso_gsm_plus_cpms_query (FsoGsmPlusCPMS* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CPMS?");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_cpms_issue (FsoGsmPlusCPMS* self, const gchar* s1, const gchar* s2, const gchar* s3) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s1 != NULL, NULL);
	g_return_val_if_fail (s2 != NULL, NULL);
	g_return_val_if_fail (s3 != NULL, NULL);
	_tmp0_ = s1;
	_tmp1_ = string_to_string (_tmp0_);
	_tmp2_ = s2;
	_tmp3_ = string_to_string (_tmp2_);
	_tmp4_ = s3;
	_tmp5_ = string_to_string (_tmp4_);
	_tmp6_ = g_strconcat ("+CPMS=\"", _tmp1_, "\",\"", _tmp3_, "\",\"", _tmp5_, "\"", NULL);
	result = _tmp6_;
	return result;
}


static void fso_gsm_plus_cpms_class_init (FsoGsmPlusCPMSClass * klass) {
	fso_gsm_plus_cpms_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cpms_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cpms_finalize;
}


static void fso_gsm_plus_cpms_instance_init (FsoGsmPlusCPMS * self) {
}


static void fso_gsm_plus_cpms_finalize (GObject* obj) {
	FsoGsmPlusCPMS * self;
	self = FSO_GSM_PLUS_CPMS (obj);
	G_OBJECT_CLASS (fso_gsm_plus_cpms_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cpms_get_type (void) {
	static volatile gsize fso_gsm_plus_cpms_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cpms_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCPMSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cpms_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCPMS), 0, (GInstanceInitFunc) fso_gsm_plus_cpms_instance_init, NULL };
		GType fso_gsm_plus_cpms_type_id;
		fso_gsm_plus_cpms_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCPMS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cpms_type_id__volatile, fso_gsm_plus_cpms_type_id);
	}
	return fso_gsm_plus_cpms_type_id__volatile;
}


FsoGsmPlusCPWD* fso_gsm_plus_cpwd_construct (GType object_type) {
	FsoGsmPlusCPWD * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPWD*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CPWD:\\ \"?(?P<pin>[^\"]*)\"?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch34_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally34;
	__catch34_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally34:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CPWD: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCPWD* fso_gsm_plus_cpwd_new (void) {
	return fso_gsm_plus_cpwd_construct (FSO_GSM_TYPE_PLUS_CPWD);
}


static void fso_gsm_plus_cpwd_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCPWD * self;
	const gchar* _tmp0_;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCPWD*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cpwd_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


gchar* fso_gsm_plus_cpwd_issue (FsoGsmPlusCPWD* self, const gchar* facility, const gchar* p1, const gchar* p2) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (facility != NULL, NULL);
	g_return_val_if_fail (p1 != NULL, NULL);
	g_return_val_if_fail (p2 != NULL, NULL);
	_tmp0_ = facility;
	_tmp1_ = string_to_string (_tmp0_);
	_tmp2_ = p1;
	_tmp3_ = string_to_string (_tmp2_);
	_tmp4_ = p2;
	_tmp5_ = string_to_string (_tmp4_);
	_tmp6_ = g_strconcat ("+CPWD=\"", _tmp1_, "\",\"", _tmp3_, "\",\"", _tmp5_, "\"", NULL);
	result = _tmp6_;
	return result;
}


gchar* fso_gsm_plus_cpwd_query (FsoGsmPlusCPWD* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CPWD?");
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cpwd_class_init (FsoGsmPlusCPWDClass * klass) {
	fso_gsm_plus_cpwd_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cpwd_real_parse;
}


static void fso_gsm_plus_cpwd_instance_init (FsoGsmPlusCPWD * self) {
}


GType fso_gsm_plus_cpwd_get_type (void) {
	static volatile gsize fso_gsm_plus_cpwd_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cpwd_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCPWDClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cpwd_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCPWD), 0, (GInstanceInitFunc) fso_gsm_plus_cpwd_instance_init, NULL };
		GType fso_gsm_plus_cpwd_type_id;
		fso_gsm_plus_cpwd_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCPWD", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cpwd_type_id__volatile, fso_gsm_plus_cpwd_type_id);
	}
	return fso_gsm_plus_cpwd_type_id__volatile;
}


GType fso_gsm_plus_creg_mode_get_type (void) {
	static volatile gsize fso_gsm_plus_creg_mode_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_creg_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{FSO_GSM_PLUS_CREG_MODE_DISABLE, "FSO_GSM_PLUS_CREG_MODE_DISABLE", "disable"}, {FSO_GSM_PLUS_CREG_MODE_ENABLE_WITH_NETORK_REGISTRATION, "FSO_GSM_PLUS_CREG_MODE_ENABLE_WITH_NETORK_REGISTRATION", "enable-with-netork-registration"}, {FSO_GSM_PLUS_CREG_MODE_ENABLE_WITH_NETORK_REGISTRATION_AND_LOCATION, "FSO_GSM_PLUS_CREG_MODE_ENABLE_WITH_NETORK_REGISTRATION_AND_LOCATION", "enable-with-netork-registration-and-location"}, {0, NULL, NULL}};
		GType fso_gsm_plus_creg_mode_type_id;
		fso_gsm_plus_creg_mode_type_id = g_enum_register_static ("FsoGsmPlusCREGMode", values);
		g_once_init_leave (&fso_gsm_plus_creg_mode_type_id__volatile, fso_gsm_plus_creg_mode_type_id);
	}
	return fso_gsm_plus_creg_mode_type_id__volatile;
}


FsoGsmPlusCREG* fso_gsm_plus_creg_construct (GType object_type) {
	FsoGsmPlusCREG * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCREG*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CREG: (?P<mode>\\d),(?P<status>\\d)(?:,\"?(?P<lac>[0-9A-F]*)\"?,\"?" \
"(?P<cid>[0-9A-F]*)\"?)?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch35_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally35;
	__catch35_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally35:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CREG: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCREG* fso_gsm_plus_creg_new (void) {
	return fso_gsm_plus_creg_construct (FSO_GSM_TYPE_PLUS_CREG);
}


static void fso_gsm_plus_creg_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCREG * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCREG*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_creg_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mode");
	self->mode = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "status");
	self->status = _tmp2_;
	_tmp3_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "lac");
	_g_free0 (self->lac);
	self->lac = _tmp3_;
	_tmp4_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "cid");
	_g_free0 (self->cid);
	self->cid = _tmp4_;
}


gchar* fso_gsm_plus_creg_query (FsoGsmPlusCREG* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CREG?");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_creg_issue (FsoGsmPlusCREG* self, FsoGsmPlusCREGMode mode) {
	gchar* result = NULL;
	FsoGsmPlusCREGMode _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = mode;
	_tmp1_ = g_strdup_printf ("+CREG=%i", (gint) _tmp0_);
	result = _tmp1_;
	return result;
}


static void fso_gsm_plus_creg_class_init (FsoGsmPlusCREGClass * klass) {
	fso_gsm_plus_creg_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_creg_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_creg_finalize;
}


static void fso_gsm_plus_creg_instance_init (FsoGsmPlusCREG * self) {
}


static void fso_gsm_plus_creg_finalize (GObject* obj) {
	FsoGsmPlusCREG * self;
	self = FSO_GSM_PLUS_CREG (obj);
	_g_free0 (self->lac);
	_g_free0 (self->cid);
	G_OBJECT_CLASS (fso_gsm_plus_creg_parent_class)->finalize (obj);
}


GType fso_gsm_plus_creg_get_type (void) {
	static volatile gsize fso_gsm_plus_creg_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_creg_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCREGClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_creg_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCREG), 0, (GInstanceInitFunc) fso_gsm_plus_creg_instance_init, NULL };
		GType fso_gsm_plus_creg_type_id;
		fso_gsm_plus_creg_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCREG", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_creg_type_id__volatile, fso_gsm_plus_creg_type_id);
	}
	return fso_gsm_plus_creg_type_id__volatile;
}


FsoGsmPlusCRSM* fso_gsm_plus_crsm_construct (GType object_type) {
	FsoGsmPlusCRSM * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCRSM*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CRSM: 144,0,\"?(?P<payload>[0-9A-Z]+)\"?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch36_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally36;
	__catch36_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally36:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CRSM: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCRSM* fso_gsm_plus_crsm_new (void) {
	return fso_gsm_plus_crsm_construct (FSO_GSM_TYPE_PLUS_CRSM);
}


static void fso_gsm_plus_crsm_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCRSM * self;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCRSM*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_crsm_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "payload");
	_g_free0 (self->payload);
	self->payload = _tmp1_;
}


gchar* fso_gsm_plus_crsm_issue (FsoGsmPlusCRSM* self, gint command, gint p1, gint p2, gint offset, gint length) {
	gchar* result = NULL;
	gint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gint _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gint _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gint _tmp9_;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	gint _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = command;
	_tmp1_ = g_strdup_printf ("%i", _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = p1;
	_tmp4_ = g_strdup_printf ("%i", _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = p2;
	_tmp7_ = g_strdup_printf ("%i", _tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = offset;
	_tmp10_ = g_strdup_printf ("%i", _tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = length;
	_tmp13_ = g_strdup_printf ("%i", _tmp12_);
	_tmp14_ = _tmp13_;
	_tmp15_ = g_strconcat ("+CRSM=", _tmp2_, ",", _tmp5_, ",", _tmp8_, ",", _tmp11_, ",", _tmp14_, NULL);
	_tmp16_ = _tmp15_;
	_g_free0 (_tmp14_);
	_g_free0 (_tmp11_);
	_g_free0 (_tmp8_);
	_g_free0 (_tmp5_);
	_g_free0 (_tmp2_);
	result = _tmp16_;
	return result;
}


static void fso_gsm_plus_crsm_class_init (FsoGsmPlusCRSMClass * klass) {
	fso_gsm_plus_crsm_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_crsm_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_crsm_finalize;
}


static void fso_gsm_plus_crsm_instance_init (FsoGsmPlusCRSM * self) {
}


static void fso_gsm_plus_crsm_finalize (GObject* obj) {
	FsoGsmPlusCRSM * self;
	self = FSO_GSM_PLUS_CRSM (obj);
	_g_free0 (self->payload);
	G_OBJECT_CLASS (fso_gsm_plus_crsm_parent_class)->finalize (obj);
}


GType fso_gsm_plus_crsm_get_type (void) {
	static volatile gsize fso_gsm_plus_crsm_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_crsm_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCRSMClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_crsm_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCRSM), 0, (GInstanceInitFunc) fso_gsm_plus_crsm_instance_init, NULL };
		GType fso_gsm_plus_crsm_type_id;
		fso_gsm_plus_crsm_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCRSM", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_crsm_type_id__volatile, fso_gsm_plus_crsm_type_id);
	}
	return fso_gsm_plus_crsm_type_id__volatile;
}


FsoGsmPlusCSCA* fso_gsm_plus_csca_construct (GType object_type) {
	FsoGsmPlusCSCA * self = NULL;
	gchar* _tmp5_;
	gchar** _tmp6_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCSCA*) fso_gsm_abstract_at_command_construct (object_type);
	{
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_;
		GRegex* _tmp2_;
		GRegex* _tmp3_;
		GRegex* _tmp4_;
		_tmp0_ = g_strdup_printf ("\\+CSCA: \"(?P<number>%s*)\",(?P<ntype>\\d+)", FSO_GSM_CONSTANTS_PHONE_DIGITS_RE);
		_tmp1_ = _tmp0_;
		_tmp2_ = g_regex_new (_tmp1_, 0, 0, &_inner_error_);
		_tmp3_ = _tmp2_;
		_g_free0 (_tmp1_);
		_tmp4_ = _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch37_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp4_;
	}
	goto __finally37;
	__catch37_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally37:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp5_ = g_strdup ("+CSCA: ");
	_tmp6_ = g_new0 (gchar*, 1 + 1);
	_tmp6_[0] = _tmp5_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp6_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCSCA* fso_gsm_plus_csca_new (void) {
	return fso_gsm_plus_csca_construct (FSO_GSM_TYPE_PLUS_CSCA);
}


static void fso_gsm_plus_csca_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCSCA * self;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gint _tmp3_ = 0;
	gchar* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCSCA*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_csca_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "number");
	_tmp2_ = _tmp1_;
	_tmp3_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "ntype");
	_tmp4_ = fso_gsm_constants_phonenumberTupleToString (_tmp2_, _tmp3_);
	_g_free0 (self->number);
	self->number = _tmp4_;
	_g_free0 (_tmp2_);
}


gchar* fso_gsm_plus_csca_query (FsoGsmPlusCSCA* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CSCA?");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_csca_issue (FsoGsmPlusCSCA* self, const gchar* number) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (number != NULL, NULL);
	_tmp0_ = number;
	_tmp1_ = fso_gsm_constants_phonenumberStringToTuple (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("+CSCA=", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


static void fso_gsm_plus_csca_class_init (FsoGsmPlusCSCAClass * klass) {
	fso_gsm_plus_csca_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_csca_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_csca_finalize;
}


static void fso_gsm_plus_csca_instance_init (FsoGsmPlusCSCA * self) {
}


static void fso_gsm_plus_csca_finalize (GObject* obj) {
	FsoGsmPlusCSCA * self;
	self = FSO_GSM_PLUS_CSCA (obj);
	_g_free0 (self->number);
	G_OBJECT_CLASS (fso_gsm_plus_csca_parent_class)->finalize (obj);
}


GType fso_gsm_plus_csca_get_type (void) {
	static volatile gsize fso_gsm_plus_csca_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_csca_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCSCAClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_csca_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCSCA), 0, (GInstanceInitFunc) fso_gsm_plus_csca_instance_init, NULL };
		GType fso_gsm_plus_csca_type_id;
		fso_gsm_plus_csca_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCSCA", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_csca_type_id__volatile, fso_gsm_plus_csca_type_id);
	}
	return fso_gsm_plus_csca_type_id__volatile;
}


GType fso_gsm_plus_cscb_mode_get_type (void) {
	static volatile gsize fso_gsm_plus_cscb_mode_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cscb_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{FSO_GSM_PLUS_CSCB_MODE_NONE, "FSO_GSM_PLUS_CSCB_MODE_NONE", "none"}, {FSO_GSM_PLUS_CSCB_MODE_ALL, "FSO_GSM_PLUS_CSCB_MODE_ALL", "all"}, {0, NULL, NULL}};
		GType fso_gsm_plus_cscb_mode_type_id;
		fso_gsm_plus_cscb_mode_type_id = g_enum_register_static ("FsoGsmPlusCSCBMode", values);
		g_once_init_leave (&fso_gsm_plus_cscb_mode_type_id__volatile, fso_gsm_plus_cscb_mode_type_id);
	}
	return fso_gsm_plus_cscb_mode_type_id__volatile;
}


FsoGsmPlusCSCB* fso_gsm_plus_cscb_construct (GType object_type) {
	FsoGsmPlusCSCB * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCSCB*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CSCB: +(?P<mode>[01]), *\"(?P<channels>\\d*)\", *\"(?P<encodings>\\" \
"d*)\"", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch38_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally38;
	__catch38_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally38:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CSCB: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCSCB* fso_gsm_plus_cscb_new (void) {
	return fso_gsm_plus_cscb_construct (FSO_GSM_TYPE_PLUS_CSCB);
}


static void fso_gsm_plus_cscb_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCSCB * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCSCB*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cscb_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mode");
	self->mode = _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "channels");
	self->channels = _tmp2_;
	_tmp3_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "encodings");
	self->encodings = _tmp3_;
}


gchar* fso_gsm_plus_cscb_query (FsoGsmPlusCSCB* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CSCB?");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_cscb_issue (FsoGsmPlusCSCB* self, FsoGsmPlusCSCBMode m) {
	gchar* result = NULL;
	gint _tmp0_ = 0;
	FsoGsmPlusCSCBMode _tmp1_;
	gint _tmp2_;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = m;
	if (_tmp1_ == FSO_GSM_PLUS_CSCB_MODE_NONE) {
		_tmp0_ = 0;
	} else {
		_tmp0_ = 1;
	}
	_tmp2_ = _tmp0_;
	_tmp3_ = g_strdup_printf ("+CSCB=%u,\"\",\"\"", (guint) _tmp2_);
	result = _tmp3_;
	return result;
}


static void fso_gsm_plus_cscb_class_init (FsoGsmPlusCSCBClass * klass) {
	fso_gsm_plus_cscb_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cscb_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cscb_finalize;
}


static void fso_gsm_plus_cscb_instance_init (FsoGsmPlusCSCB * self) {
}


static void fso_gsm_plus_cscb_finalize (GObject* obj) {
	FsoGsmPlusCSCB * self;
	self = FSO_GSM_PLUS_CSCB (obj);
	G_OBJECT_CLASS (fso_gsm_plus_cscb_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cscb_get_type (void) {
	static volatile gsize fso_gsm_plus_cscb_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cscb_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCSCBClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cscb_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCSCB), 0, (GInstanceInitFunc) fso_gsm_plus_cscb_instance_init, NULL };
		GType fso_gsm_plus_cscb_type_id;
		fso_gsm_plus_cscb_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCSCB", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cscb_type_id__volatile, fso_gsm_plus_cscb_type_id);
	}
	return fso_gsm_plus_cscb_type_id__volatile;
}


FsoGsmPlusCSCS* fso_gsm_plus_cscs_construct (GType object_type) {
	FsoGsmPlusCSCS * self = NULL;
	self = (FsoGsmPlusCSCS*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "+CSCS", FALSE);
	return self;
}


FsoGsmPlusCSCS* fso_gsm_plus_cscs_new (void) {
	return fso_gsm_plus_cscs_construct (FSO_GSM_TYPE_PLUS_CSCS);
}


static void fso_gsm_plus_cscs_class_init (FsoGsmPlusCSCSClass * klass) {
	fso_gsm_plus_cscs_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cscs_instance_init (FsoGsmPlusCSCS * self) {
}


GType fso_gsm_plus_cscs_get_type (void) {
	static volatile gsize fso_gsm_plus_cscs_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cscs_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCSCSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cscs_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCSCS), 0, (GInstanceInitFunc) fso_gsm_plus_cscs_instance_init, NULL };
		GType fso_gsm_plus_cscs_type_id;
		fso_gsm_plus_cscs_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCSCS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cscs_type_id__volatile, fso_gsm_plus_cscs_type_id);
	}
	return fso_gsm_plus_cscs_type_id__volatile;
}


FsoGsmPlusCSQ* fso_gsm_plus_csq_construct (GType object_type) {
	FsoGsmPlusCSQ * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCSQ*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CSQ: (?P<signal>\\d+),(?P<ber>\\d+)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch39_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally39;
	__catch39_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally39:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CSQ: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCSQ* fso_gsm_plus_csq_new (void) {
	return fso_gsm_plus_csq_construct (FSO_GSM_TYPE_PLUS_CSQ);
}


static void fso_gsm_plus_csq_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCSQ * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCSQ*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_csq_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "signal");
	_tmp2_ = fso_gsm_constants_networkSignalToPercentage (_tmp1_);
	self->signal = _tmp2_;
}


gchar* fso_gsm_plus_csq_execute (FsoGsmPlusCSQ* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CSQ");
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_csq_class_init (FsoGsmPlusCSQClass * klass) {
	fso_gsm_plus_csq_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_csq_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_csq_finalize;
}


static void fso_gsm_plus_csq_instance_init (FsoGsmPlusCSQ * self) {
}


static void fso_gsm_plus_csq_finalize (GObject* obj) {
	FsoGsmPlusCSQ * self;
	self = FSO_GSM_PLUS_CSQ (obj);
	G_OBJECT_CLASS (fso_gsm_plus_csq_parent_class)->finalize (obj);
}


GType fso_gsm_plus_csq_get_type (void) {
	static volatile gsize fso_gsm_plus_csq_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_csq_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCSQClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_csq_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCSQ), 0, (GInstanceInitFunc) fso_gsm_plus_csq_instance_init, NULL };
		GType fso_gsm_plus_csq_type_id;
		fso_gsm_plus_csq_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCSQ", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_csq_type_id__volatile, fso_gsm_plus_csq_type_id);
	}
	return fso_gsm_plus_csq_type_id__volatile;
}


FsoGsmPlusCSSI* fso_gsm_plus_cssi_construct (GType object_type) {
	FsoGsmPlusCSSI * self = NULL;
	self = (FsoGsmPlusCSSI*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CSSI", FALSE);
	return self;
}


FsoGsmPlusCSSI* fso_gsm_plus_cssi_new (void) {
	return fso_gsm_plus_cssi_construct (FSO_GSM_TYPE_PLUS_CSSI);
}


static void fso_gsm_plus_cssi_class_init (FsoGsmPlusCSSIClass * klass) {
	fso_gsm_plus_cssi_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cssi_instance_init (FsoGsmPlusCSSI * self) {
}


GType fso_gsm_plus_cssi_get_type (void) {
	static volatile gsize fso_gsm_plus_cssi_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cssi_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCSSIClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cssi_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCSSI), 0, (GInstanceInitFunc) fso_gsm_plus_cssi_instance_init, NULL };
		GType fso_gsm_plus_cssi_type_id;
		fso_gsm_plus_cssi_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCSSI", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cssi_type_id__volatile, fso_gsm_plus_cssi_type_id);
	}
	return fso_gsm_plus_cssi_type_id__volatile;
}


FsoGsmPlusCSSU* fso_gsm_plus_cssu_construct (GType object_type) {
	FsoGsmPlusCSSU * self = NULL;
	self = (FsoGsmPlusCSSU*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_INT, NULL, NULL, "+CSSU", FALSE);
	return self;
}


FsoGsmPlusCSSU* fso_gsm_plus_cssu_new (void) {
	return fso_gsm_plus_cssu_construct (FSO_GSM_TYPE_PLUS_CSSU);
}


static void fso_gsm_plus_cssu_class_init (FsoGsmPlusCSSUClass * klass) {
	fso_gsm_plus_cssu_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_cssu_instance_init (FsoGsmPlusCSSU * self) {
}


GType fso_gsm_plus_cssu_get_type (void) {
	static volatile gsize fso_gsm_plus_cssu_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cssu_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCSSUClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cssu_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCSSU), 0, (GInstanceInitFunc) fso_gsm_plus_cssu_instance_init, NULL };
		GType fso_gsm_plus_cssu_type_id;
		fso_gsm_plus_cssu_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusCSSU", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cssu_type_id__volatile, fso_gsm_plus_cssu_type_id);
	}
	return fso_gsm_plus_cssu_type_id__volatile;
}


GType fso_gsm_plus_cusd_mode_get_type (void) {
	static volatile gsize fso_gsm_plus_cusd_mode_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cusd_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{FSO_GSM_PLUS_CUSD_MODE_COMPLETED, "FSO_GSM_PLUS_CUSD_MODE_COMPLETED", "completed"}, {FSO_GSM_PLUS_CUSD_MODE_USERACTION, "FSO_GSM_PLUS_CUSD_MODE_USERACTION", "useraction"}, {FSO_GSM_PLUS_CUSD_MODE_TERMINATED, "FSO_GSM_PLUS_CUSD_MODE_TERMINATED", "terminated"}, {FSO_GSM_PLUS_CUSD_MODE_LOCALCLIENT, "FSO_GSM_PLUS_CUSD_MODE_LOCALCLIENT", "localclient"}, {FSO_GSM_PLUS_CUSD_MODE_UNSUPPORTED, "FSO_GSM_PLUS_CUSD_MODE_UNSUPPORTED", "unsupported"}, {FSO_GSM_PLUS_CUSD_MODE_TIMEOUT, "FSO_GSM_PLUS_CUSD_MODE_TIMEOUT", "timeout"}, {0, NULL, NULL}};
		GType fso_gsm_plus_cusd_mode_type_id;
		fso_gsm_plus_cusd_mode_type_id = g_enum_register_static ("FsoGsmPlusCUSDMode", values);
		g_once_init_leave (&fso_gsm_plus_cusd_mode_type_id__volatile, fso_gsm_plus_cusd_mode_type_id);
	}
	return fso_gsm_plus_cusd_mode_type_id__volatile;
}


FsoGsmPlusCUSD* fso_gsm_plus_cusd_construct (GType object_type) {
	FsoGsmPlusCUSD * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCUSD*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CUSD: (?P<mode>\\d)(?:,\"(?P<result>[a-zA-Z0-9]*)\"(?:,(?P<code>\\d" \
"+))?)?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch40_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally40;
	__catch40_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally40:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CUSD: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCUSD* fso_gsm_plus_cusd_new (void) {
	return fso_gsm_plus_cusd_construct (FSO_GSM_TYPE_PLUS_CUSD);
}


static void fso_gsm_plus_cusd_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCUSD * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCUSD*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cusd_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mode");
	self->mode = (FsoGsmPlusCUSDMode) _tmp1_;
	_tmp2_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "result");
	_tmp3_ = _tmp2_;
	_tmp4_ = fso_gsm_at_command_decodeString ((FsoGsmAtCommand*) self, _tmp3_);
	_g_free0 (self->result);
	self->result = _tmp4_;
	_g_free0 (_tmp3_);
	_tmp5_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "code");
	self->code = _tmp5_;
}


gchar* fso_gsm_plus_cusd_query (FsoGsmPlusCUSD* self, const gchar* request) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (request != NULL, NULL);
	_tmp0_ = request;
	_tmp1_ = fso_gsm_at_command_encodeString ((FsoGsmAtCommand*) self, _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("+CUSD=1,\"%s\",15", _tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


gchar* fso_gsm_plus_cusd_issue (FsoGsmPlusCUSD* self, gboolean enable) {
	gchar* result = NULL;
	gint _tmp0_ = 0;
	gboolean _tmp1_;
	gint _tmp2_;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = enable;
	if (_tmp1_) {
		_tmp0_ = 1;
	} else {
		_tmp0_ = 0;
	}
	_tmp2_ = _tmp0_;
	_tmp3_ = g_strdup_printf ("+CUSD=%u", (guint) _tmp2_);
	result = _tmp3_;
	return result;
}


static void fso_gsm_plus_cusd_class_init (FsoGsmPlusCUSDClass * klass) {
	fso_gsm_plus_cusd_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cusd_real_parse;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cusd_finalize;
}


static void fso_gsm_plus_cusd_instance_init (FsoGsmPlusCUSD * self) {
}


static void fso_gsm_plus_cusd_finalize (GObject* obj) {
	FsoGsmPlusCUSD * self;
	self = FSO_GSM_PLUS_CUSD (obj);
	_g_free0 (self->result);
	G_OBJECT_CLASS (fso_gsm_plus_cusd_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cusd_get_type (void) {
	static volatile gsize fso_gsm_plus_cusd_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cusd_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCUSDClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cusd_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCUSD), 0, (GInstanceInitFunc) fso_gsm_plus_cusd_instance_init, NULL };
		GType fso_gsm_plus_cusd_type_id;
		fso_gsm_plus_cusd_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCUSD", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cusd_type_id__volatile, fso_gsm_plus_cusd_type_id);
	}
	return fso_gsm_plus_cusd_type_id__volatile;
}


FsoGsmPlusFCLASS* fso_gsm_plus_fclass_construct (GType object_type) {
	FsoGsmPlusFCLASS * self = NULL;
	self = (FsoGsmPlusFCLASS*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "+FCLASS", TRUE);
	return self;
}


FsoGsmPlusFCLASS* fso_gsm_plus_fclass_new (void) {
	return fso_gsm_plus_fclass_construct (FSO_GSM_TYPE_PLUS_FCLASS);
}


static void fso_gsm_plus_fclass_class_init (FsoGsmPlusFCLASSClass * klass) {
	fso_gsm_plus_fclass_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_fclass_instance_init (FsoGsmPlusFCLASS * self) {
}


GType fso_gsm_plus_fclass_get_type (void) {
	static volatile gsize fso_gsm_plus_fclass_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_fclass_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusFCLASSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_fclass_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusFCLASS), 0, (GInstanceInitFunc) fso_gsm_plus_fclass_instance_init, NULL };
		GType fso_gsm_plus_fclass_type_id;
		fso_gsm_plus_fclass_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusFCLASS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_fclass_type_id__volatile, fso_gsm_plus_fclass_type_id);
	}
	return fso_gsm_plus_fclass_type_id__volatile;
}


FsoGsmPlusGCAP* fso_gsm_plus_gcap_construct (GType object_type) {
	FsoGsmPlusGCAP * self = NULL;
	self = (FsoGsmPlusGCAP*) fso_gsm_simple_at_command_construct (object_type, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "+GCAP", TRUE);
	return self;
}


FsoGsmPlusGCAP* fso_gsm_plus_gcap_new (void) {
	return fso_gsm_plus_gcap_construct (FSO_GSM_TYPE_PLUS_GCAP);
}


static void fso_gsm_plus_gcap_class_init (FsoGsmPlusGCAPClass * klass) {
	fso_gsm_plus_gcap_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_gcap_instance_init (FsoGsmPlusGCAP * self) {
}


GType fso_gsm_plus_gcap_get_type (void) {
	static volatile gsize fso_gsm_plus_gcap_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_gcap_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusGCAPClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_gcap_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusGCAP), 0, (GInstanceInitFunc) fso_gsm_plus_gcap_instance_init, NULL };
		GType fso_gsm_plus_gcap_type_id;
		fso_gsm_plus_gcap_type_id = g_type_register_static (FSO_GSM_TYPE_SIMPLE_AT_COMMAND, "FsoGsmPlusGCAP", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_gcap_type_id__volatile, fso_gsm_plus_gcap_type_id);
	}
	return fso_gsm_plus_gcap_type_id__volatile;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


gchar* fso_gsm_plus_vts_issue (FsoGsmPlusVTS* self, const gchar* tones) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar _tmp1_ = '\0';
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* command;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (tones != NULL, NULL);
	_tmp0_ = tones;
	_tmp1_ = string_get (_tmp0_, (glong) 0);
	_tmp2_ = g_strdup_printf ("%c", _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat ("+VTS=", _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	command = _tmp5_;
	{
		gint n;
		n = 1;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				gint _tmp9_;
				const gchar* _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				const gchar* _tmp13_;
				const gchar* _tmp14_;
				gint _tmp15_;
				gchar _tmp16_ = '\0';
				gchar* _tmp17_ = NULL;
				gchar* _tmp18_;
				gchar* _tmp19_ = NULL;
				gchar* _tmp20_;
				gchar* _tmp21_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					gint _tmp8_;
					_tmp8_ = n;
					n = _tmp8_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp9_ = n;
				_tmp10_ = tones;
				_tmp11_ = strlen (_tmp10_);
				_tmp12_ = _tmp11_;
				if (!(_tmp9_ < _tmp12_)) {
					break;
				}
				_tmp13_ = command;
				_tmp14_ = tones;
				_tmp15_ = n;
				_tmp16_ = string_get (_tmp14_, (glong) _tmp15_);
				_tmp17_ = g_strdup_printf ("%c", _tmp16_);
				_tmp18_ = _tmp17_;
				_tmp19_ = g_strconcat (";+VTS=", _tmp18_, NULL);
				_tmp20_ = _tmp19_;
				_tmp21_ = g_strconcat (_tmp13_, _tmp20_, NULL);
				_g_free0 (command);
				command = _tmp21_;
				_g_free0 (_tmp20_);
				_g_free0 (_tmp18_);
			}
		}
	}
	result = command;
	return result;
}


FsoGsmPlusVTS* fso_gsm_plus_vts_construct (GType object_type) {
	FsoGsmPlusVTS * self = NULL;
	self = (FsoGsmPlusVTS*) fso_gsm_abstract_at_command_construct (object_type);
	return self;
}


FsoGsmPlusVTS* fso_gsm_plus_vts_new (void) {
	return fso_gsm_plus_vts_construct (FSO_GSM_TYPE_PLUS_VTS);
}


static void fso_gsm_plus_vts_class_init (FsoGsmPlusVTSClass * klass) {
	fso_gsm_plus_vts_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_vts_instance_init (FsoGsmPlusVTS * self) {
}


GType fso_gsm_plus_vts_get_type (void) {
	static volatile gsize fso_gsm_plus_vts_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_vts_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusVTSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_vts_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusVTS), 0, (GInstanceInitFunc) fso_gsm_plus_vts_instance_init, NULL };
		GType fso_gsm_plus_vts_type_id;
		fso_gsm_plus_vts_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusVTS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_vts_type_id__volatile, fso_gsm_plus_vts_type_id);
	}
	return fso_gsm_plus_vts_type_id__volatile;
}


FsoGsmV250A* fso_gsm_v250_a_construct (GType object_type) {
	FsoGsmV250A * self = NULL;
	self = (FsoGsmV250A*) fso_gsm_v250ter_command_construct (object_type, "A");
	return self;
}


FsoGsmV250A* fso_gsm_v250_a_new (void) {
	return fso_gsm_v250_a_construct (FSO_GSM_TYPE_V250_A);
}


static void fso_gsm_v250_a_class_init (FsoGsmV250AClass * klass) {
	fso_gsm_v250_a_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_v250_a_instance_init (FsoGsmV250A * self) {
}


GType fso_gsm_v250_a_get_type (void) {
	static volatile gsize fso_gsm_v250_a_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_v250_a_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmV250AClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_v250_a_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmV250A), 0, (GInstanceInitFunc) fso_gsm_v250_a_instance_init, NULL };
		GType fso_gsm_v250_a_type_id;
		fso_gsm_v250_a_type_id = g_type_register_static (FSO_GSM_TYPE_V250TER_COMMAND, "FsoGsmV250A", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_v250_a_type_id__volatile, fso_gsm_v250_a_type_id);
	}
	return fso_gsm_v250_a_type_id__volatile;
}


FsoGsmV250D* fso_gsm_v250_d_construct (GType object_type) {
	FsoGsmV250D * self = NULL;
	self = (FsoGsmV250D*) fso_gsm_v250ter_command_construct (object_type, "D");
	return self;
}


FsoGsmV250D* fso_gsm_v250_d_new (void) {
	return fso_gsm_v250_d_construct (FSO_GSM_TYPE_V250_D);
}


gchar* fso_gsm_v250_d_issue (FsoGsmV250D* self, const gchar* number, gboolean voice) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* postfix;
	const gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* safenumber;
	const gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (number != NULL, NULL);
	_tmp1_ = voice;
	if (_tmp1_) {
		_tmp0_ = ";";
	} else {
		_tmp0_ = "";
	}
	_tmp2_ = _tmp0_;
	_tmp3_ = g_strdup (_tmp2_);
	postfix = _tmp3_;
	_tmp4_ = number;
	_tmp5_ = fso_gsm_constants_cleanPhoneNumber (_tmp4_);
	safenumber = _tmp5_;
	_tmp6_ = string_to_string (safenumber);
	_tmp7_ = string_to_string (postfix);
	_tmp8_ = g_strconcat ("D", _tmp6_, _tmp7_, NULL);
	result = _tmp8_;
	_g_free0 (safenumber);
	_g_free0 (postfix);
	return result;
}


static guint fso_gsm_v250_d_real_get_timeout (FsoGsmAbstractAtCommand* base) {
	FsoGsmV250D * self;
	guint result = 0U;
	self = (FsoGsmV250D*) base;
	result = FSO_GSM_VOICE_COMM_TIMEOUT;
	return result;
}


static void fso_gsm_v250_d_class_init (FsoGsmV250DClass * klass) {
	fso_gsm_v250_d_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->get_timeout = fso_gsm_v250_d_real_get_timeout;
}


static void fso_gsm_v250_d_instance_init (FsoGsmV250D * self) {
}


GType fso_gsm_v250_d_get_type (void) {
	static volatile gsize fso_gsm_v250_d_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_v250_d_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmV250DClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_v250_d_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmV250D), 0, (GInstanceInitFunc) fso_gsm_v250_d_instance_init, NULL };
		GType fso_gsm_v250_d_type_id;
		fso_gsm_v250_d_type_id = g_type_register_static (FSO_GSM_TYPE_V250TER_COMMAND, "FsoGsmV250D", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_v250_d_type_id__volatile, fso_gsm_v250_d_type_id);
	}
	return fso_gsm_v250_d_type_id__volatile;
}


FsoGsmV250H* fso_gsm_v250_h_construct (GType object_type) {
	FsoGsmV250H * self = NULL;
	self = (FsoGsmV250H*) fso_gsm_v250ter_command_construct (object_type, "H");
	return self;
}


FsoGsmV250H* fso_gsm_v250_h_new (void) {
	return fso_gsm_v250_h_construct (FSO_GSM_TYPE_V250_H);
}


static void fso_gsm_v250_h_class_init (FsoGsmV250HClass * klass) {
	fso_gsm_v250_h_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_v250_h_instance_init (FsoGsmV250H * self) {
}


GType fso_gsm_v250_h_get_type (void) {
	static volatile gsize fso_gsm_v250_h_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_v250_h_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmV250HClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_v250_h_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmV250H), 0, (GInstanceInitFunc) fso_gsm_v250_h_instance_init, NULL };
		GType fso_gsm_v250_h_type_id;
		fso_gsm_v250_h_type_id = g_type_register_static (FSO_GSM_TYPE_V250TER_COMMAND, "FsoGsmV250H", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_v250_h_type_id__volatile, fso_gsm_v250_h_type_id);
	}
	return fso_gsm_v250_h_type_id__volatile;
}


FsoGsmPlusCCFC* fso_gsm_plus_ccfc_construct (GType object_type) {
	FsoGsmPlusCCFC * self = NULL;
	gchar* _tmp7_;
	gchar** _tmp8_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCCFC*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CCFC: (?P<status>[01]),(?P<class1>\\d)(?:,\"(?P<number>[\\+0-9*#w]+" \
")\",(?P<type>\\d+)(?:,\"(?P<subaddr>[\\+0-9*#w]+)\",(?P<satype>\\d+)(?" \
":,(?P<time>\\d+))?)?)?", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch41_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally41;
	__catch41_g_regex_error:
	{
		GError* e = NULL;
		FILE* _tmp2_;
		const gchar* _tmp3_;
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = stdout;
		_tmp3_ = e->message;
		_tmp4_ = string_to_string (_tmp3_);
		_tmp5_ = g_strconcat ("error: ", _tmp4_, "\n", NULL);
		_tmp6_ = _tmp5_;
		fprintf (_tmp2_, "%s", _tmp6_);
		_g_free0 (_tmp6_);
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally41:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp7_ = g_strdup ("+CCFC: ");
	_tmp8_ = g_new0 (gchar*, 1 + 1);
	_tmp8_[0] = _tmp7_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp8_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCCFC* fso_gsm_plus_ccfc_new (void) {
	return fso_gsm_plus_ccfc_construct (FSO_GSM_TYPE_PLUS_CCFC);
}


static void fso_gsm_plus_ccfc_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCCFC * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gint _tmp5_ = 0;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCCFC*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_ccfc_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "status");
	fso_gsm_plus_ccfc_set_active (self, _tmp1_ == 1);
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "class1");
	fso_gsm_plus_ccfc_set_class1 (self, (FsoGsmConstantsBearerClass) _tmp2_);
	_tmp3_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "number");
	_tmp4_ = _tmp3_;
	fso_gsm_plus_ccfc_set_number (self, _tmp4_);
	_g_free0 (_tmp4_);
	_tmp5_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "type");
	fso_gsm_plus_ccfc_set_number_type (self, _tmp5_);
	_tmp6_ = fso_gsm_abstract_at_command_to_string ((FsoGsmAbstractAtCommand*) self, "subaddr");
	_tmp7_ = _tmp6_;
	fso_gsm_plus_ccfc_set_subaddr (self, _tmp7_);
	_g_free0 (_tmp7_);
	_tmp8_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "satype");
	fso_gsm_plus_ccfc_set_satype (self, _tmp8_);
	_tmp9_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "time");
	fso_gsm_plus_ccfc_set_timeout (self, _tmp9_);
}


gchar* fso_gsm_plus_ccfc_query (FsoGsmPlusCCFC* self, FsoGsmConstantsCallForwardingType type, FsoGsmConstantsBearerClass cls) {
	gchar* result = NULL;
	FsoGsmConstantsBearerClass _tmp0_;
	FsoGsmConstantsCallForwardingType _tmp3_;
	FsoGsmConstantsBearerClass _tmp4_;
	gchar* _tmp5_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = cls;
	if (_tmp0_ == FSO_GSM_CONSTANTS_BEARER_CLASS_DEFAULT) {
		FsoGsmConstantsCallForwardingType _tmp1_;
		gchar* _tmp2_ = NULL;
		_tmp1_ = type;
		_tmp2_ = g_strdup_printf ("+CCFC=%d,2", (gint) _tmp1_);
		result = _tmp2_;
		return result;
	}
	_tmp3_ = type;
	_tmp4_ = cls;
	_tmp5_ = g_strdup_printf ("+CCFC=%d,2,,,%d", (gint) _tmp3_, (gint) _tmp4_);
	result = _tmp5_;
	return result;
}


gchar* fso_gsm_plus_ccfc_issue (FsoGsmPlusCCFC* self, FsoGsmConstantsCallForwardingMode mode, FsoGsmConstantsCallForwardingType type, FsoGsmConstantsBearerClass cls) {
	gchar* result = NULL;
	FsoGsmConstantsCallForwardingType _tmp0_;
	FsoGsmConstantsCallForwardingMode _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* command;
	FsoGsmConstantsBearerClass _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = type;
	_tmp1_ = mode;
	_tmp2_ = g_strdup_printf ("+CCFC=%d,%d", (gint) _tmp0_, (gint) _tmp1_);
	command = _tmp2_;
	_tmp3_ = cls;
	if (_tmp3_ != FSO_GSM_CONSTANTS_BEARER_CLASS_DEFAULT) {
		const gchar* _tmp4_;
		FsoGsmConstantsBearerClass _tmp5_;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		gchar* _tmp8_;
		_tmp4_ = command;
		_tmp5_ = cls;
		_tmp6_ = g_strdup_printf (",,,%d", (gint) _tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strconcat (_tmp4_, _tmp7_, NULL);
		_g_free0 (command);
		command = _tmp8_;
		_g_free0 (_tmp7_);
	}
	result = command;
	return result;
}


gchar* fso_gsm_plus_ccfc_issue_ext (FsoGsmPlusCCFC* self, FsoGsmConstantsCallForwardingMode mode, FsoGsmConstantsCallForwardingType type, FsoGsmConstantsBearerClass cls, const gchar* number, gint time) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	guint8 _tmp1_ = 0U;
	gint number_type;
	FsoGsmConstantsCallForwardingType _tmp2_;
	FsoGsmConstantsCallForwardingMode _tmp3_;
	const gchar* _tmp4_;
	gint _tmp5_;
	FsoGsmConstantsBearerClass _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* command;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	FsoGsmConstantsCallForwardingType _tmp10_;
	gboolean _tmp12_;
	gboolean _tmp14_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (number != NULL, NULL);
	_tmp0_ = number;
	_tmp1_ = fso_gsm_constants_determinePhoneNumberType (_tmp0_);
	number_type = (gint) _tmp1_;
	_tmp2_ = type;
	_tmp3_ = mode;
	_tmp4_ = number;
	_tmp5_ = number_type;
	_tmp6_ = cls;
	_tmp7_ = g_strdup_printf ("+CCFC=%d,%d,\"%s\",%d,%d", (gint) _tmp2_, (gint) _tmp3_, _tmp4_, _tmp5_, (gint) _tmp6_);
	command = _tmp7_;
	_tmp10_ = type;
	if (_tmp10_ == FSO_GSM_CONSTANTS_CALL_FORWARDING_TYPE_NO_REPLY) {
		_tmp9_ = TRUE;
	} else {
		FsoGsmConstantsCallForwardingType _tmp11_;
		_tmp11_ = type;
		_tmp9_ = _tmp11_ == FSO_GSM_CONSTANTS_CALL_FORWARDING_TYPE_ALL;
	}
	_tmp12_ = _tmp9_;
	if (_tmp12_) {
		_tmp8_ = TRUE;
	} else {
		FsoGsmConstantsCallForwardingType _tmp13_;
		_tmp13_ = type;
		_tmp8_ = _tmp13_ == FSO_GSM_CONSTANTS_CALL_FORWARDING_TYPE_ALL_CONDITIONAL;
	}
	_tmp14_ = _tmp8_;
	if (_tmp14_) {
		const gchar* _tmp15_;
		gint _tmp16_;
		gchar* _tmp17_ = NULL;
		gchar* _tmp18_;
		gchar* _tmp19_;
		_tmp15_ = command;
		_tmp16_ = time;
		_tmp17_ = g_strdup_printf (",,,%d", _tmp16_);
		_tmp18_ = _tmp17_;
		_tmp19_ = g_strconcat (_tmp15_, _tmp18_, NULL);
		_g_free0 (command);
		command = _tmp19_;
		_g_free0 (_tmp18_);
	}
	result = command;
	return result;
}


gboolean fso_gsm_plus_ccfc_get_active (FsoGsmPlusCCFC* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_active;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_ccfc_set_active (FsoGsmPlusCCFC* self, gboolean value) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_active = _tmp0_;
	g_object_notify ((GObject *) self, "active");
}


FsoGsmConstantsBearerClass fso_gsm_plus_ccfc_get_class1 (FsoGsmPlusCCFC* self) {
	FsoGsmConstantsBearerClass result;
	FsoGsmConstantsBearerClass _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_class1;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_ccfc_set_class1 (FsoGsmPlusCCFC* self, FsoGsmConstantsBearerClass value) {
	FsoGsmConstantsBearerClass _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_class1 = _tmp0_;
	g_object_notify ((GObject *) self, "class1");
}


const gchar* fso_gsm_plus_ccfc_get_number (FsoGsmPlusCCFC* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_number;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_ccfc_set_number (FsoGsmPlusCCFC* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_number);
	self->priv->_number = _tmp1_;
	g_object_notify ((GObject *) self, "number");
}


gint fso_gsm_plus_ccfc_get_number_type (FsoGsmPlusCCFC* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_number_type;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_ccfc_set_number_type (FsoGsmPlusCCFC* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_number_type = _tmp0_;
	g_object_notify ((GObject *) self, "number-type");
}


const gchar* fso_gsm_plus_ccfc_get_subaddr (FsoGsmPlusCCFC* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_subaddr;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_ccfc_set_subaddr (FsoGsmPlusCCFC* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_subaddr);
	self->priv->_subaddr = _tmp1_;
	g_object_notify ((GObject *) self, "subaddr");
}


gint fso_gsm_plus_ccfc_get_satype (FsoGsmPlusCCFC* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_satype;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_ccfc_set_satype (FsoGsmPlusCCFC* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_satype = _tmp0_;
	g_object_notify ((GObject *) self, "satype");
}


gint fso_gsm_plus_ccfc_get_timeout (FsoGsmPlusCCFC* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_timeout;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_ccfc_set_timeout (FsoGsmPlusCCFC* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_timeout = _tmp0_;
	g_object_notify ((GObject *) self, "timeout");
}


static void fso_gsm_plus_ccfc_class_init (FsoGsmPlusCCFCClass * klass) {
	fso_gsm_plus_ccfc_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FsoGsmPlusCCFCPrivate));
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_ccfc_real_parse;
	G_OBJECT_CLASS (klass)->get_property = _vala_fso_gsm_plus_ccfc_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_fso_gsm_plus_ccfc_set_property;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_ccfc_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CCFC_ACTIVE, g_param_spec_boolean ("active", "active", "active", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CCFC_CLASS1, g_param_spec_enum ("class1", "class1", "class1", FSO_GSM_CONSTANTS_TYPE_BEARER_CLASS, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CCFC_NUMBER, g_param_spec_string ("number", "number", "number", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CCFC_NUMBER_TYPE, g_param_spec_int ("number-type", "number-type", "number-type", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CCFC_SUBADDR, g_param_spec_string ("subaddr", "subaddr", "subaddr", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CCFC_SATYPE, g_param_spec_int ("satype", "satype", "satype", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CCFC_TIMEOUT, g_param_spec_int ("timeout", "timeout", "timeout", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void fso_gsm_plus_ccfc_instance_init (FsoGsmPlusCCFC * self) {
	self->priv = FSO_GSM_PLUS_CCFC_GET_PRIVATE (self);
}


static void fso_gsm_plus_ccfc_finalize (GObject* obj) {
	FsoGsmPlusCCFC * self;
	self = FSO_GSM_PLUS_CCFC (obj);
	_g_free0 (self->priv->_number);
	_g_free0 (self->priv->_subaddr);
	G_OBJECT_CLASS (fso_gsm_plus_ccfc_parent_class)->finalize (obj);
}


GType fso_gsm_plus_ccfc_get_type (void) {
	static volatile gsize fso_gsm_plus_ccfc_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_ccfc_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCCFCClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_ccfc_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCCFC), 0, (GInstanceInitFunc) fso_gsm_plus_ccfc_instance_init, NULL };
		GType fso_gsm_plus_ccfc_type_id;
		fso_gsm_plus_ccfc_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCCFC", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_ccfc_type_id__volatile, fso_gsm_plus_ccfc_type_id);
	}
	return fso_gsm_plus_ccfc_type_id__volatile;
}


static void _vala_fso_gsm_plus_ccfc_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FsoGsmPlusCCFC * self;
	self = FSO_GSM_PLUS_CCFC (object);
	switch (property_id) {
		case FSO_GSM_PLUS_CCFC_ACTIVE:
		g_value_set_boolean (value, fso_gsm_plus_ccfc_get_active (self));
		break;
		case FSO_GSM_PLUS_CCFC_CLASS1:
		g_value_set_enum (value, fso_gsm_plus_ccfc_get_class1 (self));
		break;
		case FSO_GSM_PLUS_CCFC_NUMBER:
		g_value_set_string (value, fso_gsm_plus_ccfc_get_number (self));
		break;
		case FSO_GSM_PLUS_CCFC_NUMBER_TYPE:
		g_value_set_int (value, fso_gsm_plus_ccfc_get_number_type (self));
		break;
		case FSO_GSM_PLUS_CCFC_SUBADDR:
		g_value_set_string (value, fso_gsm_plus_ccfc_get_subaddr (self));
		break;
		case FSO_GSM_PLUS_CCFC_SATYPE:
		g_value_set_int (value, fso_gsm_plus_ccfc_get_satype (self));
		break;
		case FSO_GSM_PLUS_CCFC_TIMEOUT:
		g_value_set_int (value, fso_gsm_plus_ccfc_get_timeout (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_fso_gsm_plus_ccfc_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FsoGsmPlusCCFC * self;
	self = FSO_GSM_PLUS_CCFC (object);
	switch (property_id) {
		case FSO_GSM_PLUS_CCFC_ACTIVE:
		fso_gsm_plus_ccfc_set_active (self, g_value_get_boolean (value));
		break;
		case FSO_GSM_PLUS_CCFC_CLASS1:
		fso_gsm_plus_ccfc_set_class1 (self, g_value_get_enum (value));
		break;
		case FSO_GSM_PLUS_CCFC_NUMBER:
		fso_gsm_plus_ccfc_set_number (self, g_value_get_string (value));
		break;
		case FSO_GSM_PLUS_CCFC_NUMBER_TYPE:
		fso_gsm_plus_ccfc_set_number_type (self, g_value_get_int (value));
		break;
		case FSO_GSM_PLUS_CCFC_SUBADDR:
		fso_gsm_plus_ccfc_set_subaddr (self, g_value_get_string (value));
		break;
		case FSO_GSM_PLUS_CCFC_SATYPE:
		fso_gsm_plus_ccfc_set_satype (self, g_value_get_int (value));
		break;
		case FSO_GSM_PLUS_CCFC_TIMEOUT:
		fso_gsm_plus_ccfc_set_timeout (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


gchar* fso_gsm_plus_ctfr_issue (FsoGsmPlusCTFR* self, const gchar* number, gint number_type) {
	gchar* result = NULL;
	gint _tmp0_;
	const gchar* _tmp4_;
	const gchar* _tmp5_ = NULL;
	gint _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (number != NULL, NULL);
	_tmp0_ = number_type;
	if (_tmp0_ == 0) {
		const gchar* _tmp1_;
		const gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		_tmp1_ = number;
		_tmp2_ = string_to_string (_tmp1_);
		_tmp3_ = g_strconcat ("+CTFR=", _tmp2_, NULL);
		result = _tmp3_;
		return result;
	}
	_tmp4_ = number;
	_tmp5_ = string_to_string (_tmp4_);
	_tmp6_ = number_type;
	_tmp7_ = g_strdup_printf ("%i", _tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strconcat ("+CTFR=", _tmp5_, ",", _tmp8_, NULL);
	_tmp10_ = _tmp9_;
	_g_free0 (_tmp8_);
	result = _tmp10_;
	return result;
}


FsoGsmPlusCTFR* fso_gsm_plus_ctfr_construct (GType object_type) {
	FsoGsmPlusCTFR * self = NULL;
	self = (FsoGsmPlusCTFR*) fso_gsm_abstract_at_command_construct (object_type);
	return self;
}


FsoGsmPlusCTFR* fso_gsm_plus_ctfr_new (void) {
	return fso_gsm_plus_ctfr_construct (FSO_GSM_TYPE_PLUS_CTFR);
}


static void fso_gsm_plus_ctfr_class_init (FsoGsmPlusCTFRClass * klass) {
	fso_gsm_plus_ctfr_parent_class = g_type_class_peek_parent (klass);
}


static void fso_gsm_plus_ctfr_instance_init (FsoGsmPlusCTFR * self) {
}


GType fso_gsm_plus_ctfr_get_type (void) {
	static volatile gsize fso_gsm_plus_ctfr_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_ctfr_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCTFRClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_ctfr_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCTFR), 0, (GInstanceInitFunc) fso_gsm_plus_ctfr_instance_init, NULL };
		GType fso_gsm_plus_ctfr_type_id;
		fso_gsm_plus_ctfr_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCTFR", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_ctfr_type_id__volatile, fso_gsm_plus_ctfr_type_id);
	}
	return fso_gsm_plus_ctfr_type_id__volatile;
}


FsoGsmPlusCSMS* fso_gsm_plus_csms_construct (GType object_type) {
	FsoGsmPlusCSMS * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCSMS*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CSMS: (?P<mt>\\d),(?P<mo>\\d),(?P<bm>\\d)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch42_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally42;
	__catch42_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally42:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CSMS: ");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCSMS* fso_gsm_plus_csms_new (void) {
	return fso_gsm_plus_csms_construct (FSO_GSM_TYPE_PLUS_CSMS);
}


static void fso_gsm_plus_csms_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCSMS * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCSMS*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_csms_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mt");
	fso_gsm_plus_csms_set_mt (self, _tmp1_);
	_tmp2_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mo");
	fso_gsm_plus_csms_set_mo (self, _tmp2_);
	_tmp3_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "bm");
	fso_gsm_plus_csms_set_bm (self, _tmp3_);
}


static void _vala_array_add5 (gint** array, int* length, int* size, gint value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gint, *array, *size);
	}
	(*array)[(*length)++] = value;
}


static void fso_gsm_plus_csms_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCSMS * self;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_;
	gint _tmp3__length1;
	FsoGsmAtResultIter* _tmp4_;
	FsoGsmAtResultIter* _tmp5_;
	FsoGsmAtResultIter* iter;
	gint service;
	gint* _tmp6_ = NULL;
	gint* services;
	gint services_length1;
	gint _services_size_;
	gint* _tmp7_ = NULL;
	gint* _tmp8_;
	gint _tmp8__length1;
	FsoGsmAtResultIter* _tmp9_;
	gboolean _tmp10_ = FALSE;
	FsoGsmAtResultIter* _tmp17_;
	gboolean _tmp18_ = FALSE;
	gint* _tmp30_;
	gint _tmp30__length1;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCSMS*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	_tmp1_ = g_strdup (_tmp0_);
	_tmp2_ = g_new0 (gchar*, 1 + 1);
	_tmp2_[0] = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp3__length1 = 1;
	_tmp4_ = fso_gsm_at_result_iter_new (_tmp3_, 1);
	_tmp5_ = _tmp4_;
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	iter = _tmp5_;
	service = 0;
	_tmp6_ = g_new0 (gint, 0);
	services = _tmp6_;
	services_length1 = 0;
	_services_size_ = services_length1;
	_tmp7_ = g_new0 (gint, 0);
	_tmp8_ = _tmp7_;
	_tmp8__length1 = 0;
	fso_gsm_plus_csms_set_supported_services (self, _tmp8_, 0);
	_tmp8_ = (g_free (_tmp8_), NULL);
	_tmp9_ = iter;
	_tmp10_ = fso_gsm_at_result_iter_next (_tmp9_, "+CSMS:");
	if (!_tmp10_) {
		const gchar* _tmp11_;
		const gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		GError* _tmp15_;
		GError* _tmp16_;
		_tmp11_ = response;
		_tmp12_ = string_to_string (_tmp11_);
		_tmp13_ = g_strconcat ("Can't parse ", _tmp12_, NULL);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_error_new_literal (FSO_GSM_AT_COMMAND_ERROR, FSO_GSM_AT_COMMAND_ERROR_UNABLE_TO_PARSE, _tmp14_);
		_tmp16_ = _tmp15_;
		_g_free0 (_tmp14_);
		_inner_error_ = _tmp16_;
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			services = (g_free (services), NULL);
			_fso_gsm_at_result_iter_unref0 (iter);
			return;
		} else {
			services = (g_free (services), NULL);
			_fso_gsm_at_result_iter_unref0 (iter);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp17_ = iter;
	_tmp18_ = fso_gsm_at_result_iter_open_list (_tmp17_);
	if (!_tmp18_) {
		const gchar* _tmp19_;
		const gchar* _tmp20_ = NULL;
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_;
		GError* _tmp23_;
		GError* _tmp24_;
		_tmp19_ = response;
		_tmp20_ = string_to_string (_tmp19_);
		_tmp21_ = g_strconcat ("Can't parse ", _tmp20_, NULL);
		_tmp22_ = _tmp21_;
		_tmp23_ = g_error_new_literal (FSO_GSM_AT_COMMAND_ERROR, FSO_GSM_AT_COMMAND_ERROR_UNABLE_TO_PARSE, _tmp22_);
		_tmp24_ = _tmp23_;
		_g_free0 (_tmp22_);
		_inner_error_ = _tmp24_;
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			services = (g_free (services), NULL);
			_fso_gsm_at_result_iter_unref0 (iter);
			return;
		} else {
			services = (g_free (services), NULL);
			_fso_gsm_at_result_iter_unref0 (iter);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	while (TRUE) {
		FsoGsmAtResultIter* _tmp25_;
		gint _tmp26_ = 0;
		gboolean _tmp27_ = FALSE;
		gint* _tmp28_;
		gint _tmp28__length1;
		gint _tmp29_;
		_tmp25_ = iter;
		_tmp27_ = fso_gsm_at_result_iter_next_number (_tmp25_, &_tmp26_);
		service = _tmp26_;
		if (!_tmp27_) {
			break;
		}
		_tmp28_ = services;
		_tmp28__length1 = services_length1;
		_tmp29_ = service;
		_vala_array_add5 (&services, &services_length1, &_services_size_, _tmp29_);
	}
	_tmp30_ = services;
	_tmp30__length1 = services_length1;
	fso_gsm_plus_csms_set_supported_services (self, _tmp30_, _tmp30__length1);
	services = (g_free (services), NULL);
	_fso_gsm_at_result_iter_unref0 (iter);
}


gchar* fso_gsm_plus_csms_issue (FsoGsmPlusCSMS* self, gint service) {
	gchar* result = NULL;
	gint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = service;
	_tmp1_ = g_strdup_printf ("%i", _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("+CSMS=", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


gchar* fso_gsm_plus_csms_query (FsoGsmPlusCSMS* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CSMS?");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_csms_test (FsoGsmPlusCSMS* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CSMS=?");
	result = _tmp0_;
	return result;
}


gint fso_gsm_plus_csms_get_mt (FsoGsmPlusCSMS* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_mt;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_csms_set_mt (FsoGsmPlusCSMS* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_mt = _tmp0_;
	g_object_notify ((GObject *) self, "mt");
}


gint fso_gsm_plus_csms_get_mo (FsoGsmPlusCSMS* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_mo;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_csms_set_mo (FsoGsmPlusCSMS* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_mo = _tmp0_;
	g_object_notify ((GObject *) self, "mo");
}


gint fso_gsm_plus_csms_get_bm (FsoGsmPlusCSMS* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_bm;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_csms_set_bm (FsoGsmPlusCSMS* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_bm = _tmp0_;
	g_object_notify ((GObject *) self, "bm");
}


gint* fso_gsm_plus_csms_get_supported_services (FsoGsmPlusCSMS* self, int* result_length1) {
	gint* result;
	gint* _tmp0_;
	gint _tmp0__length1;
	gint* _tmp1_;
	gint _tmp1__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_supported_services;
	_tmp0__length1 = self->priv->_supported_services_length1;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}


static gint* _vala_array_dup5 (gint* self, int length) {
	return g_memdup (self, length * sizeof (gint));
}


static void fso_gsm_plus_csms_set_supported_services (FsoGsmPlusCSMS* self, gint* value, int value_length1) {
	gint* _tmp0_;
	gint _tmp0__length1;
	gint* _tmp1_;
	gint _tmp1__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp0__length1 = value_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup5 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	self->priv->_supported_services = (g_free (self->priv->_supported_services), NULL);
	self->priv->_supported_services = _tmp1_;
	self->priv->_supported_services_length1 = _tmp1__length1;
	self->priv->__supported_services_size_ = self->priv->_supported_services_length1;
}


static void fso_gsm_plus_csms_class_init (FsoGsmPlusCSMSClass * klass) {
	fso_gsm_plus_csms_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FsoGsmPlusCSMSPrivate));
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_csms_real_parse;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseTest = fso_gsm_plus_csms_real_parseTest;
	G_OBJECT_CLASS (klass)->get_property = _vala_fso_gsm_plus_csms_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_fso_gsm_plus_csms_set_property;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_csms_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CSMS_MT, g_param_spec_int ("mt", "mt", "mt", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CSMS_MO, g_param_spec_int ("mo", "mo", "mo", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CSMS_BM, g_param_spec_int ("bm", "bm", "bm", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void fso_gsm_plus_csms_instance_init (FsoGsmPlusCSMS * self) {
	gint* _tmp0_ = NULL;
	self->priv = FSO_GSM_PLUS_CSMS_GET_PRIVATE (self);
	_tmp0_ = g_new0 (gint, 0);
	self->priv->_supported_services = _tmp0_;
	self->priv->_supported_services_length1 = 0;
	self->priv->__supported_services_size_ = self->priv->_supported_services_length1;
}


static void fso_gsm_plus_csms_finalize (GObject* obj) {
	FsoGsmPlusCSMS * self;
	self = FSO_GSM_PLUS_CSMS (obj);
	self->priv->_supported_services = (g_free (self->priv->_supported_services), NULL);
	G_OBJECT_CLASS (fso_gsm_plus_csms_parent_class)->finalize (obj);
}


GType fso_gsm_plus_csms_get_type (void) {
	static volatile gsize fso_gsm_plus_csms_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_csms_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCSMSClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_csms_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCSMS), 0, (GInstanceInitFunc) fso_gsm_plus_csms_instance_init, NULL };
		GType fso_gsm_plus_csms_type_id;
		fso_gsm_plus_csms_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCSMS", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_csms_type_id__volatile, fso_gsm_plus_csms_type_id);
	}
	return fso_gsm_plus_csms_type_id__volatile;
}


static void _vala_fso_gsm_plus_csms_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FsoGsmPlusCSMS * self;
	self = FSO_GSM_PLUS_CSMS (object);
	switch (property_id) {
		case FSO_GSM_PLUS_CSMS_MT:
		g_value_set_int (value, fso_gsm_plus_csms_get_mt (self));
		break;
		case FSO_GSM_PLUS_CSMS_MO:
		g_value_set_int (value, fso_gsm_plus_csms_get_mo (self));
		break;
		case FSO_GSM_PLUS_CSMS_BM:
		g_value_set_int (value, fso_gsm_plus_csms_get_bm (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_fso_gsm_plus_csms_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FsoGsmPlusCSMS * self;
	self = FSO_GSM_PLUS_CSMS (object);
	switch (property_id) {
		case FSO_GSM_PLUS_CSMS_MT:
		fso_gsm_plus_csms_set_mt (self, g_value_get_int (value));
		break;
		case FSO_GSM_PLUS_CSMS_MO:
		fso_gsm_plus_csms_set_mo (self, g_value_get_int (value));
		break;
		case FSO_GSM_PLUS_CSMS_BM:
		fso_gsm_plus_csms_set_bm (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


FsoGsmPlusCMGF* fso_gsm_plus_cmgf_construct (GType object_type) {
	FsoGsmPlusCMGF * self = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGF*) fso_gsm_abstract_at_command_construct (object_type);
	{
		GRegex* _tmp0_;
		GRegex* _tmp1_;
		_tmp0_ = g_regex_new ("\\+CMGF: (?P<mode>\\d)", 0, 0, &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch43_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (((FsoGsmAbstractAtCommand*) self)->re);
		((FsoGsmAbstractAtCommand*) self)->re = _tmp1_;
	}
	goto __finally43;
	__catch43_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally43:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = g_strdup ("+CMGF");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	((FsoGsmAbstractAtCommand*) self)->prefix = (_vala_array_free (((FsoGsmAbstractAtCommand*) self)->prefix, ((FsoGsmAbstractAtCommand*) self)->prefix_length1, (GDestroyNotify) g_free), NULL);
	((FsoGsmAbstractAtCommand*) self)->prefix = _tmp3_;
	((FsoGsmAbstractAtCommand*) self)->prefix_length1 = 1;
	return self;
}


FsoGsmPlusCMGF* fso_gsm_plus_cmgf_new (void) {
	return fso_gsm_plus_cmgf_construct (FSO_GSM_TYPE_PLUS_CMGF);
}


static void fso_gsm_plus_cmgf_real_parse (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCMGF * self;
	const gchar* _tmp0_;
	gint _tmp1_ = 0;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGF*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (fso_gsm_plus_cmgf_parent_class)->parse (FSO_GSM_ABSTRACT_AT_COMMAND (self), _tmp0_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp1_ = fso_gsm_abstract_at_command_to_int ((FsoGsmAbstractAtCommand*) self, "mode");
	fso_gsm_plus_cmgf_set_mode (self, _tmp1_);
}


static void _vala_array_add6 (gint** array, int* length, int* size, gint value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gint, *array, *size);
	}
	(*array)[(*length)++] = value;
}


static void fso_gsm_plus_cmgf_real_parseTest (FsoGsmAbstractAtCommand* base, const gchar* response, GError** error) {
	FsoGsmPlusCMGF * self;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_;
	gint _tmp3__length1;
	FsoGsmAtResultIter* _tmp4_;
	FsoGsmAtResultIter* _tmp5_;
	FsoGsmAtResultIter* iter;
	gint mode;
	gint* _tmp6_ = NULL;
	gint* modes;
	gint modes_length1;
	gint _modes_size_;
	FsoGsmAtResultIter* _tmp7_;
	gboolean _tmp8_ = FALSE;
	FsoGsmAtResultIter* _tmp10_;
	gboolean _tmp11_ = FALSE;
	gint* _tmp17_;
	gint _tmp17__length1;
	GError * _inner_error_ = NULL;
	self = (FsoGsmPlusCMGF*) base;
	g_return_if_fail (response != NULL);
	_tmp0_ = response;
	_tmp1_ = g_strdup (_tmp0_);
	_tmp2_ = g_new0 (gchar*, 1 + 1);
	_tmp2_[0] = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp3__length1 = 1;
	_tmp4_ = fso_gsm_at_result_iter_new (_tmp3_, 1);
	_tmp5_ = _tmp4_;
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	iter = _tmp5_;
	mode = 0;
	_tmp6_ = g_new0 (gint, 0);
	modes = _tmp6_;
	modes_length1 = 0;
	_modes_size_ = modes_length1;
	_tmp7_ = iter;
	_tmp8_ = fso_gsm_at_result_iter_next (_tmp7_, "+CMGF:");
	if (!_tmp8_) {
		GError* _tmp9_;
		_tmp9_ = g_error_new_literal (FSO_GSM_AT_COMMAND_ERROR, FSO_GSM_AT_COMMAND_ERROR_UNABLE_TO_PARSE, "Wrong prefix: expected +CMGF");
		_inner_error_ = _tmp9_;
		if (_inner_error_->domain == FSO_GSM_AT_COMMAND_ERROR) {
			g_propagate_error (error, _inner_error_);
			modes = (g_free (modes), NULL);
			_fso_gsm_at_result_iter_unref0 (iter);
			return;
		} else {
			modes = (g_free (modes), NULL);
			_fso_gsm_at_result_iter_unref0 (iter);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp10_ = iter;
	_tmp11_ = fso_gsm_at_result_iter_open_list (_tmp10_);
	if (!_tmp11_) {
		modes = (g_free (modes), NULL);
		_fso_gsm_at_result_iter_unref0 (iter);
		return;
	}
	while (TRUE) {
		FsoGsmAtResultIter* _tmp12_;
		gint _tmp13_ = 0;
		gboolean _tmp14_ = FALSE;
		gint* _tmp15_;
		gint _tmp15__length1;
		gint _tmp16_;
		_tmp12_ = iter;
		_tmp14_ = fso_gsm_at_result_iter_next_number (_tmp12_, &_tmp13_);
		mode = _tmp13_;
		if (!_tmp14_) {
			break;
		}
		_tmp15_ = modes;
		_tmp15__length1 = modes_length1;
		_tmp16_ = mode;
		_vala_array_add6 (&modes, &modes_length1, &_modes_size_, _tmp16_);
	}
	_tmp17_ = modes;
	_tmp17__length1 = modes_length1;
	fso_gsm_plus_cmgf_set_supported_modes (self, _tmp17_, _tmp17__length1);
	modes = (g_free (modes), NULL);
	_fso_gsm_at_result_iter_unref0 (iter);
}


gchar* fso_gsm_plus_cmgf_issue (FsoGsmPlusCMGF* self, gint mode) {
	gchar* result = NULL;
	gint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = mode;
	_tmp1_ = g_strdup_printf ("%i", _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("+CMGF=", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


gchar* fso_gsm_plus_cmgf_test (FsoGsmPlusCMGF* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CMGF=?");
	result = _tmp0_;
	return result;
}


gchar* fso_gsm_plus_cmgf_query (FsoGsmPlusCMGF* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("+CMGF?");
	result = _tmp0_;
	return result;
}


gint fso_gsm_plus_cmgf_get_mode (FsoGsmPlusCMGF* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_mode;
	result = _tmp0_;
	return result;
}


static void fso_gsm_plus_cmgf_set_mode (FsoGsmPlusCMGF* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_mode = _tmp0_;
	g_object_notify ((GObject *) self, "mode");
}


gint* fso_gsm_plus_cmgf_get_supported_modes (FsoGsmPlusCMGF* self, int* result_length1) {
	gint* result;
	gint* _tmp0_;
	gint _tmp0__length1;
	gint* _tmp1_;
	gint _tmp1__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_supported_modes;
	_tmp0__length1 = self->priv->_supported_modes_length1;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}


static gint* _vala_array_dup6 (gint* self, int length) {
	return g_memdup (self, length * sizeof (gint));
}


static void fso_gsm_plus_cmgf_set_supported_modes (FsoGsmPlusCMGF* self, gint* value, int value_length1) {
	gint* _tmp0_;
	gint _tmp0__length1;
	gint* _tmp1_;
	gint _tmp1__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp0__length1 = value_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup6 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	self->priv->_supported_modes = (g_free (self->priv->_supported_modes), NULL);
	self->priv->_supported_modes = _tmp1_;
	self->priv->_supported_modes_length1 = _tmp1__length1;
	self->priv->__supported_modes_size_ = self->priv->_supported_modes_length1;
}


static void fso_gsm_plus_cmgf_class_init (FsoGsmPlusCMGFClass * klass) {
	fso_gsm_plus_cmgf_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FsoGsmPlusCMGFPrivate));
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parse = fso_gsm_plus_cmgf_real_parse;
	FSO_GSM_ABSTRACT_AT_COMMAND_CLASS (klass)->parseTest = fso_gsm_plus_cmgf_real_parseTest;
	G_OBJECT_CLASS (klass)->get_property = _vala_fso_gsm_plus_cmgf_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_fso_gsm_plus_cmgf_set_property;
	G_OBJECT_CLASS (klass)->finalize = fso_gsm_plus_cmgf_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FSO_GSM_PLUS_CMGF_MODE, g_param_spec_int ("mode", "mode", "mode", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void fso_gsm_plus_cmgf_instance_init (FsoGsmPlusCMGF * self) {
	gint* _tmp0_ = NULL;
	self->priv = FSO_GSM_PLUS_CMGF_GET_PRIVATE (self);
	_tmp0_ = g_new0 (gint, 0);
	self->priv->_supported_modes = _tmp0_;
	self->priv->_supported_modes_length1 = 0;
	self->priv->__supported_modes_size_ = self->priv->_supported_modes_length1;
}


static void fso_gsm_plus_cmgf_finalize (GObject* obj) {
	FsoGsmPlusCMGF * self;
	self = FSO_GSM_PLUS_CMGF (obj);
	self->priv->_supported_modes = (g_free (self->priv->_supported_modes), NULL);
	G_OBJECT_CLASS (fso_gsm_plus_cmgf_parent_class)->finalize (obj);
}


GType fso_gsm_plus_cmgf_get_type (void) {
	static volatile gsize fso_gsm_plus_cmgf_type_id__volatile = 0;
	if (g_once_init_enter (&fso_gsm_plus_cmgf_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FsoGsmPlusCMGFClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_gsm_plus_cmgf_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoGsmPlusCMGF), 0, (GInstanceInitFunc) fso_gsm_plus_cmgf_instance_init, NULL };
		GType fso_gsm_plus_cmgf_type_id;
		fso_gsm_plus_cmgf_type_id = g_type_register_static (FSO_GSM_TYPE_ABSTRACT_AT_COMMAND, "FsoGsmPlusCMGF", &g_define_type_info, 0);
		g_once_init_leave (&fso_gsm_plus_cmgf_type_id__volatile, fso_gsm_plus_cmgf_type_id);
	}
	return fso_gsm_plus_cmgf_type_id__volatile;
}


static void _vala_fso_gsm_plus_cmgf_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FsoGsmPlusCMGF * self;
	self = FSO_GSM_PLUS_CMGF (object);
	switch (property_id) {
		case FSO_GSM_PLUS_CMGF_MODE:
		g_value_set_int (value, fso_gsm_plus_cmgf_get_mode (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_fso_gsm_plus_cmgf_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FsoGsmPlusCMGF * self;
	self = FSO_GSM_PLUS_CMGF (object);
	switch (property_id) {
		case FSO_GSM_PLUS_CMGF_MODE:
		fso_gsm_plus_cmgf_set_mode (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


void fso_gsm_registerGenericAtCommands (GeeHashMap* table) {
	GeeHashMap* _tmp0_;
	FsoGsmPlusCRSM* _tmp1_;
	FsoGsmPlusCRSM* _tmp2_;
	GeeHashMap* _tmp3_;
	FsoGsmPlusCSCS* _tmp4_;
	FsoGsmPlusCSCS* _tmp5_;
	GeeHashMap* _tmp6_;
	FsoGsmPlusCGCLASS* _tmp7_;
	FsoGsmPlusCGCLASS* _tmp8_;
	GeeHashMap* _tmp9_;
	FsoGsmPlusCGMI* _tmp10_;
	FsoGsmPlusCGMI* _tmp11_;
	GeeHashMap* _tmp12_;
	FsoGsmPlusCGMM* _tmp13_;
	FsoGsmPlusCGMM* _tmp14_;
	GeeHashMap* _tmp15_;
	FsoGsmPlusCGMR* _tmp16_;
	FsoGsmPlusCGMR* _tmp17_;
	GeeHashMap* _tmp18_;
	FsoGsmPlusCGSN* _tmp19_;
	FsoGsmPlusCGSN* _tmp20_;
	GeeHashMap* _tmp21_;
	FsoGsmPlusCIMI* _tmp22_;
	FsoGsmPlusCIMI* _tmp23_;
	GeeHashMap* _tmp24_;
	FsoGsmPlusCOPN* _tmp25_;
	FsoGsmPlusCOPN* _tmp26_;
	GeeHashMap* _tmp27_;
	FsoGsmPlusFCLASS* _tmp28_;
	FsoGsmPlusFCLASS* _tmp29_;
	GeeHashMap* _tmp30_;
	FsoGsmPlusGCAP* _tmp31_;
	FsoGsmPlusGCAP* _tmp32_;
	GeeHashMap* _tmp33_;
	FsoGsmPlusCLCK* _tmp34_;
	FsoGsmPlusCLCK* _tmp35_;
	GeeHashMap* _tmp36_;
	FsoGsmPlusCPIN* _tmp37_;
	FsoGsmPlusCPIN* _tmp38_;
	GeeHashMap* _tmp39_;
	FsoGsmPlusCPWD* _tmp40_;
	FsoGsmPlusCPWD* _tmp41_;
	GeeHashMap* _tmp42_;
	FsoGsmPlusCIEV* _tmp43_;
	FsoGsmPlusCIEV* _tmp44_;
	GeeHashMap* _tmp45_;
	FsoGsmPlusCNMI* _tmp46_;
	FsoGsmPlusCNMI* _tmp47_;
	GeeHashMap* _tmp48_;
	FsoGsmPlusCBC* _tmp49_;
	FsoGsmPlusCBC* _tmp50_;
	GeeHashMap* _tmp51_;
	FsoGsmPlusCFUN* _tmp52_;
	FsoGsmPlusCFUN* _tmp53_;
	GeeHashMap* _tmp54_;
	FsoGsmPlusCLVL* _tmp55_;
	FsoGsmPlusCLVL* _tmp56_;
	GeeHashMap* _tmp57_;
	FsoGsmPlusCMUT* _tmp58_;
	FsoGsmPlusCMUT* _tmp59_;
	GeeHashMap* _tmp60_;
	FsoGsmPlusCALA* _tmp61_;
	FsoGsmPlusCALA* _tmp62_;
	GeeHashMap* _tmp63_;
	FsoGsmPlusCCLK* _tmp64_;
	FsoGsmPlusCCLK* _tmp65_;
	GeeHashMap* _tmp66_;
	FsoGsmPlusCGREG* _tmp67_;
	FsoGsmPlusCGREG* _tmp68_;
	GeeHashMap* _tmp69_;
	FsoGsmPlusCLIR* _tmp70_;
	FsoGsmPlusCLIR* _tmp71_;
	GeeHashMap* _tmp72_;
	FsoGsmPlusCREG* _tmp73_;
	FsoGsmPlusCREG* _tmp74_;
	GeeHashMap* _tmp75_;
	FsoGsmPlusCOPS* _tmp76_;
	FsoGsmPlusCOPS* _tmp77_;
	GeeHashMap* _tmp78_;
	FsoGsmPlusCSQ* _tmp79_;
	FsoGsmPlusCSQ* _tmp80_;
	GeeHashMap* _tmp81_;
	FsoGsmPlusCSSI* _tmp82_;
	FsoGsmPlusCSSI* _tmp83_;
	GeeHashMap* _tmp84_;
	FsoGsmPlusCSSU* _tmp85_;
	FsoGsmPlusCSSU* _tmp86_;
	GeeHashMap* _tmp87_;
	FsoGsmPlusCUSD* _tmp88_;
	FsoGsmPlusCUSD* _tmp89_;
	GeeHashMap* _tmp90_;
	FsoGsmPlusCCFC* _tmp91_;
	FsoGsmPlusCCFC* _tmp92_;
	GeeHashMap* _tmp93_;
	FsoGsmV250A* _tmp94_;
	FsoGsmV250A* _tmp95_;
	GeeHashMap* _tmp96_;
	FsoGsmV250H* _tmp97_;
	FsoGsmV250H* _tmp98_;
	GeeHashMap* _tmp99_;
	FsoGsmV250D* _tmp100_;
	FsoGsmV250D* _tmp101_;
	GeeHashMap* _tmp102_;
	FsoGsmPlusCEER* _tmp103_;
	FsoGsmPlusCEER* _tmp104_;
	GeeHashMap* _tmp105_;
	FsoGsmPlusCHLD* _tmp106_;
	FsoGsmPlusCHLD* _tmp107_;
	GeeHashMap* _tmp108_;
	FsoGsmPlusCLCC* _tmp109_;
	FsoGsmPlusCLCC* _tmp110_;
	GeeHashMap* _tmp111_;
	FsoGsmPlusVTS* _tmp112_;
	FsoGsmPlusVTS* _tmp113_;
	GeeHashMap* _tmp114_;
	FsoGsmPlusCTFR* _tmp115_;
	FsoGsmPlusCTFR* _tmp116_;
	GeeHashMap* _tmp117_;
	FsoGsmPlusCPBR* _tmp118_;
	FsoGsmPlusCPBR* _tmp119_;
	GeeHashMap* _tmp120_;
	FsoGsmPlusCPBS* _tmp121_;
	FsoGsmPlusCPBS* _tmp122_;
	GeeHashMap* _tmp123_;
	FsoGsmPlusCPBW* _tmp124_;
	FsoGsmPlusCPBW* _tmp125_;
	GeeHashMap* _tmp126_;
	FsoGsmPlusCDS* _tmp127_;
	FsoGsmPlusCDS* _tmp128_;
	GeeHashMap* _tmp129_;
	FsoGsmPlusCMGD* _tmp130_;
	FsoGsmPlusCMGD* _tmp131_;
	GeeHashMap* _tmp132_;
	FsoGsmPlusCMGL* _tmp133_;
	FsoGsmPlusCMGL* _tmp134_;
	GeeHashMap* _tmp135_;
	FsoGsmPlusCMGR* _tmp136_;
	FsoGsmPlusCMGR* _tmp137_;
	GeeHashMap* _tmp138_;
	FsoGsmPlusCMGS* _tmp139_;
	FsoGsmPlusCMGS* _tmp140_;
	GeeHashMap* _tmp141_;
	FsoGsmPlusCMGW* _tmp142_;
	FsoGsmPlusCMGW* _tmp143_;
	GeeHashMap* _tmp144_;
	FsoGsmPlusCMMS* _tmp145_;
	FsoGsmPlusCMMS* _tmp146_;
	GeeHashMap* _tmp147_;
	FsoGsmPlusCMSS* _tmp148_;
	FsoGsmPlusCMSS* _tmp149_;
	GeeHashMap* _tmp150_;
	FsoGsmPlusCMT* _tmp151_;
	FsoGsmPlusCMT* _tmp152_;
	GeeHashMap* _tmp153_;
	FsoGsmPlusCMTI* _tmp154_;
	FsoGsmPlusCMTI* _tmp155_;
	GeeHashMap* _tmp156_;
	FsoGsmPlusCNMA* _tmp157_;
	FsoGsmPlusCNMA* _tmp158_;
	GeeHashMap* _tmp159_;
	FsoGsmPlusCPMS* _tmp160_;
	FsoGsmPlusCPMS* _tmp161_;
	GeeHashMap* _tmp162_;
	FsoGsmPlusCSCA* _tmp163_;
	FsoGsmPlusCSCA* _tmp164_;
	GeeHashMap* _tmp165_;
	FsoGsmPlusCSMS* _tmp166_;
	FsoGsmPlusCSMS* _tmp167_;
	GeeHashMap* _tmp168_;
	FsoGsmPlusCMGF* _tmp169_;
	FsoGsmPlusCMGF* _tmp170_;
	GeeHashMap* _tmp171_;
	FsoGsmPlusCBM* _tmp172_;
	FsoGsmPlusCBM* _tmp173_;
	GeeHashMap* _tmp174_;
	FsoGsmPlusCSCB* _tmp175_;
	FsoGsmPlusCSCB* _tmp176_;
	GeeHashMap* _tmp177_;
	FsoGsmPlusCGACT* _tmp178_;
	FsoGsmPlusCGACT* _tmp179_;
	GeeHashMap* _tmp180_;
	FsoGsmPlusCGATT* _tmp181_;
	FsoGsmPlusCGATT* _tmp182_;
	GeeHashMap* _tmp183_;
	FsoGsmPlusCGDCONT* _tmp184_;
	FsoGsmPlusCGDCONT* _tmp185_;
	GeeHashMap* _tmp186_;
	FsoGsmPlusCMICKEY* _tmp187_;
	FsoGsmPlusCMICKEY* _tmp188_;
	g_return_if_fail (table != NULL);
	_tmp0_ = table;
	_tmp1_ = fso_gsm_plus_crsm_new ();
	_tmp2_ = _tmp1_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp0_, "+CRSM", (FsoGsmAtCommand*) _tmp2_);
	_g_object_unref0 (_tmp2_);
	_tmp3_ = table;
	_tmp4_ = fso_gsm_plus_cscs_new ();
	_tmp5_ = _tmp4_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp3_, "+CSCS", (FsoGsmAtCommand*) _tmp5_);
	_g_object_unref0 (_tmp5_);
	_tmp6_ = table;
	_tmp7_ = fso_gsm_plus_cgclass_new ();
	_tmp8_ = _tmp7_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp6_, "+CGCLASS", (FsoGsmAtCommand*) _tmp8_);
	_g_object_unref0 (_tmp8_);
	_tmp9_ = table;
	_tmp10_ = fso_gsm_plus_cgmi_new ();
	_tmp11_ = _tmp10_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp9_, "+CGMI", (FsoGsmAtCommand*) _tmp11_);
	_g_object_unref0 (_tmp11_);
	_tmp12_ = table;
	_tmp13_ = fso_gsm_plus_cgmm_new ();
	_tmp14_ = _tmp13_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp12_, "+CGMM", (FsoGsmAtCommand*) _tmp14_);
	_g_object_unref0 (_tmp14_);
	_tmp15_ = table;
	_tmp16_ = fso_gsm_plus_cgmr_new ();
	_tmp17_ = _tmp16_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp15_, "+CGMR", (FsoGsmAtCommand*) _tmp17_);
	_g_object_unref0 (_tmp17_);
	_tmp18_ = table;
	_tmp19_ = fso_gsm_plus_cgsn_new ();
	_tmp20_ = _tmp19_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp18_, "+CGSN", (FsoGsmAtCommand*) _tmp20_);
	_g_object_unref0 (_tmp20_);
	_tmp21_ = table;
	_tmp22_ = fso_gsm_plus_cimi_new ();
	_tmp23_ = _tmp22_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp21_, "+CIMI", (FsoGsmAtCommand*) _tmp23_);
	_g_object_unref0 (_tmp23_);
	_tmp24_ = table;
	_tmp25_ = fso_gsm_plus_copn_new ();
	_tmp26_ = _tmp25_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp24_, "+COPN", (FsoGsmAtCommand*) _tmp26_);
	_g_object_unref0 (_tmp26_);
	_tmp27_ = table;
	_tmp28_ = fso_gsm_plus_fclass_new ();
	_tmp29_ = _tmp28_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp27_, "+FCLASS", (FsoGsmAtCommand*) _tmp29_);
	_g_object_unref0 (_tmp29_);
	_tmp30_ = table;
	_tmp31_ = fso_gsm_plus_gcap_new ();
	_tmp32_ = _tmp31_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp30_, "+GCAP", (FsoGsmAtCommand*) _tmp32_);
	_g_object_unref0 (_tmp32_);
	_tmp33_ = table;
	_tmp34_ = fso_gsm_plus_clck_new ();
	_tmp35_ = _tmp34_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp33_, "+CLCK", (FsoGsmAtCommand*) _tmp35_);
	_g_object_unref0 (_tmp35_);
	_tmp36_ = table;
	_tmp37_ = fso_gsm_plus_cpin_new ();
	_tmp38_ = _tmp37_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp36_, "+CPIN", (FsoGsmAtCommand*) _tmp38_);
	_g_object_unref0 (_tmp38_);
	_tmp39_ = table;
	_tmp40_ = fso_gsm_plus_cpwd_new ();
	_tmp41_ = _tmp40_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp39_, "+CPWD", (FsoGsmAtCommand*) _tmp41_);
	_g_object_unref0 (_tmp41_);
	_tmp42_ = table;
	_tmp43_ = fso_gsm_plus_ciev_new ();
	_tmp44_ = _tmp43_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp42_, "+CIEV", (FsoGsmAtCommand*) _tmp44_);
	_g_object_unref0 (_tmp44_);
	_tmp45_ = table;
	_tmp46_ = fso_gsm_plus_cnmi_new ();
	_tmp47_ = _tmp46_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp45_, "+CNMI", (FsoGsmAtCommand*) _tmp47_);
	_g_object_unref0 (_tmp47_);
	_tmp48_ = table;
	_tmp49_ = fso_gsm_plus_cbc_new ();
	_tmp50_ = _tmp49_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp48_, "+CBC", (FsoGsmAtCommand*) _tmp50_);
	_g_object_unref0 (_tmp50_);
	_tmp51_ = table;
	_tmp52_ = fso_gsm_plus_cfun_new ();
	_tmp53_ = _tmp52_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp51_, "+CFUN", (FsoGsmAtCommand*) _tmp53_);
	_g_object_unref0 (_tmp53_);
	_tmp54_ = table;
	_tmp55_ = fso_gsm_plus_clvl_new ();
	_tmp56_ = _tmp55_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp54_, "+CLVL", (FsoGsmAtCommand*) _tmp56_);
	_g_object_unref0 (_tmp56_);
	_tmp57_ = table;
	_tmp58_ = fso_gsm_plus_cmut_new ();
	_tmp59_ = _tmp58_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp57_, "+CMUT", (FsoGsmAtCommand*) _tmp59_);
	_g_object_unref0 (_tmp59_);
	_tmp60_ = table;
	_tmp61_ = fso_gsm_plus_cala_new ();
	_tmp62_ = _tmp61_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp60_, "+CALA", (FsoGsmAtCommand*) _tmp62_);
	_g_object_unref0 (_tmp62_);
	_tmp63_ = table;
	_tmp64_ = fso_gsm_plus_cclk_new ();
	_tmp65_ = _tmp64_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp63_, "+CCLK", (FsoGsmAtCommand*) _tmp65_);
	_g_object_unref0 (_tmp65_);
	_tmp66_ = table;
	_tmp67_ = fso_gsm_plus_cgreg_new ();
	_tmp68_ = _tmp67_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp66_, "+CGREG", (FsoGsmAtCommand*) _tmp68_);
	_g_object_unref0 (_tmp68_);
	_tmp69_ = table;
	_tmp70_ = fso_gsm_plus_clir_new ();
	_tmp71_ = _tmp70_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp69_, "+CLIR", (FsoGsmAtCommand*) _tmp71_);
	_g_object_unref0 (_tmp71_);
	_tmp72_ = table;
	_tmp73_ = fso_gsm_plus_creg_new ();
	_tmp74_ = _tmp73_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp72_, "+CREG", (FsoGsmAtCommand*) _tmp74_);
	_g_object_unref0 (_tmp74_);
	_tmp75_ = table;
	_tmp76_ = fso_gsm_plus_cops_new ();
	_tmp77_ = _tmp76_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp75_, "+COPS", (FsoGsmAtCommand*) _tmp77_);
	_g_object_unref0 (_tmp77_);
	_tmp78_ = table;
	_tmp79_ = fso_gsm_plus_csq_new ();
	_tmp80_ = _tmp79_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp78_, "+CSQ", (FsoGsmAtCommand*) _tmp80_);
	_g_object_unref0 (_tmp80_);
	_tmp81_ = table;
	_tmp82_ = fso_gsm_plus_cssi_new ();
	_tmp83_ = _tmp82_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp81_, "+CSSI", (FsoGsmAtCommand*) _tmp83_);
	_g_object_unref0 (_tmp83_);
	_tmp84_ = table;
	_tmp85_ = fso_gsm_plus_cssu_new ();
	_tmp86_ = _tmp85_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp84_, "+CSSU", (FsoGsmAtCommand*) _tmp86_);
	_g_object_unref0 (_tmp86_);
	_tmp87_ = table;
	_tmp88_ = fso_gsm_plus_cusd_new ();
	_tmp89_ = _tmp88_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp87_, "+CUSD", (FsoGsmAtCommand*) _tmp89_);
	_g_object_unref0 (_tmp89_);
	_tmp90_ = table;
	_tmp91_ = fso_gsm_plus_ccfc_new ();
	_tmp92_ = _tmp91_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp90_, "+CCFC", (FsoGsmAtCommand*) _tmp92_);
	_g_object_unref0 (_tmp92_);
	_tmp93_ = table;
	_tmp94_ = fso_gsm_v250_a_new ();
	_tmp95_ = _tmp94_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp93_, "A", (FsoGsmAtCommand*) _tmp95_);
	_g_object_unref0 (_tmp95_);
	_tmp96_ = table;
	_tmp97_ = fso_gsm_v250_h_new ();
	_tmp98_ = _tmp97_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp96_, "H", (FsoGsmAtCommand*) _tmp98_);
	_g_object_unref0 (_tmp98_);
	_tmp99_ = table;
	_tmp100_ = fso_gsm_v250_d_new ();
	_tmp101_ = _tmp100_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp99_, "D", (FsoGsmAtCommand*) _tmp101_);
	_g_object_unref0 (_tmp101_);
	_tmp102_ = table;
	_tmp103_ = fso_gsm_plus_ceer_new ();
	_tmp104_ = _tmp103_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp102_, "+CEER", (FsoGsmAtCommand*) _tmp104_);
	_g_object_unref0 (_tmp104_);
	_tmp105_ = table;
	_tmp106_ = fso_gsm_plus_chld_new ();
	_tmp107_ = _tmp106_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp105_, "+CHLD", (FsoGsmAtCommand*) _tmp107_);
	_g_object_unref0 (_tmp107_);
	_tmp108_ = table;
	_tmp109_ = fso_gsm_plus_clcc_new ();
	_tmp110_ = _tmp109_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp108_, "+CLCC", (FsoGsmAtCommand*) _tmp110_);
	_g_object_unref0 (_tmp110_);
	_tmp111_ = table;
	_tmp112_ = fso_gsm_plus_vts_new ();
	_tmp113_ = _tmp112_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp111_, "+VTS", (FsoGsmAtCommand*) _tmp113_);
	_g_object_unref0 (_tmp113_);
	_tmp114_ = table;
	_tmp115_ = fso_gsm_plus_ctfr_new ();
	_tmp116_ = _tmp115_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp114_, "+CTFR", (FsoGsmAtCommand*) _tmp116_);
	_g_object_unref0 (_tmp116_);
	_tmp117_ = table;
	_tmp118_ = fso_gsm_plus_cpbr_new ();
	_tmp119_ = _tmp118_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp117_, "+CPBR", (FsoGsmAtCommand*) _tmp119_);
	_g_object_unref0 (_tmp119_);
	_tmp120_ = table;
	_tmp121_ = fso_gsm_plus_cpbs_new ();
	_tmp122_ = _tmp121_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp120_, "+CPBS", (FsoGsmAtCommand*) _tmp122_);
	_g_object_unref0 (_tmp122_);
	_tmp123_ = table;
	_tmp124_ = fso_gsm_plus_cpbw_new ();
	_tmp125_ = _tmp124_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp123_, "+CPBW", (FsoGsmAtCommand*) _tmp125_);
	_g_object_unref0 (_tmp125_);
	_tmp126_ = table;
	_tmp127_ = fso_gsm_plus_cds_new ();
	_tmp128_ = _tmp127_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp126_, "+CDS", (FsoGsmAtCommand*) _tmp128_);
	_g_object_unref0 (_tmp128_);
	_tmp129_ = table;
	_tmp130_ = fso_gsm_plus_cmgd_new ();
	_tmp131_ = _tmp130_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp129_, "+CMGD", (FsoGsmAtCommand*) _tmp131_);
	_g_object_unref0 (_tmp131_);
	_tmp132_ = table;
	_tmp133_ = fso_gsm_plus_cmgl_new ();
	_tmp134_ = _tmp133_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp132_, "+CMGL", (FsoGsmAtCommand*) _tmp134_);
	_g_object_unref0 (_tmp134_);
	_tmp135_ = table;
	_tmp136_ = fso_gsm_plus_cmgr_new ();
	_tmp137_ = _tmp136_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp135_, "+CMGR", (FsoGsmAtCommand*) _tmp137_);
	_g_object_unref0 (_tmp137_);
	_tmp138_ = table;
	_tmp139_ = fso_gsm_plus_cmgs_new ();
	_tmp140_ = _tmp139_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp138_, "+CMGS", (FsoGsmAtCommand*) _tmp140_);
	_g_object_unref0 (_tmp140_);
	_tmp141_ = table;
	_tmp142_ = fso_gsm_plus_cmgw_new ();
	_tmp143_ = _tmp142_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp141_, "+CMGW", (FsoGsmAtCommand*) _tmp143_);
	_g_object_unref0 (_tmp143_);
	_tmp144_ = table;
	_tmp145_ = fso_gsm_plus_cmms_new ();
	_tmp146_ = _tmp145_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp144_, "+CMMS", (FsoGsmAtCommand*) _tmp146_);
	_g_object_unref0 (_tmp146_);
	_tmp147_ = table;
	_tmp148_ = fso_gsm_plus_cmss_new ();
	_tmp149_ = _tmp148_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp147_, "+CMSS", (FsoGsmAtCommand*) _tmp149_);
	_g_object_unref0 (_tmp149_);
	_tmp150_ = table;
	_tmp151_ = fso_gsm_plus_cmt_new ();
	_tmp152_ = _tmp151_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp150_, "+CMT", (FsoGsmAtCommand*) _tmp152_);
	_g_object_unref0 (_tmp152_);
	_tmp153_ = table;
	_tmp154_ = fso_gsm_plus_cmti_new ();
	_tmp155_ = _tmp154_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp153_, "+CMTI", (FsoGsmAtCommand*) _tmp155_);
	_g_object_unref0 (_tmp155_);
	_tmp156_ = table;
	_tmp157_ = fso_gsm_plus_cnma_new ();
	_tmp158_ = _tmp157_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp156_, "+CNMA", (FsoGsmAtCommand*) _tmp158_);
	_g_object_unref0 (_tmp158_);
	_tmp159_ = table;
	_tmp160_ = fso_gsm_plus_cpms_new ();
	_tmp161_ = _tmp160_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp159_, "+CPMS", (FsoGsmAtCommand*) _tmp161_);
	_g_object_unref0 (_tmp161_);
	_tmp162_ = table;
	_tmp163_ = fso_gsm_plus_csca_new ();
	_tmp164_ = _tmp163_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp162_, "+CSCA", (FsoGsmAtCommand*) _tmp164_);
	_g_object_unref0 (_tmp164_);
	_tmp165_ = table;
	_tmp166_ = fso_gsm_plus_csms_new ();
	_tmp167_ = _tmp166_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp165_, "+CSMS", (FsoGsmAtCommand*) _tmp167_);
	_g_object_unref0 (_tmp167_);
	_tmp168_ = table;
	_tmp169_ = fso_gsm_plus_cmgf_new ();
	_tmp170_ = _tmp169_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp168_, "+CMGF", (FsoGsmAtCommand*) _tmp170_);
	_g_object_unref0 (_tmp170_);
	_tmp171_ = table;
	_tmp172_ = fso_gsm_plus_cbm_new ();
	_tmp173_ = _tmp172_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp171_, "+CBM", (FsoGsmAtCommand*) _tmp173_);
	_g_object_unref0 (_tmp173_);
	_tmp174_ = table;
	_tmp175_ = fso_gsm_plus_cscb_new ();
	_tmp176_ = _tmp175_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp174_, "+CSCB", (FsoGsmAtCommand*) _tmp176_);
	_g_object_unref0 (_tmp176_);
	_tmp177_ = table;
	_tmp178_ = fso_gsm_plus_cgact_new ();
	_tmp179_ = _tmp178_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp177_, "+CGACT", (FsoGsmAtCommand*) _tmp179_);
	_g_object_unref0 (_tmp179_);
	_tmp180_ = table;
	_tmp181_ = fso_gsm_plus_cgatt_new ();
	_tmp182_ = _tmp181_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp180_, "+CGATT", (FsoGsmAtCommand*) _tmp182_);
	_g_object_unref0 (_tmp182_);
	_tmp183_ = table;
	_tmp184_ = fso_gsm_plus_cgdcont_new ();
	_tmp185_ = _tmp184_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp183_, "+CGDCONT", (FsoGsmAtCommand*) _tmp185_);
	_g_object_unref0 (_tmp185_);
	_tmp186_ = table;
	_tmp187_ = fso_gsm_plus_cmickey_new ();
	_tmp188_ = _tmp187_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp186_, "+CMICKEY", (FsoGsmAtCommand*) _tmp188_);
	_g_object_unref0 (_tmp188_);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



