/* plugin.c generated by valac 0.16.1, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * Copyright (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <fsogsm.h>
#include <fsobasics.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <freesmartphone.h>
#include <fcntl.h>
#include <sys/types.h>
#include <errno.h>
#include <fsoframework.h>


#define PDP_TYPE_QMI (pdp_qmi_get_type ())
#define PDP_QMI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PDP_TYPE_QMI, PdpQmi))
#define PDP_QMI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PDP_TYPE_QMI, PdpQmiClass))
#define PDP_IS_QMI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PDP_TYPE_QMI))
#define PDP_IS_QMI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PDP_TYPE_QMI))
#define PDP_QMI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PDP_TYPE_QMI, PdpQmiClass))

typedef struct _PdpQmi PdpQmi;
typedef struct _PdpQmiClass PdpQmiClass;
typedef struct _PdpQmiPrivate PdpQmiPrivate;
typedef struct _Block1Data Block1Data;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _fso_gsm_route_info_unref0(var) ((var == NULL) ? NULL : (var = (fso_gsm_route_info_unref (var), NULL)))
typedef struct _PdpQmiScActivateData PdpQmiScActivateData;
typedef struct _PdpQmiScDeactivateData PdpQmiScDeactivateData;
typedef struct _pdp_qmi_statusUpdateData pdp_qmi_statusUpdateData;

struct _PdpQmi {
	FsoGsmPdpHandler parent_instance;
	PdpQmiPrivate * priv;
	gint fd;
};

struct _PdpQmiClass {
	FsoGsmPdpHandlerClass parent_class;
};

struct _Block1Data {
	int _ref_count_;
	PdpQmi * self;
	gssize bread;
};

struct _PdpQmiScActivateData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	PdpQmi* self;
	FsoGsmModem* _tmp0_;
	FsoGsmModem* _tmp1_;
	FsoGsmModemData* _tmp2_;
	FsoGsmModemData* data;
	FsoGsmModemData* _tmp3_;
	FsoGsmContextParams* _tmp4_;
	GError* _tmp5_;
	FsoGsmModemData* _tmp6_;
	FsoGsmContextParams* _tmp7_;
	const gchar* _tmp8_;
	GError* _tmp9_;
	FsoGsmModemData* _tmp10_;
	FsoGsmContextParams* _tmp11_;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	FsoGsmModemData* _tmp14_;
	FsoGsmContextParams* _tmp15_;
	const gchar* _tmp16_;
	const gchar* _tmp17_;
	FsoGsmModemData* _tmp18_;
	FsoGsmContextParams* _tmp19_;
	const gchar* _tmp20_;
	const gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* cmdline;
	gint _tmp23_;
	const gchar* _tmp24_;
	const gchar* _tmp25_;
	gint _tmp26_;
	gint _tmp27_;
	GError * _inner_error_;
};

struct _PdpQmiScDeactivateData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	PdpQmi* self;
	gint _tmp0_;
};

struct _pdp_qmi_statusUpdateData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	PdpQmi* self;
	gchar* status;
	GHashTable* properties;
};


static gpointer pdp_qmi_parent_class = NULL;
static gchar* pdp_qmi_buffer;
static gint pdp_qmi_buffer_length1;
static gchar* pdp_qmi_buffer = NULL;
static gint pdp_qmi_buffer_length1 = 0;
static gint _pdp_qmi_buffer_size_ = 0;
extern gchar* devfs_root;
static GType pdp_qmi_type_id = 0;
extern gchar* sysfs_root;
gchar* sysfs_root = NULL;
gchar* devfs_root = NULL;

GType pdp_qmi_get_type (void) G_GNUC_CONST;
GType pdp_qmi_register_type (GTypeModule * module);
enum  {
	PDP_QMI_DUMMY_PROPERTY
};
#define PDP_QMI_MODULE_NAME "fsogsm.pdp_qmi"
#define PDP_QMI_RMNET_IFACE "rmnet0"
#define PDP_QMI_QMI_DEVNODE "qmi0"
static gchar* pdp_qmi_real_repr (FsoFrameworkAbstractObject* base);
static void pdp_qmi_qmiListenerThread (PdpQmi* self, void* data);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean ___lambda2_ (Block1Data* _data1_);
static void pdp_qmi_onInputFromQmi (PdpQmi* self, gchar* data, gssize length);
static gboolean ____lambda2__gsource_func (gpointer self);
static void pdp_qmi_onUpdateFromQmi (PdpQmi* self, GHashTable* properties);
static void pdp_qmi_real_sc_activate_data_free (gpointer _data);
static void pdp_qmi_real_sc_activate (FsoGsmPdpHandler* base, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean pdp_qmi_real_sc_activate_co (PdpQmiScActivateData* _data_);
static void pdp_qmi_real_sc_deactivate_data_free (gpointer _data);
static void pdp_qmi_real_sc_deactivate (FsoGsmPdpHandler* base, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean pdp_qmi_real_sc_deactivate_co (PdpQmiScDeactivateData* _data_);
static void pdp_qmi_real_statusUpdate_data_free (gpointer _data);
static void pdp_qmi_real_statusUpdate (FsoGsmPdpHandler* base, const gchar* status, GHashTable* properties, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean pdp_qmi_real_statusUpdate_co (pdp_qmi_statusUpdateData* _data_);
PdpQmi* pdp_qmi_new (void);
PdpQmi* pdp_qmi_construct (GType object_type);
static GObject * pdp_qmi_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _pdp_qmi_qmiListenerThread_fso_framework_threading_void_func_with_void_star_param (void* param, gpointer self);
static void pdp_qmi_finalize (GObject* obj);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);


static gchar* pdp_qmi_real_repr (FsoFrameworkAbstractObject* base) {
	PdpQmi * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (PdpQmi*) base;
	_tmp0_ = g_strdup ("<>");
	result = _tmp0_;
	return result;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		PdpQmi * self;
		self = _data1_->self;
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean ___lambda2_ (Block1Data* _data1_) {
	PdpQmi * self;
	gboolean result = FALSE;
	gchar* _tmp0_;
	gint _tmp0__length1;
	gssize _tmp1_;
	self = _data1_->self;
	_tmp0_ = pdp_qmi_buffer;
	_tmp0__length1 = pdp_qmi_buffer_length1;
	_tmp1_ = _data1_->bread;
	pdp_qmi_onInputFromQmi (self, _tmp0_, _tmp1_);
	result = FALSE;
	return result;
}


static gboolean ____lambda2__gsource_func (gpointer self) {
	gboolean result;
	result = ___lambda2_ (self);
	return result;
}


static void pdp_qmi_qmiListenerThread (PdpQmi* self, void* data) {
	g_return_if_fail (self != NULL);
	while (TRUE) {
		Block1Data* _data1_;
		FsoFrameworkLogger* _tmp0_;
		gboolean _tmp1_ = FALSE;
		gint _tmp2_;
		gchar* _tmp3_;
		gint _tmp3__length1;
		gchar* _tmp4_;
		gint _tmp4__length1;
		gssize _tmp5_ = 0L;
		FsoFrameworkLogger* _tmp6_;
		gssize _tmp7_;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		gboolean _tmp12_ = FALSE;
		_data1_ = g_slice_new0 (Block1Data);
		_data1_->_ref_count_ = 1;
		_data1_->self = g_object_ref (self);
		_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp1_ = fso_framework_logger_debug (_tmp0_, "qmi listener thread waiting for data from QMI...");
		g_assert (_tmp1_);
		_tmp2_ = self->fd;
		_tmp3_ = pdp_qmi_buffer;
		_tmp3__length1 = pdp_qmi_buffer_length1;
		_tmp4_ = pdp_qmi_buffer;
		_tmp4__length1 = pdp_qmi_buffer_length1;
		_tmp5_ = read (_tmp2_, _tmp3_, (gsize) _tmp4__length1);
		_data1_->bread = _tmp5_;
		_tmp6_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp7_ = _data1_->bread;
		_tmp8_ = g_strdup_printf ("%" G_GSSIZE_FORMAT, _tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = g_strconcat ("got ", _tmp9_, " bytes", NULL);
		_tmp11_ = _tmp10_;
		_tmp12_ = fso_framework_logger_debug (_tmp6_, _tmp11_);
		g_assert (_tmp12_);
		_g_free0 (_tmp11_);
		_g_free0 (_tmp9_);
		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ____lambda2__gsource_func, block1_data_ref (_data1_), block1_data_unref);
		block1_data_unref (_data1_);
		_data1_ = NULL;
	}
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void pdp_qmi_onInputFromQmi (PdpQmi* self, gchar* data, gssize length) {
	gchar* _tmp0_;
	gssize _tmp1_;
	gchar _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* message;
	FsoFrameworkLogger* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	gboolean _tmp11_ = FALSE;
	GHashTable* _tmp12_ = NULL;
	GHashTable* _tmp13_;
	g_return_if_fail (self != NULL);
	_tmp0_ = data;
	_tmp1_ = length;
	_tmp0_[_tmp1_ - 1] = '\0';
	_tmp2_ = _tmp0_[_tmp1_ - 1];
	_tmp3_ = data;
	_tmp4_ = g_strdup ((const gchar*) _tmp3_);
	message = _tmp4_;
	_tmp5_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp6_ = g_strescape (message, "");
	_tmp7_ = _tmp6_;
	_tmp8_ = string_to_string (_tmp7_);
	_tmp9_ = g_strconcat ("QMI says: ", _tmp8_, NULL);
	_tmp10_ = _tmp9_;
	_tmp11_ = fso_framework_logger_debug (_tmp5_, _tmp10_);
	g_assert (_tmp11_);
	_g_free0 (_tmp10_);
	_g_free0 (_tmp7_);
	_tmp12_ = fso_framework_string_handling_splitKeyValuePairs (message);
	_tmp13_ = _tmp12_;
	pdp_qmi_onUpdateFromQmi (self, _tmp13_);
	_g_hash_table_unref0 (_tmp13_);
	_g_free0 (message);
}


static void pdp_qmi_onUpdateFromQmi (PdpQmi* self, GHashTable* properties) {
	GHashTable* _tmp0_;
	gconstpointer _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* state;
	GHashTable* _tmp8_;
	guint _tmp9_ = 0U;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	const gchar* _tmp12_;
	const gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_;
	const gchar* _tmp16_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (properties != NULL);
	_tmp0_ = properties;
	_tmp1_ = g_hash_table_lookup (_tmp0_, "STATE");
	_tmp2_ = g_strdup ((const gchar*) _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_;
	if (_tmp4_ == NULL) {
		gchar* _tmp5_;
		_tmp5_ = g_strdup ("unknown");
		_g_free0 (_tmp3_);
		_tmp3_ = _tmp5_;
	}
	_tmp6_ = _tmp3_;
	_tmp7_ = g_strdup (_tmp6_);
	state = _tmp7_;
	_tmp8_ = properties;
	_tmp9_ = g_hash_table_size (_tmp8_);
	_tmp10_ = g_strdup_printf ("%u", _tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = state;
	_tmp13_ = string_to_string (_tmp12_);
	_tmp14_ = g_strconcat ("onUpdateFromQmi with ", _tmp11_, " properties [state=", _tmp13_, "]", NULL);
	_tmp15_ = _tmp14_;
	g_message ("plugin.vala:85: %s", _tmp15_);
	_g_free0 (_tmp15_);
	_g_free0 (_tmp11_);
	_tmp16_ = state;
	if (g_strcmp0 (_tmp16_, "up") == 0) {
		GHashTable* _tmp17_;
		gconstpointer _tmp18_ = NULL;
		gchar* _tmp19_;
		gchar* _tmp20_;
		const gchar* _tmp21_;
		const gchar* _tmp23_;
		gchar* _tmp24_;
		gchar* addr;
		GHashTable* _tmp25_;
		gconstpointer _tmp26_ = NULL;
		gchar* _tmp27_;
		gchar* _tmp28_;
		const gchar* _tmp29_;
		const gchar* _tmp31_;
		gchar* _tmp32_;
		gchar* mask;
		GHashTable* _tmp33_;
		gconstpointer _tmp34_ = NULL;
		gchar* _tmp35_;
		gchar* _tmp36_;
		const gchar* _tmp37_;
		const gchar* _tmp39_;
		gchar* _tmp40_;
		gchar* gway;
		GHashTable* _tmp41_;
		gconstpointer _tmp42_ = NULL;
		gchar* _tmp43_;
		gchar* _tmp44_;
		const gchar* _tmp45_;
		const gchar* _tmp47_;
		gchar* _tmp48_;
		gchar* dns1;
		GHashTable* _tmp49_;
		gconstpointer _tmp50_ = NULL;
		gchar* _tmp51_;
		gchar* _tmp52_;
		const gchar* _tmp53_;
		const gchar* _tmp55_;
		gchar* _tmp56_;
		gchar* dns2;
		gchar* _tmp57_;
		const gchar* _tmp58_;
		gchar* _tmp59_;
		const gchar* _tmp60_;
		gchar* _tmp61_;
		const gchar* _tmp62_;
		gchar* _tmp63_;
		const gchar* _tmp64_;
		gchar* _tmp65_;
		const gchar* _tmp66_;
		gchar* _tmp67_;
		FsoGsmRouteInfo* _tmp68_ = NULL;
		FsoGsmRouteInfo* route;
		FsoGsmRouteInfo* _tmp69_;
		_tmp17_ = properties;
		_tmp18_ = g_hash_table_lookup (_tmp17_, "ADDR");
		_tmp19_ = g_strdup ((const gchar*) _tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = _tmp20_;
		if (_tmp21_ == NULL) {
			gchar* _tmp22_;
			_tmp22_ = g_strdup ("unknown");
			_g_free0 (_tmp20_);
			_tmp20_ = _tmp22_;
		}
		_tmp23_ = _tmp20_;
		_tmp24_ = g_strdup (_tmp23_);
		addr = _tmp24_;
		_tmp25_ = properties;
		_tmp26_ = g_hash_table_lookup (_tmp25_, "MASK");
		_tmp27_ = g_strdup ((const gchar*) _tmp26_);
		_tmp28_ = _tmp27_;
		_tmp29_ = _tmp28_;
		if (_tmp29_ == NULL) {
			gchar* _tmp30_;
			_tmp30_ = g_strdup ("unknown");
			_g_free0 (_tmp28_);
			_tmp28_ = _tmp30_;
		}
		_tmp31_ = _tmp28_;
		_tmp32_ = g_strdup (_tmp31_);
		mask = _tmp32_;
		_tmp33_ = properties;
		_tmp34_ = g_hash_table_lookup (_tmp33_, "GATEWAY");
		_tmp35_ = g_strdup ((const gchar*) _tmp34_);
		_tmp36_ = _tmp35_;
		_tmp37_ = _tmp36_;
		if (_tmp37_ == NULL) {
			gchar* _tmp38_;
			_tmp38_ = g_strdup ("unknown");
			_g_free0 (_tmp36_);
			_tmp36_ = _tmp38_;
		}
		_tmp39_ = _tmp36_;
		_tmp40_ = g_strdup (_tmp39_);
		gway = _tmp40_;
		_tmp41_ = properties;
		_tmp42_ = g_hash_table_lookup (_tmp41_, "DNS1");
		_tmp43_ = g_strdup ((const gchar*) _tmp42_);
		_tmp44_ = _tmp43_;
		_tmp45_ = _tmp44_;
		if (_tmp45_ == NULL) {
			gchar* _tmp46_;
			_tmp46_ = g_strdup ("unknown");
			_g_free0 (_tmp44_);
			_tmp44_ = _tmp46_;
		}
		_tmp47_ = _tmp44_;
		_tmp48_ = g_strdup (_tmp47_);
		dns1 = _tmp48_;
		_tmp49_ = properties;
		_tmp50_ = g_hash_table_lookup (_tmp49_, "DNS2");
		_tmp51_ = g_strdup ((const gchar*) _tmp50_);
		_tmp52_ = _tmp51_;
		_tmp53_ = _tmp52_;
		if (_tmp53_ == NULL) {
			gchar* _tmp54_;
			_tmp54_ = g_strdup ("unknown");
			_g_free0 (_tmp52_);
			_tmp52_ = _tmp54_;
		}
		_tmp55_ = _tmp52_;
		_tmp56_ = g_strdup (_tmp55_);
		dns2 = _tmp56_;
		_tmp57_ = g_strdup (PDP_QMI_RMNET_IFACE);
		_tmp58_ = addr;
		_tmp59_ = g_strdup (_tmp58_);
		_tmp60_ = mask;
		_tmp61_ = g_strdup (_tmp60_);
		_tmp62_ = gway;
		_tmp63_ = g_strdup (_tmp62_);
		_tmp64_ = dns1;
		_tmp65_ = g_strdup (_tmp64_);
		_tmp66_ = dns2;
		_tmp67_ = g_strdup (_tmp66_);
		_tmp68_ = fso_gsm_route_info_new ();
		_g_free0 (_tmp68_->iface);
		_tmp68_->iface = _tmp57_;
		_g_free0 (_tmp68_->ipv4addr);
		_tmp68_->ipv4addr = _tmp59_;
		_g_free0 (_tmp68_->ipv4mask);
		_tmp68_->ipv4mask = _tmp61_;
		_g_free0 (_tmp68_->ipv4gateway);
		_tmp68_->ipv4gateway = _tmp63_;
		_g_free0 (_tmp68_->dns1);
		_tmp68_->dns1 = _tmp65_;
		_g_free0 (_tmp68_->dns2);
		_tmp68_->dns2 = _tmp67_;
		route = _tmp68_;
		_tmp69_ = route;
		fso_gsm_ipdp_handler_connectedWithNewDefaultRoute ((FsoGsmIPdpHandler*) self, _tmp69_, NULL, NULL);
		_fso_gsm_route_info_unref0 (route);
		_g_free0 (dns2);
		_g_free0 (_tmp52_);
		_g_free0 (dns1);
		_g_free0 (_tmp44_);
		_g_free0 (gway);
		_g_free0 (_tmp36_);
		_g_free0 (mask);
		_g_free0 (_tmp28_);
		_g_free0 (addr);
		_g_free0 (_tmp20_);
	}
	_g_free0 (state);
	_g_free0 (_tmp3_);
}


static void pdp_qmi_real_sc_activate_data_free (gpointer _data) {
	PdpQmiScActivateData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (PdpQmiScActivateData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void pdp_qmi_real_sc_activate (FsoGsmPdpHandler* base, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	PdpQmi * self;
	PdpQmiScActivateData* _data_;
	PdpQmi* _tmp0_;
	self = (PdpQmi*) base;
	_data_ = g_slice_new0 (PdpQmiScActivateData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, pdp_qmi_real_sc_activate);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, pdp_qmi_real_sc_activate_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	pdp_qmi_real_sc_activate_co (_data_);
}


static void pdp_qmi_real_sc_activate_finish (FsoGsmPdpHandler* base, GAsyncResult* _res_, GError** error) {
	PdpQmiScActivateData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean pdp_qmi_real_sc_activate_co (PdpQmiScActivateData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = fso_gsm_pdp_handler_get_modem ((FsoGsmPdpHandler*) _data_->self);
	_data_->_tmp1_ = _data_->_tmp0_;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = fso_gsm_modem_data (_data_->_tmp1_);
	_data_->data = _data_->_tmp2_;
	_data_->_tmp3_ = _data_->data;
	_data_->_tmp4_ = _data_->_tmp3_->contextParams;
	if (_data_->_tmp4_ == NULL) {
		_data_->_tmp5_ = g_error_new_literal (FREE_SMARTPHONE_ERROR, FREE_SMARTPHONE_ERROR_INTERNAL_ERROR, "Context parameters not set");
		_data_->_inner_error_ = _data_->_tmp5_;
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_GSM_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_g_object_unref0 (_data_->data);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_g_object_unref0 (_data_->data);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp6_ = _data_->data;
	_data_->_tmp7_ = _data_->_tmp6_->contextParams;
	_data_->_tmp8_ = _data_->_tmp7_->apn;
	if (_data_->_tmp8_ == NULL) {
		_data_->_tmp9_ = g_error_new_literal (FREE_SMARTPHONE_ERROR, FREE_SMARTPHONE_ERROR_INTERNAL_ERROR, "APN not set");
		_data_->_inner_error_ = _data_->_tmp9_;
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_GSM_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_g_object_unref0 (_data_->data);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_g_object_unref0 (_data_->data);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp10_ = _data_->data;
	_data_->_tmp11_ = _data_->_tmp10_->contextParams;
	_data_->_tmp12_ = _data_->_tmp11_->apn;
	_data_->_tmp13_ = NULL;
	_data_->_tmp13_ = string_to_string (_data_->_tmp12_);
	_data_->_tmp14_ = _data_->data;
	_data_->_tmp15_ = _data_->_tmp14_->contextParams;
	_data_->_tmp16_ = _data_->_tmp15_->username;
	_data_->_tmp17_ = NULL;
	_data_->_tmp17_ = string_to_string (_data_->_tmp16_);
	_data_->_tmp18_ = _data_->data;
	_data_->_tmp19_ = _data_->_tmp18_->contextParams;
	_data_->_tmp20_ = _data_->_tmp19_->password;
	_data_->_tmp21_ = NULL;
	_data_->_tmp21_ = string_to_string (_data_->_tmp20_);
	_data_->_tmp22_ = NULL;
	_data_->_tmp22_ = g_strconcat ("up:", _data_->_tmp13_, " ", _data_->_tmp17_, " ", _data_->_tmp21_, NULL);
	_data_->cmdline = _data_->_tmp22_;
	_data_->_tmp23_ = _data_->self->fd;
	_data_->_tmp24_ = _data_->cmdline;
	_data_->_tmp25_ = _data_->cmdline;
	_data_->_tmp26_ = strlen (_data_->_tmp25_);
	_data_->_tmp27_ = _data_->_tmp26_;
	write (_data_->_tmp23_, _data_->_tmp24_, (gsize) _data_->_tmp27_);
	_g_free0 (_data_->cmdline);
	_g_object_unref0 (_data_->data);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void pdp_qmi_real_sc_deactivate_data_free (gpointer _data) {
	PdpQmiScDeactivateData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (PdpQmiScDeactivateData, _data_);
}


static void pdp_qmi_real_sc_deactivate (FsoGsmPdpHandler* base, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	PdpQmi * self;
	PdpQmiScDeactivateData* _data_;
	PdpQmi* _tmp0_;
	self = (PdpQmi*) base;
	_data_ = g_slice_new0 (PdpQmiScDeactivateData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, pdp_qmi_real_sc_deactivate);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, pdp_qmi_real_sc_deactivate_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	pdp_qmi_real_sc_deactivate_co (_data_);
}


static void pdp_qmi_real_sc_deactivate_finish (FsoGsmPdpHandler* base, GAsyncResult* _res_, GError** error) {
	PdpQmiScDeactivateData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean pdp_qmi_real_sc_deactivate_co (PdpQmiScDeactivateData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->fd;
	write (_data_->_tmp0_, "down", (gsize) 5);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void pdp_qmi_real_statusUpdate_data_free (gpointer _data) {
	pdp_qmi_statusUpdateData* _data_;
	_data_ = _data;
	_g_free0 (_data_->status);
	_g_hash_table_unref0 (_data_->properties);
	_g_object_unref0 (_data_->self);
	g_slice_free (pdp_qmi_statusUpdateData, _data_);
}


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


static void pdp_qmi_real_statusUpdate (FsoGsmPdpHandler* base, const gchar* status, GHashTable* properties, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	PdpQmi * self;
	pdp_qmi_statusUpdateData* _data_;
	PdpQmi* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	GHashTable* _tmp3_;
	GHashTable* _tmp4_;
	self = (PdpQmi*) base;
	_data_ = g_slice_new0 (pdp_qmi_statusUpdateData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, pdp_qmi_real_statusUpdate);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, pdp_qmi_real_statusUpdate_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = status;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->status = _tmp2_;
	_tmp3_ = properties;
	_tmp4_ = _g_hash_table_ref0 (_tmp3_);
	_data_->properties = _tmp4_;
	pdp_qmi_real_statusUpdate_co (_data_);
}


static void pdp_qmi_real_statusUpdate_finish (FsoGsmPdpHandler* base, GAsyncResult* _res_) {
	pdp_qmi_statusUpdateData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean pdp_qmi_real_statusUpdate_co (pdp_qmi_statusUpdateData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_assert_not_reached ();
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


PdpQmi* pdp_qmi_construct (GType object_type) {
	PdpQmi * self = NULL;
	self = (PdpQmi*) fso_gsm_pdp_handler_construct (object_type);
	return self;
}


PdpQmi* pdp_qmi_new (void) {
	return pdp_qmi_construct (PDP_TYPE_QMI);
}


static void _pdp_qmi_qmiListenerThread_fso_framework_threading_void_func_with_void_star_param (void* param, gpointer self) {
	pdp_qmi_qmiListenerThread (self, param);
}


static GObject * pdp_qmi_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	PdpQmi * self;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* node;
	const gchar* _tmp2_;
	gint _tmp3_ = 0;
	gint _tmp4_;
	parent_class = G_OBJECT_CLASS (pdp_qmi_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = PDP_QMI (obj);
	_tmp0_ = devfs_root;
	_tmp1_ = g_build_filename (_tmp0_, PDP_QMI_QMI_DEVNODE, NULL);
	node = _tmp1_;
	_tmp2_ = node;
	_tmp3_ = open (_tmp2_, O_RDWR | O_NONBLOCK, (mode_t) 0);
	self->fd = _tmp3_;
	_tmp4_ = self->fd;
	if (_tmp4_ < 0) {
		FsoFrameworkLogger* _tmp5_;
		const gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gint _tmp8_;
		const gchar* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_;
		_tmp5_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp6_ = node;
		_tmp7_ = string_to_string (_tmp6_);
		_tmp8_ = errno;
		_tmp9_ = g_strerror (_tmp8_);
		_tmp10_ = string_to_string (_tmp9_);
		_tmp11_ = g_strconcat ("Can't open ", _tmp7_, ": ", _tmp10_, "; PDP via QMI will NOT be available", NULL);
		_tmp12_ = _tmp11_;
		fso_framework_logger_error (_tmp5_, _tmp12_);
		_g_free0 (_tmp12_);
	} else {
		g_thread_init (NULL);
		fso_framework_threading_callDelegateOnNewThread (_pdp_qmi_qmiListenerThread_fso_framework_threading_void_func_with_void_star_param, self, NULL);
	}
	_g_free0 (node);
	return obj;
}


static void pdp_qmi_class_init (PdpQmiClass * klass) {
	gchar* _tmp0_ = NULL;
	pdp_qmi_parent_class = g_type_class_peek_parent (klass);
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = pdp_qmi_real_repr;
	FSO_GSM_PDP_HANDLER_CLASS (klass)->sc_activate = pdp_qmi_real_sc_activate;
	FSO_GSM_PDP_HANDLER_CLASS (klass)->sc_activate_finish = pdp_qmi_real_sc_activate_finish;
	FSO_GSM_PDP_HANDLER_CLASS (klass)->sc_deactivate = pdp_qmi_real_sc_deactivate;
	FSO_GSM_PDP_HANDLER_CLASS (klass)->sc_deactivate_finish = pdp_qmi_real_sc_deactivate_finish;
	FSO_GSM_PDP_HANDLER_CLASS (klass)->statusUpdate = pdp_qmi_real_statusUpdate;
	FSO_GSM_PDP_HANDLER_CLASS (klass)->statusUpdate_finish = pdp_qmi_real_statusUpdate_finish;
	G_OBJECT_CLASS (klass)->constructor = pdp_qmi_constructor;
	G_OBJECT_CLASS (klass)->finalize = pdp_qmi_finalize;
	_tmp0_ = g_new0 (gchar, 512);
	pdp_qmi_buffer = _tmp0_;
	pdp_qmi_buffer_length1 = 512;
}


static void pdp_qmi_instance_init (PdpQmi * self) {
}


static void pdp_qmi_finalize (GObject* obj) {
	PdpQmi * self;
	self = PDP_QMI (obj);
	G_OBJECT_CLASS (pdp_qmi_parent_class)->finalize (obj);
}


/**
 * @class Pdp.Qmi
 *
 * Pdp Handler implemented with the proprietary Qualcomm Management Interface protocol
 **/
GType pdp_qmi_get_type (void) {
	return pdp_qmi_type_id;
}


GType pdp_qmi_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (PdpQmiClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pdp_qmi_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PdpQmi), 0, (GInstanceInitFunc) pdp_qmi_instance_init, NULL };
	pdp_qmi_type_id = g_type_module_register_type (module, FSO_GSM_TYPE_PDP_HANDLER, "PdpQmi", &g_define_type_info, 0);
	return pdp_qmi_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	FsoFrameworkLogger* _tmp0_;
	FsoFrameworkSmartKeyFile* _tmp1_;
	FsoFrameworkSmartKeyFile* _tmp2_;
	FsoFrameworkSmartKeyFile* config;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "pdp_qmi fso_factory_function");
	_tmp1_ = fso_framework_theConfig;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	config = _tmp2_;
	_tmp3_ = fso_framework_smart_key_file_stringValue (config, "cornucopia", "sysfs_root", "/sys");
	_g_free0 (sysfs_root);
	sysfs_root = _tmp3_;
	_tmp4_ = fso_framework_smart_key_file_stringValue (config, "cornucopia", "devfs_root", "/dev");
	_g_free0 (devfs_root);
	devfs_root = _tmp4_;
	_tmp5_ = g_strdup (PDP_QMI_MODULE_NAME);
	result = _tmp5_;
	_g_object_unref0 (config);
	return result;
}


void fso_register_function (GTypeModule* module) {
	g_return_if_fail (module != NULL);
	pdp_qmi_register_type (module);
}



