/* isitransport.c generated by valac 0.14.2, the Vala compiler
 * generated from isitransport.vala, do not modify */

/*
 * Copyright (C) 2011 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <fsotransport.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gisicomm.h>


#define TYPE_ISI_TRANSPORT (isi_transport_get_type ())
#define ISI_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ISI_TRANSPORT, IsiTransport))
#define ISI_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ISI_TRANSPORT, IsiTransportClass))
#define IS_ISI_TRANSPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ISI_TRANSPORT))
#define IS_ISI_TRANSPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ISI_TRANSPORT))
#define ISI_TRANSPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ISI_TRANSPORT, IsiTransportClass))

typedef struct _IsiTransport IsiTransport;
typedef struct _IsiTransportClass IsiTransportClass;
typedef struct _IsiTransportPrivate IsiTransportPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _isi_transport_openAsyncData isi_transport_openAsyncData;

struct _IsiTransport {
	FsoFrameworkNullTransport parent_instance;
	IsiTransportPrivate * priv;
};

struct _IsiTransportClass {
	FsoFrameworkNullTransportClass parent_class;
};

struct _IsiTransportPrivate {
	gboolean reachable;
	gchar* iface;
};

struct _isi_transport_openAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	IsiTransport* self;
	gboolean result;
	GIsiCommModemAccess* _tmp0_;
	gboolean _tmp1_;
	GIsiCommModemAccess* _tmp2_;
	gboolean _tmp3_;
	GIsiCommModemAccess* _tmp4_;
	gboolean _tmp5_;
};


static gpointer isi_transport_parent_class = NULL;
extern GIsiCommModemAccess* nokia_isi_isimodem;
static GType isi_transport_type_id = 0;

GType isi_transport_get_type (void) G_GNUC_CONST;
GType isi_transport_register_type (GTypeModule * module);
#define ISI_TRANSPORT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_ISI_TRANSPORT, IsiTransportPrivate))
enum  {
	ISI_TRANSPORT_DUMMY_PROPERTY
};
IsiTransport* isi_transport_new (const gchar* iface);
IsiTransport* isi_transport_construct (GType object_type, const gchar* iface);
static gchar* isi_transport_real_repr (FsoFrameworkBaseTransport* base);
static gboolean isi_transport_real_open (FsoFrameworkTransport* base);
static gboolean isi_transport_real_isOpen (FsoFrameworkTransport* base);
static void isi_transport_real_openAsync_data_free (gpointer _data);
static void isi_transport_real_openAsync (FsoFrameworkTransport* base, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean isi_transport_real_openAsync_co (isi_transport_openAsyncData* _data_);
static void isi_transport_openAsync_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void isi_transport_finalize (GObject* obj);


IsiTransport* isi_transport_construct (GType object_type, const gchar* iface) {
	IsiTransport * self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (iface != NULL, NULL);
	self = (IsiTransport*) fso_framework_null_transport_construct (object_type, "IsiTransport", (guint) 0, TRUE, TRUE);
	_tmp0_ = iface;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->iface);
	self->priv->iface = _tmp1_;
	return self;
}


IsiTransport* isi_transport_new (const gchar* iface) {
	return isi_transport_construct (TYPE_ISI_TRANSPORT, iface);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gchar* isi_transport_real_repr (FsoFrameworkBaseTransport* base) {
	IsiTransport * self;
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_;
	self = (IsiTransport*) base;
	_tmp1_ = self->priv->iface;
	if (_tmp1_ != NULL) {
		const gchar* _tmp2_;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		_tmp2_ = self->priv->iface;
		_tmp3_ = string_to_string (_tmp2_);
		_tmp4_ = g_strconcat ("<", _tmp3_, ">", NULL);
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp4_;
	} else {
		gchar* _tmp5_;
		_tmp5_ = g_strdup ("<unknown>");
		_g_free0 (_tmp0_);
		_tmp0_ = _tmp5_;
	}
	result = _tmp0_;
	return result;
}


static gboolean isi_transport_real_open (FsoFrameworkTransport* base) {
	IsiTransport * self;
	gboolean result = FALSE;
	self = (IsiTransport*) base;
	g_assert_not_reached ();
	return result;
}


static gboolean isi_transport_real_isOpen (FsoFrameworkTransport* base) {
	IsiTransport * self;
	gboolean result = FALSE;
	gboolean _tmp0_;
	self = (IsiTransport*) base;
	_tmp0_ = self->priv->reachable;
	result = _tmp0_;
	return result;
}


static void isi_transport_real_openAsync_data_free (gpointer _data) {
	isi_transport_openAsyncData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (isi_transport_openAsyncData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void isi_transport_real_openAsync (FsoFrameworkTransport* base, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	IsiTransport * self;
	isi_transport_openAsyncData* _data_;
	IsiTransport* _tmp0_;
	self = (IsiTransport*) base;
	_data_ = g_slice_new0 (isi_transport_openAsyncData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, isi_transport_real_openAsync);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, isi_transport_real_openAsync_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	isi_transport_real_openAsync_co (_data_);
}


static gboolean isi_transport_real_openAsync_finish (FsoFrameworkTransport* base, GAsyncResult* _res_) {
	gboolean result;
	isi_transport_openAsyncData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	return result;
}


static void isi_transport_openAsync_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	isi_transport_openAsyncData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	isi_transport_real_openAsync_co (_data_);
}


static gboolean isi_transport_real_openAsync_co (isi_transport_openAsyncData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = nokia_isi_isimodem;
	_data_->_state_ = 1;
	gisi_comm_modem_access_connect (_data_->_tmp0_, isi_transport_openAsync_ready, _data_);
	return FALSE;
	_state_1:
	_data_->_tmp1_ = FALSE;
	_data_->_tmp1_ = gisi_comm_modem_access_connect_finish (_data_->_tmp0_, _data_->_res_);
	if (!_data_->_tmp1_) {
		g_debug ("isitransport.vala:56: ISI PROBLEM in PHASE 1, FAIL");
		_data_->result = FALSE;
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp2_ = nokia_isi_isimodem;
	_data_->_state_ = 2;
	gisi_comm_modem_access_launch (_data_->_tmp2_, isi_transport_openAsync_ready, _data_);
	return FALSE;
	_state_2:
	_data_->_tmp3_ = FALSE;
	_data_->_tmp3_ = gisi_comm_modem_access_launch_finish (_data_->_tmp2_, _data_->_res_);
	if (!_data_->_tmp3_) {
		g_debug ("isitransport.vala:63: ISI PROBLEM in PHASE 2, FAIL");
		_data_->result = FALSE;
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp4_ = nokia_isi_isimodem;
	_data_->_state_ = 3;
	gisi_comm_modem_access_startup (_data_->_tmp4_, isi_transport_openAsync_ready, _data_);
	return FALSE;
	_state_3:
	_data_->_tmp5_ = FALSE;
	_data_->_tmp5_ = gisi_comm_modem_access_startup_finish (_data_->_tmp4_, _data_->_res_);
	if (!_data_->_tmp5_) {
		g_debug ("isitransport.vala:70: ISI PROBLEM in PHASE 3, FAIL");
		_data_->result = FALSE;
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	g_debug ("isitransport.vala:74: ISI OPEN ASYNC OK");
	_data_->result = TRUE;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void isi_transport_class_init (IsiTransportClass * klass) {
	isi_transport_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IsiTransportPrivate));
	FSO_FRAMEWORK_BASE_TRANSPORT_CLASS (klass)->repr = isi_transport_real_repr;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->open = isi_transport_real_open;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->isOpen = isi_transport_real_isOpen;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->openAsync = isi_transport_real_openAsync;
	FSO_FRAMEWORK_TRANSPORT_CLASS (klass)->openAsync_finish = isi_transport_real_openAsync_finish;
	G_OBJECT_CLASS (klass)->finalize = isi_transport_finalize;
}


static void isi_transport_instance_init (IsiTransport * self) {
	self->priv = ISI_TRANSPORT_GET_PRIVATE (self);
	self->priv->reachable = FALSE;
}


static void isi_transport_finalize (GObject* obj) {
	IsiTransport * self;
	self = ISI_TRANSPORT (obj);
	_g_free0 (self->priv->iface);
	G_OBJECT_CLASS (isi_transport_parent_class)->finalize (obj);
}


GType isi_transport_get_type (void) {
	return isi_transport_type_id;
}


GType isi_transport_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (IsiTransportClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) isi_transport_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IsiTransport), 0, (GInstanceInitFunc) isi_transport_instance_init, NULL };
	isi_transport_type_id = g_type_module_register_type (module, FSO_FRAMEWORK_TYPE_NULL_TRANSPORT, "IsiTransport", &g_define_type_info, 0);
	return isi_transport_type_id;
}



