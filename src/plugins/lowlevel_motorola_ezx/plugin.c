/* plugin.c generated by valac 0.14.2, the Vala compiler
 * generated from plugin.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <fsobasics.h>
#include <fsogsm.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <fsoframework.h>


#define LOW_LEVEL_TYPE_MOTOROLA_EZX (low_level_motorola_ezx_get_type ())
#define LOW_LEVEL_MOTOROLA_EZX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LOW_LEVEL_TYPE_MOTOROLA_EZX, LowLevelMotorolaEZX))
#define LOW_LEVEL_MOTOROLA_EZX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), LOW_LEVEL_TYPE_MOTOROLA_EZX, LowLevelMotorolaEZXClass))
#define LOW_LEVEL_IS_MOTOROLA_EZX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LOW_LEVEL_TYPE_MOTOROLA_EZX))
#define LOW_LEVEL_IS_MOTOROLA_EZX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), LOW_LEVEL_TYPE_MOTOROLA_EZX))
#define LOW_LEVEL_MOTOROLA_EZX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), LOW_LEVEL_TYPE_MOTOROLA_EZX, LowLevelMotorolaEZXClass))

typedef struct _LowLevelMotorolaEZX LowLevelMotorolaEZX;
typedef struct _LowLevelMotorolaEZXClass LowLevelMotorolaEZXClass;
typedef struct _LowLevelMotorolaEZXPrivate LowLevelMotorolaEZXPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _LowLevelMotorolaEZX {
	FsoFrameworkAbstractObject parent_instance;
	LowLevelMotorolaEZXPrivate * priv;
};

struct _LowLevelMotorolaEZXClass {
	FsoFrameworkAbstractObjectClass parent_class;
};

struct _LowLevelMotorolaEZXPrivate {
	FsoGsmAbstractModem* modem;
	gint muxfds[16];
};


static gpointer low_level_motorola_ezx_parent_class = NULL;
static gboolean low_level_motorola_ezx_initDone;
static gboolean low_level_motorola_ezx_initDone = FALSE;
static FsoGsmLowLevelIface* low_level_motorola_ezx_fso_gsm_low_level_parent_iface = NULL;
static GType low_level_motorola_ezx_type_id = 0;

GType low_level_motorola_ezx_get_type (void) G_GNUC_CONST;
GType low_level_motorola_ezx_register_type (GTypeModule * module);
#define LOW_LEVEL_MOTOROLA_EZX_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), LOW_LEVEL_TYPE_MOTOROLA_EZX, LowLevelMotorolaEZXPrivate))
enum  {
	LOW_LEVEL_MOTOROLA_EZX_DUMMY_PROPERTY
};
#define LOW_LEVEL_MOTOROLA_EZX_MODULE_NAME "fsogsm.lowlevel_motorola_ezx"
static gchar* low_level_motorola_ezx_real_repr (FsoFrameworkAbstractObject* base);
static gboolean low_level_motorola_ezx_modem_init (LowLevelMotorolaEZX* self);
static gboolean low_level_motorola_ezx_real_poweron (FsoGsmLowLevel* base);
static gboolean low_level_motorola_ezx_real_poweroff (FsoGsmLowLevel* base);
static gboolean low_level_motorola_ezx_real_suspend (FsoGsmLowLevel* base);
static gboolean low_level_motorola_ezx_real_resume (FsoGsmLowLevel* base);
LowLevelMotorolaEZX* low_level_motorola_ezx_new (void);
LowLevelMotorolaEZX* low_level_motorola_ezx_construct (GType object_type);
static GObject * low_level_motorola_ezx_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void low_level_motorola_ezx_finalize (GObject* obj);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static gchar* low_level_motorola_ezx_real_repr (FsoFrameworkAbstractObject* base) {
	LowLevelMotorolaEZX * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (LowLevelMotorolaEZX*) base;
	_tmp0_ = g_strdup ("<>");
	result = _tmp0_;
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean low_level_motorola_ezx_modem_init (LowLevelMotorolaEZX* self) {
	gboolean result = FALSE;
	gint count_retries;
	FsoFrameworkLogger* _tmp0_;
	FsoFrameworkSmartKeyFile* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* modem_node;
	gint ipc;
	gint _tmp30_;
	FsoFrameworkSmartKeyFile* _tmp41_;
	gchar* _tmp42_ = NULL;
	gchar* _tmp43_;
	gint _tmp44_ = 0;
	guint _tmp45_;
	guint line;
	FsoFrameworkLogger* _tmp46_;
	guint _tmp47_;
	gchar* _tmp48_ = NULL;
	gchar* _tmp49_;
	gchar* _tmp50_ = NULL;
	gchar* _tmp51_;
	guint ret = 0U;
	gint _tmp52_;
	gint _tmp53_ = 0;
	guint _tmp54_;
	FsoFrameworkSmartKeyFile* _tmp63_;
	gchar* _tmp64_ = NULL;
	gchar* muxnode_prefix;
	FsoFrameworkSmartKeyFile* _tmp65_;
	gint _tmp66_ = 0;
	gchar** _tmp67_ = NULL;
	gchar** dlci_lines;
	gint dlci_lines_length1;
	gint _dlci_lines_size_;
	gchar* devpath = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	count_retries = 10;
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_debug (_tmp0_, "********************** Modem init **********************");
	system ("modprobe ohci-hcd");
	sleep ((guint) 2);
	system ("modprobe moto-usb-ipc");
	system ("modprobe ts27010mux");
	_tmp1_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp2_ = fso_framework_smart_key_file_stringValue (_tmp1_, LOW_LEVEL_MOTOROLA_EZX_MODULE_NAME, "modem_node", "");
	modem_node = _tmp2_;
	ipc = -1;
	{
		gboolean _tmp3_;
		_tmp3_ = TRUE;
		while (TRUE) {
			gboolean _tmp4_;
			FsoFrameworkLogger* _tmp12_;
			const gchar* _tmp13_;
			const gchar* _tmp14_ = NULL;
			gchar* _tmp15_ = NULL;
			gchar* _tmp16_;
			const gchar* _tmp17_;
			gint _tmp18_ = 0;
			gint _tmp19_;
			gint _tmp29_;
			_tmp4_ = _tmp3_;
			if (!_tmp4_) {
				gboolean _tmp5_ = FALSE;
				gboolean _tmp6_ = FALSE;
				gint _tmp7_;
				gboolean _tmp9_;
				gboolean _tmp11_;
				_tmp7_ = ipc;
				if (_tmp7_ < 0) {
					gint _tmp8_;
					_tmp8_ = errno;
					_tmp6_ = _tmp8_ == ENODEV;
				} else {
					_tmp6_ = FALSE;
				}
				_tmp9_ = _tmp6_;
				if (_tmp9_) {
					gint _tmp10_;
					_tmp10_ = count_retries;
					_tmp5_ = _tmp10_ >= 0;
				} else {
					_tmp5_ = FALSE;
				}
				_tmp11_ = _tmp5_;
				if (!_tmp11_) {
					break;
				}
			}
			_tmp3_ = FALSE;
			_tmp12_ = ((FsoFrameworkAbstractObject*) self)->logger;
			_tmp13_ = modem_node;
			_tmp14_ = string_to_string (_tmp13_);
			_tmp15_ = g_strconcat ("Trying to open ", _tmp14_, "...", NULL);
			_tmp16_ = _tmp15_;
			fso_framework_logger_debug (_tmp12_, _tmp16_);
			_g_free0 (_tmp16_);
			_tmp17_ = modem_node;
			_tmp18_ = open (_tmp17_, O_RDWR, (mode_t) 0);
			ipc = _tmp18_;
			_tmp19_ = ipc;
			if (_tmp19_ < 0) {
				FsoFrameworkLogger* _tmp20_;
				gint _tmp21_;
				gchar* _tmp22_ = NULL;
				gchar* _tmp23_;
				gint _tmp24_;
				gchar* _tmp25_ = NULL;
				gchar* _tmp26_;
				gchar* _tmp27_ = NULL;
				gchar* _tmp28_;
				_tmp20_ = ((FsoFrameworkAbstractObject*) self)->logger;
				_tmp21_ = ipc;
				_tmp22_ = g_strdup_printf ("%i", _tmp21_);
				_tmp23_ = _tmp22_;
				_tmp24_ = count_retries;
				_tmp25_ = g_strdup_printf ("%i", _tmp24_);
				_tmp26_ = _tmp25_;
				_tmp27_ = g_strconcat ("Error ", _tmp23_, " ... retrying ( ", _tmp26_, " )", NULL);
				_tmp28_ = _tmp27_;
				fso_framework_logger_debug (_tmp20_, _tmp28_);
				_g_free0 (_tmp28_);
				_g_free0 (_tmp26_);
				_g_free0 (_tmp23_);
				sleep ((guint) 1);
			}
			_tmp29_ = count_retries;
			count_retries = _tmp29_ - 1;
		}
	}
	_tmp30_ = ipc;
	if (_tmp30_ < 0) {
		gint _tmp31_;
		const gchar* _tmp32_ = NULL;
		gchar* _tmp33_;
		gchar* message;
		FsoFrameworkLogger* _tmp34_;
		const gchar* _tmp35_;
		const gchar* _tmp36_ = NULL;
		const gchar* _tmp37_;
		const gchar* _tmp38_ = NULL;
		gchar* _tmp39_ = NULL;
		gchar* _tmp40_;
		_tmp31_ = errno;
		_tmp32_ = strerror (_tmp31_);
		_tmp33_ = g_strdup (_tmp32_);
		message = _tmp33_;
		_tmp34_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp35_ = modem_node;
		_tmp36_ = string_to_string (_tmp35_);
		_tmp37_ = message;
		_tmp38_ = string_to_string (_tmp37_);
		_tmp39_ = g_strconcat (_tmp36_, ": ", _tmp38_, NULL);
		_tmp40_ = _tmp39_;
		fso_framework_logger_debug (_tmp34_, _tmp40_);
		_g_free0 (_tmp40_);
		result = FALSE;
		_g_free0 (message);
		_g_free0 (modem_node);
		return result;
	}
	_tmp41_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp42_ = fso_framework_smart_key_file_stringValue (_tmp41_, LOW_LEVEL_MOTOROLA_EZX_MODULE_NAME, "gsm_ldisc", "");
	_tmp43_ = _tmp42_;
	_tmp44_ = atoi (_tmp43_);
	_tmp45_ = (guint) _tmp44_;
	_g_free0 (_tmp43_);
	line = _tmp45_;
	_tmp46_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp47_ = line;
	_tmp48_ = g_strdup_printf ("%u", _tmp47_);
	_tmp49_ = _tmp48_;
	_tmp50_ = g_strconcat ("Setting ldisc ", _tmp49_, "...", NULL);
	_tmp51_ = _tmp50_;
	fso_framework_logger_debug (_tmp46_, _tmp51_);
	_g_free0 (_tmp51_);
	_g_free0 (_tmp49_);
	_tmp52_ = ipc;
	_tmp53_ = ioctl (_tmp52_, TIOCSETD, &line);
	ret = (guint) _tmp53_;
	_tmp54_ = ret;
	if (_tmp54_ < ((guint) 0)) {
		gint _tmp55_;
		const gchar* _tmp56_ = NULL;
		gchar* _tmp57_;
		gchar* message;
		FsoFrameworkLogger* _tmp58_;
		const gchar* _tmp59_;
		const gchar* _tmp60_ = NULL;
		gchar* _tmp61_ = NULL;
		gchar* _tmp62_;
		_tmp55_ = errno;
		_tmp56_ = strerror (_tmp55_);
		_tmp57_ = g_strdup (_tmp56_);
		message = _tmp57_;
		_tmp58_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp59_ = message;
		_tmp60_ = string_to_string (_tmp59_);
		_tmp61_ = g_strconcat ("ioctl: ", _tmp60_, NULL);
		_tmp62_ = _tmp61_;
		fso_framework_logger_debug (_tmp58_, _tmp62_);
		_g_free0 (_tmp62_);
		result = FALSE;
		_g_free0 (message);
		_g_free0 (modem_node);
		return result;
	}
	_tmp63_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp64_ = fso_framework_smart_key_file_stringValue (_tmp63_, LOW_LEVEL_MOTOROLA_EZX_MODULE_NAME, "muxnode_prefix", "");
	muxnode_prefix = _tmp64_;
	_tmp65_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp67_ = fso_framework_smart_key_file_stringListValue (_tmp65_, LOW_LEVEL_MOTOROLA_EZX_MODULE_NAME, "dlci_lines", NULL, 0, &_tmp66_);
	dlci_lines = _tmp67_;
	dlci_lines_length1 = _tmp66_;
	_dlci_lines_size_ = dlci_lines_length1;
	{
		guint i;
		i = (guint) 0;
		{
			gboolean _tmp68_;
			_tmp68_ = TRUE;
			while (TRUE) {
				gboolean _tmp69_;
				guint _tmp71_;
				gchar** _tmp72_;
				gint _tmp72__length1;
				const gchar* _tmp73_;
				gchar** _tmp74_;
				gint _tmp74__length1;
				guint _tmp75_;
				const gchar* _tmp76_;
				gchar* _tmp77_;
				FsoFrameworkLogger* _tmp78_;
				const gchar* _tmp79_;
				const gchar* _tmp80_ = NULL;
				gchar* _tmp81_ = NULL;
				gchar* _tmp82_;
				guint _tmp83_;
				const gchar* _tmp84_;
				gint _tmp85_ = 0;
				gint _tmp86_;
				guint _tmp87_;
				gint _tmp88_;
				_tmp69_ = _tmp68_;
				if (!_tmp69_) {
					guint _tmp70_;
					_tmp70_ = i;
					i = _tmp70_ + 1;
				}
				_tmp68_ = FALSE;
				_tmp71_ = i;
				_tmp72_ = dlci_lines;
				_tmp72__length1 = dlci_lines_length1;
				if (!(_tmp71_ < ((guint) _tmp72__length1))) {
					break;
				}
				_tmp73_ = muxnode_prefix;
				_tmp74_ = dlci_lines;
				_tmp74__length1 = dlci_lines_length1;
				_tmp75_ = i;
				_tmp76_ = _tmp74_[_tmp75_];
				_tmp77_ = g_strconcat (_tmp73_, _tmp76_, NULL);
				_g_free0 (devpath);
				devpath = _tmp77_;
				_tmp78_ = ((FsoFrameworkAbstractObject*) self)->logger;
				_tmp79_ = devpath;
				_tmp80_ = string_to_string (_tmp79_);
				_tmp81_ = g_strconcat ("Trying to open ", _tmp80_, " ...", NULL);
				_tmp82_ = _tmp81_;
				fso_framework_logger_debug (_tmp78_, _tmp82_);
				_g_free0 (_tmp82_);
				_tmp83_ = i;
				_tmp84_ = devpath;
				_tmp85_ = open (_tmp84_, O_RDWR | O_NOCTTY, (mode_t) 0);
				self->priv->muxfds[_tmp83_] = _tmp85_;
				_tmp86_ = self->priv->muxfds[_tmp83_];
				_tmp87_ = i;
				_tmp88_ = self->priv->muxfds[_tmp87_];
				if (_tmp88_ < 0) {
					gint _tmp89_;
					const gchar* _tmp90_ = NULL;
					gchar* _tmp91_;
					gchar* message;
					FsoFrameworkLogger* _tmp92_;
					const gchar* _tmp93_;
					const gchar* _tmp94_ = NULL;
					const gchar* _tmp95_;
					const gchar* _tmp96_ = NULL;
					gchar* _tmp97_ = NULL;
					gchar* _tmp98_;
					_tmp89_ = errno;
					_tmp90_ = strerror (_tmp89_);
					_tmp91_ = g_strdup (_tmp90_);
					message = _tmp91_;
					_tmp92_ = ((FsoFrameworkAbstractObject*) self)->logger;
					_tmp93_ = devpath;
					_tmp94_ = string_to_string (_tmp93_);
					_tmp95_ = message;
					_tmp96_ = string_to_string (_tmp95_);
					_tmp97_ = g_strconcat (_tmp94_, " : ", _tmp96_, NULL);
					_tmp98_ = _tmp97_;
					fso_framework_logger_debug (_tmp92_, _tmp98_);
					_g_free0 (_tmp98_);
					_g_free0 (message);
				} else {
					FsoFrameworkLogger* _tmp99_;
					const gchar* _tmp100_;
					const gchar* _tmp101_ = NULL;
					gchar* _tmp102_ = NULL;
					gchar* _tmp103_;
					_tmp99_ = ((FsoFrameworkAbstractObject*) self)->logger;
					_tmp100_ = devpath;
					_tmp101_ = string_to_string (_tmp100_);
					_tmp102_ = g_strconcat (_tmp101_, " opened.", NULL);
					_tmp103_ = _tmp102_;
					fso_framework_logger_debug (_tmp99_, _tmp103_);
					_g_free0 (_tmp103_);
				}
			}
		}
	}
	result = TRUE;
	_g_free0 (devpath);
	dlci_lines = (_vala_array_free (dlci_lines, dlci_lines_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (muxnode_prefix);
	_g_free0 (modem_node);
	return result;
}


static gboolean low_level_motorola_ezx_real_poweron (FsoGsmLowLevel* base) {
	LowLevelMotorolaEZX * self;
	gboolean result = FALSE;
	FsoFrameworkLogger* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean ret;
	self = (LowLevelMotorolaEZX*) base;
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_debug (_tmp0_, "lowlevel_motorola_ezx_poweron()");
	_tmp1_ = low_level_motorola_ezx_initDone;
	if (_tmp1_ == TRUE) {
		result = TRUE;
		return result;
	}
	_tmp2_ = low_level_motorola_ezx_modem_init (self);
	ret = _tmp2_;
	low_level_motorola_ezx_initDone = TRUE;
	result = ret;
	return result;
}


static gboolean low_level_motorola_ezx_real_poweroff (FsoGsmLowLevel* base) {
	LowLevelMotorolaEZX * self;
	gboolean result = FALSE;
	FsoFrameworkLogger* _tmp0_;
	self = (LowLevelMotorolaEZX*) base;
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_debug (_tmp0_, "lowlevel_motorola_ezx_poweroff()");
	result = TRUE;
	return result;
}


static gboolean low_level_motorola_ezx_real_suspend (FsoGsmLowLevel* base) {
	LowLevelMotorolaEZX * self;
	gboolean result = FALSE;
	self = (LowLevelMotorolaEZX*) base;
	g_debug ("plugin.vala:120: lowlevel_motorola_ezx_suspend()");
	result = TRUE;
	return result;
}


static gboolean low_level_motorola_ezx_real_resume (FsoGsmLowLevel* base) {
	LowLevelMotorolaEZX * self;
	gboolean result = FALSE;
	self = (LowLevelMotorolaEZX*) base;
	g_debug ("plugin.vala:126: lowlevel_motorola_ezx_resume()");
	result = TRUE;
	return result;
}


LowLevelMotorolaEZX* low_level_motorola_ezx_construct (GType object_type) {
	LowLevelMotorolaEZX * self = NULL;
	self = (LowLevelMotorolaEZX*) fso_framework_abstract_object_construct (object_type);
	return self;
}


LowLevelMotorolaEZX* low_level_motorola_ezx_new (void) {
	return low_level_motorola_ezx_construct (LOW_LEVEL_TYPE_MOTOROLA_EZX);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static GObject * low_level_motorola_ezx_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	LowLevelMotorolaEZX * self;
	FsoGsmModem* _tmp0_;
	FsoGsmAbstractModem* _tmp1_;
	FsoFrameworkLogger* _tmp2_;
	parent_class = G_OBJECT_CLASS (low_level_motorola_ezx_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = LOW_LEVEL_MOTOROLA_EZX (obj);
	_tmp0_ = fso_gsm_theModem;
	_tmp1_ = _g_object_ref0 (FSO_GSM_IS_ABSTRACT_MODEM (_tmp0_) ? ((FsoGsmAbstractModem*) _tmp0_) : NULL);
	_g_object_unref0 (self->priv->modem);
	self->priv->modem = _tmp1_;
	_tmp2_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_info (_tmp2_, "Registering Motorola EZX low level poweron/poweroff handling");
	return obj;
}


static void low_level_motorola_ezx_class_init (LowLevelMotorolaEZXClass * klass) {
	low_level_motorola_ezx_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (LowLevelMotorolaEZXPrivate));
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = low_level_motorola_ezx_real_repr;
	G_OBJECT_CLASS (klass)->constructor = low_level_motorola_ezx_constructor;
	G_OBJECT_CLASS (klass)->finalize = low_level_motorola_ezx_finalize;
}


static void low_level_motorola_ezx_fso_gsm_low_level_interface_init (FsoGsmLowLevelIface * iface) {
	low_level_motorola_ezx_fso_gsm_low_level_parent_iface = g_type_interface_peek_parent (iface);
	iface->poweron = (gboolean (*)(FsoGsmLowLevel*)) low_level_motorola_ezx_real_poweron;
	iface->poweroff = (gboolean (*)(FsoGsmLowLevel*)) low_level_motorola_ezx_real_poweroff;
	iface->suspend = (gboolean (*)(FsoGsmLowLevel*)) low_level_motorola_ezx_real_suspend;
	iface->resume = (gboolean (*)(FsoGsmLowLevel*)) low_level_motorola_ezx_real_resume;
}


static void low_level_motorola_ezx_instance_init (LowLevelMotorolaEZX * self) {
	self->priv = LOW_LEVEL_MOTOROLA_EZX_GET_PRIVATE (self);
}


static void low_level_motorola_ezx_finalize (GObject* obj) {
	LowLevelMotorolaEZX * self;
	self = LOW_LEVEL_MOTOROLA_EZX (obj);
	_g_object_unref0 (self->priv->modem);
	G_OBJECT_CLASS (low_level_motorola_ezx_parent_class)->finalize (obj);
}


/**
 * Copyright (C) 2010  Antonio Ospite <ospite@studenti.unina.it>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */
GType low_level_motorola_ezx_get_type (void) {
	return low_level_motorola_ezx_type_id;
}


GType low_level_motorola_ezx_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (LowLevelMotorolaEZXClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) low_level_motorola_ezx_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LowLevelMotorolaEZX), 0, (GInstanceInitFunc) low_level_motorola_ezx_instance_init, NULL };
	static const GInterfaceInfo fso_gsm_low_level_info = { (GInterfaceInitFunc) low_level_motorola_ezx_fso_gsm_low_level_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	low_level_motorola_ezx_type_id = g_type_module_register_type (module, FSO_FRAMEWORK_TYPE_ABSTRACT_OBJECT, "LowLevelMotorolaEZX", &g_define_type_info, 0);
	g_type_module_add_interface (module, low_level_motorola_ezx_type_id, FSO_GSM_TYPE_LOW_LEVEL, &fso_gsm_low_level_info);
	return low_level_motorola_ezx_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	FsoFrameworkLogger* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "lowlevel_motorola_ezx fso_factory_function");
	_tmp1_ = g_strdup (LOW_LEVEL_MOTOROLA_EZX_MODULE_NAME);
	result = _tmp1_;
	return result;
}


void fso_register_function (GTypeModule* module) {
	g_return_if_fail (module != NULL);
	low_level_motorola_ezx_register_type (module);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



