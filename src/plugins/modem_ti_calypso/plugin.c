/* plugin.c generated by valac 0.14.2, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * Copyright (C) 2009-2011 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsogsm.h>
#include <gee.h>
#include <fsobasics.h>
#include <fsotransport.h>
#include <fsoframework.h>


#define TI_CALYPSO_TYPE_MODEM (ti_calypso_modem_get_type ())
#define TI_CALYPSO_MODEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TI_CALYPSO_TYPE_MODEM, TiCalypsoModem))
#define TI_CALYPSO_MODEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TI_CALYPSO_TYPE_MODEM, TiCalypsoModemClass))
#define TI_CALYPSO_IS_MODEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TI_CALYPSO_TYPE_MODEM))
#define TI_CALYPSO_IS_MODEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TI_CALYPSO_TYPE_MODEM))
#define TI_CALYPSO_MODEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TI_CALYPSO_TYPE_MODEM, TiCalypsoModemClass))

typedef struct _TiCalypsoModem TiCalypsoModem;
typedef struct _TiCalypsoModemClass TiCalypsoModemClass;
typedef struct _TiCalypsoModemPrivate TiCalypsoModemPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _fso_gsm_at_command_sequence_unref0(var) ((var == NULL) ? NULL : (var = (fso_gsm_at_command_sequence_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TI_CALYPSO_TYPE_UNSOLICITED_RESPONSE_HANDLER (ti_calypso_unsolicited_response_handler_get_type ())
#define TI_CALYPSO_UNSOLICITED_RESPONSE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TI_CALYPSO_TYPE_UNSOLICITED_RESPONSE_HANDLER, TiCalypsoUnsolicitedResponseHandler))
#define TI_CALYPSO_UNSOLICITED_RESPONSE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TI_CALYPSO_TYPE_UNSOLICITED_RESPONSE_HANDLER, TiCalypsoUnsolicitedResponseHandlerClass))
#define TI_CALYPSO_IS_UNSOLICITED_RESPONSE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TI_CALYPSO_TYPE_UNSOLICITED_RESPONSE_HANDLER))
#define TI_CALYPSO_IS_UNSOLICITED_RESPONSE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TI_CALYPSO_TYPE_UNSOLICITED_RESPONSE_HANDLER))
#define TI_CALYPSO_UNSOLICITED_RESPONSE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TI_CALYPSO_TYPE_UNSOLICITED_RESPONSE_HANDLER, TiCalypsoUnsolicitedResponseHandlerClass))

typedef struct _TiCalypsoUnsolicitedResponseHandler TiCalypsoUnsolicitedResponseHandler;
typedef struct _TiCalypsoUnsolicitedResponseHandlerClass TiCalypsoUnsolicitedResponseHandlerClass;

struct _TiCalypsoModem {
	FsoGsmAbstractModem parent_instance;
	TiCalypsoModemPrivate * priv;
	gchar* dspCommand;
};

struct _TiCalypsoModemClass {
	FsoGsmAbstractModemClass parent_class;
};


static gpointer ti_calypso_modem_parent_class = NULL;
static GType ti_calypso_modem_type_id = 0;

#define TI_CALYPSO_MODULE_NAME "fsogsm.modem_ti_calypso"
GType ti_calypso_modem_get_type (void) G_GNUC_CONST;
GType ti_calypso_modem_register_type (GTypeModule * module);
enum  {
	TI_CALYPSO_MODEM_DUMMY_PROPERTY
};
static gchar* ti_calypso_modem_real_repr (FsoFrameworkAbstractObject* base);
static void ti_calypso_modem_real_configureData (FsoGsmAbstractModem* base);
static void ti_calypso_modem_real_createChannels (FsoGsmAbstractModem* base);
static void ti_calypso_modem_real_registerCustomMediators (FsoGsmAbstractModem* base, GeeHashMap* mediators);
void ti_calypso_registerCustomMediators (GeeHashMap* table);
static void ti_calypso_modem_real_registerCustomAtCommands (FsoGsmAbstractModem* base, GeeHashMap* commands);
void ti_calypso_registerCustomAtCommands (GeeHashMap* table);
static FsoGsmUnsolicitedResponseHandler* ti_calypso_modem_real_createUnsolicitedHandler (FsoGsmAbstractModem* base);
TiCalypsoUnsolicitedResponseHandler* ti_calypso_unsolicited_response_handler_new (void);
TiCalypsoUnsolicitedResponseHandler* ti_calypso_unsolicited_response_handler_construct (GType object_type);
GType ti_calypso_unsolicited_response_handler_get_type (void) G_GNUC_CONST;
GType ti_calypso_unsolicited_response_handler_register_type (GTypeModule * module);
static FsoGsmChannel* ti_calypso_modem_real_channelForCommand (FsoGsmAbstractModem* base, FsoGsmAtCommand* command, const gchar* query);
static gchar* ti_calypso_modem_real_allocateDataPort (FsoGsmAbstractModem* base);
TiCalypsoModem* ti_calypso_modem_new (void);
TiCalypsoModem* ti_calypso_modem_construct (GType object_type);
static GObject * ti_calypso_modem_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void ti_calypso_modem_finalize (GObject* obj);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

const gchar* TI_CALYPSO_CHANNEL_NAMES[4] = {"call", "main", "urc", "data"};

static gchar* ti_calypso_modem_real_repr (FsoFrameworkAbstractObject* base) {
	TiCalypsoModem * self;
	gchar* result = NULL;
	GeeHashMap* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	self = (TiCalypsoModem*) base;
	_tmp0_ = ((FsoGsmAbstractModem*) self)->channels;
	_tmp1_ = gee_abstract_map_get_size ((GeeMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("%i", _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat ("<", _tmp4_, "C>", NULL);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	result = _tmp6_;
	return result;
}


static void ti_calypso_modem_real_configureData (FsoGsmAbstractModem* base) {
	TiCalypsoModem * self;
	FsoGsmModemData* _tmp0_;
	FsoGsmModemData* _tmp1_;
	FsoGsmModemData* _tmp2_;
	FsoGsmModemData* _tmp3_;
	gchar* _tmp4_;
	FsoFrameworkSmartKeyFile* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* deep_sleep;
	const gchar* _tmp7_;
	FsoGsmModem* _tmp20_;
	FsoGsmAtCommandSequence* _tmp21_ = NULL;
	FsoGsmAtCommandSequence* _tmp22_;
	gchar* _tmp23_;
	gchar** _tmp24_ = NULL;
	gchar** _tmp25_;
	gint _tmp25__length1;
	gchar* _tmp26_;
	gchar* _tmp27_;
	gchar* _tmp28_;
	gchar* _tmp29_;
	gchar* _tmp30_;
	gchar** _tmp31_ = NULL;
	gchar** _tmp32_;
	gint _tmp32__length1;
	FsoGsmAtCommandSequence* _tmp33_;
	FsoGsmAtCommandSequence* _tmp34_;
	gchar* _tmp35_;
	gchar** _tmp36_ = NULL;
	gchar** _tmp37_;
	gint _tmp37__length1;
	FsoGsmAtCommandSequence* _tmp38_;
	FsoGsmAtCommandSequence* _tmp39_;
	gchar* _tmp40_;
	gchar* _tmp41_;
	gchar* _tmp42_;
	gchar* _tmp43_;
	gchar* _tmp44_;
	gchar* _tmp45_;
	gchar* _tmp46_;
	gchar* _tmp47_;
	gchar* _tmp48_;
	gchar* _tmp49_;
	gchar* _tmp50_;
	gchar* _tmp51_;
	gchar* _tmp52_;
	gchar* _tmp53_;
	gchar* _tmp54_;
	gchar* _tmp55_;
	gchar* _tmp56_;
	gchar* _tmp57_;
	gchar* _tmp58_;
	gchar* _tmp59_;
	gchar** _tmp60_ = NULL;
	gchar** _tmp61_;
	gint _tmp61__length1;
	FsoGsmAtCommandSequence* _tmp62_;
	FsoGsmAtCommandSequence* _tmp63_;
	const gchar* _tmp64_ = NULL;
	FsoGsmModemData* _tmp65_;
	gboolean _tmp66_;
	const gchar* _tmp67_;
	gchar* _tmp68_;
	gchar* cnmiCommand;
	gchar* _tmp69_;
	gchar* _tmp70_;
	gchar* _tmp71_;
	gchar** _tmp72_ = NULL;
	gchar** _tmp73_;
	gint _tmp73__length1;
	FsoGsmAtCommandSequence* _tmp74_;
	FsoGsmAtCommandSequence* _tmp75_;
	gchar* _tmp76_;
	gchar* _tmp77_;
	gchar* _tmp78_;
	gchar* _tmp79_;
	gchar* _tmp80_;
	gchar* _tmp81_;
	gchar* _tmp82_;
	gchar* _tmp83_;
	gchar* _tmp84_;
	gchar* _tmp85_;
	gchar** _tmp86_ = NULL;
	gchar** _tmp87_;
	gint _tmp87__length1;
	FsoGsmAtCommandSequence* _tmp88_;
	FsoGsmAtCommandSequence* _tmp89_;
	gchar* _tmp90_;
	gchar* _tmp91_;
	gchar* _tmp92_;
	gchar* _tmp93_;
	gchar* _tmp94_;
	gchar* _tmp95_;
	gchar* _tmp96_;
	gchar* _tmp97_;
	gchar* _tmp98_;
	gchar** _tmp99_ = NULL;
	gchar** _tmp100_;
	gint _tmp100__length1;
	FsoGsmAtCommandSequence* _tmp101_;
	FsoGsmAtCommandSequence* _tmp102_;
	FsoGsmModemData* _tmp103_;
	FsoFrameworkSmartKeyFile* _tmp104_;
	gchar* _tmp105_;
	gchar* _tmp106_;
	gchar* _tmp107_;
	gchar* _tmp108_;
	gchar* _tmp109_;
	gchar* _tmp110_;
	gchar* _tmp111_;
	gchar* _tmp112_;
	gchar* _tmp113_;
	gchar* _tmp114_;
	gchar* _tmp115_;
	gchar* _tmp116_;
	gchar* _tmp117_;
	gchar* _tmp118_;
	gchar* _tmp119_;
	gchar* _tmp120_;
	gchar* _tmp121_;
	gchar** _tmp122_ = NULL;
	gchar** _tmp123_;
	gint _tmp123__length1;
	gint _tmp124_ = 0;
	gchar** _tmp125_ = NULL;
	self = (TiCalypsoModem*) base;
	_tmp0_ = ((FsoGsmAbstractModem*) self)->modem_data;
	g_assert (_tmp0_ != NULL);
	_tmp1_ = ((FsoGsmAbstractModem*) self)->modem_data;
	_tmp1_->simHasReadySignal = TRUE;
	_tmp2_ = ((FsoGsmAbstractModem*) self)->modem_data;
	_tmp2_->simReadyTimeout = (guint) 60;
	_tmp3_ = ((FsoGsmAbstractModem*) self)->modem_data;
	_tmp4_ = g_strdup ("%CHLD=i");
	_g_free0 (_tmp3_->atCommandCancelOutgoing);
	_tmp3_->atCommandCancelOutgoing = _tmp4_;
	_tmp5_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp6_ = fso_framework_smart_key_file_stringValue (_tmp5_, TI_CALYPSO_MODULE_NAME, "deep_sleep", "never");
	deep_sleep = _tmp6_;
	_tmp7_ = deep_sleep;
	if (g_strcmp0 (_tmp7_, "always") == 0) {
		FsoGsmModem* _tmp8_;
		FsoGsmAtCommandSequence* _tmp9_ = NULL;
		FsoGsmAtCommandSequence* _tmp10_;
		gchar* _tmp11_;
		gchar** _tmp12_ = NULL;
		gchar** _tmp13_;
		gint _tmp13__length1;
		_tmp8_ = fso_gsm_theModem;
		_tmp9_ = fso_gsm_modem_atCommandSequence (_tmp8_, "MODEM", "init");
		_tmp10_ = _tmp9_;
		_tmp11_ = g_strdup ("%SLEEP=4");
		_tmp12_ = g_new0 (gchar*, 1 + 1);
		_tmp12_[0] = _tmp11_;
		_tmp13_ = _tmp12_;
		_tmp13__length1 = 1;
		fso_gsm_at_command_sequence_append (_tmp10_, _tmp13_, 1);
		_tmp13_ = (_vala_array_free (_tmp13_, _tmp13__length1, (GDestroyNotify) g_free), NULL);
		_fso_gsm_at_command_sequence_unref0 (_tmp10_);
	} else {
		FsoGsmModem* _tmp14_;
		FsoGsmAtCommandSequence* _tmp15_ = NULL;
		FsoGsmAtCommandSequence* _tmp16_;
		gchar* _tmp17_;
		gchar** _tmp18_ = NULL;
		gchar** _tmp19_;
		gint _tmp19__length1;
		_tmp14_ = fso_gsm_theModem;
		_tmp15_ = fso_gsm_modem_atCommandSequence (_tmp14_, "MODEM", "init");
		_tmp16_ = _tmp15_;
		_tmp17_ = g_strdup ("%SLEEP=2");
		_tmp18_ = g_new0 (gchar*, 1 + 1);
		_tmp18_[0] = _tmp17_;
		_tmp19_ = _tmp18_;
		_tmp19__length1 = 1;
		fso_gsm_at_command_sequence_append (_tmp16_, _tmp19_, 1);
		_tmp19_ = (_vala_array_free (_tmp19_, _tmp19__length1, (GDestroyNotify) g_free), NULL);
		_fso_gsm_at_command_sequence_unref0 (_tmp16_);
	}
	_tmp20_ = fso_gsm_theModem;
	_tmp21_ = fso_gsm_modem_atCommandSequence (_tmp20_, "MODEM", "shutdown");
	_tmp22_ = _tmp21_;
	_tmp23_ = g_strdup ("@POFF");
	_tmp24_ = g_new0 (gchar*, 1 + 1);
	_tmp24_[0] = _tmp23_;
	_tmp25_ = _tmp24_;
	_tmp25__length1 = 1;
	fso_gsm_at_command_sequence_append (_tmp22_, _tmp25_, 1);
	_tmp25_ = (_vala_array_free (_tmp25_, _tmp25__length1, (GDestroyNotify) g_free), NULL);
	_fso_gsm_at_command_sequence_unref0 (_tmp22_);
	_tmp26_ = g_strdup ("E0Q0V1");
	_tmp27_ = g_strdup ("%CUNS=2");
	_tmp28_ = g_strdup ("+CMEE=1");
	_tmp29_ = g_strdup ("+CRC=1");
	_tmp30_ = g_strdup ("+CSNS=0");
	_tmp31_ = g_new0 (gchar*, 5 + 1);
	_tmp31_[0] = _tmp26_;
	_tmp31_[1] = _tmp27_;
	_tmp31_[2] = _tmp28_;
	_tmp31_[3] = _tmp29_;
	_tmp31_[4] = _tmp30_;
	_tmp32_ = _tmp31_;
	_tmp32__length1 = 5;
	_tmp33_ = fso_gsm_at_command_sequence_new (_tmp32_, 5);
	_tmp34_ = _tmp33_;
	fso_gsm_modem_registerAtCommandSequence ((FsoGsmModem*) self, "CHANNEL", "init", _tmp34_);
	_fso_gsm_at_command_sequence_unref0 (_tmp34_);
	_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
	_tmp35_ = g_strdup ("+CFUN=1");
	_tmp36_ = g_new0 (gchar*, 1 + 1);
	_tmp36_[0] = _tmp35_;
	_tmp37_ = _tmp36_;
	_tmp37__length1 = 1;
	_tmp38_ = fso_gsm_at_command_sequence_new (_tmp37_, 1);
	_tmp39_ = _tmp38_;
	fso_gsm_modem_registerAtCommandSequence ((FsoGsmModem*) self, "main", "init", _tmp39_);
	_fso_gsm_at_command_sequence_unref0 (_tmp39_);
	_tmp37_ = (_vala_array_free (_tmp37_, _tmp37__length1, (GDestroyNotify) g_free), NULL);
	_tmp40_ = g_strdup ("+CGEREP=2,1");
	_tmp41_ = g_strdup ("+CGREG=2");
	_tmp42_ = g_strdup ("+CLIP=1");
	_tmp43_ = g_strdup ("+CREG=2");
	_tmp44_ = g_strdup ("+COLP=0");
	_tmp45_ = g_strdup ("+CSSN=1,1");
	_tmp46_ = g_strdup ("+CTZU=1");
	_tmp47_ = g_strdup ("+CTZR=1");
	_tmp48_ = g_strdup ("%CPVWI=1");
	_tmp49_ = g_strdup ("%CTZV=1");
	_tmp50_ = g_strdup ("%CSSN=1");
	_tmp51_ = g_strdup ("%CSSD=1");
	_tmp52_ = g_strdup ("%CPI=3");
	_tmp53_ = g_strdup ("%CPRI=1");
	_tmp54_ = g_strdup ("%CPVWI=1");
	_tmp55_ = g_strdup ("%CNIV=1");
	_tmp56_ = g_strdup ("%CSCN=1,2,1,2");
	_tmp57_ = g_strdup ("%CSTAT=1");
	_tmp58_ = g_strdup ("%CSQ=1");
	_tmp59_ = g_strdup ("@ST=\"-26\"");
	_tmp60_ = g_new0 (gchar*, 20 + 1);
	_tmp60_[0] = _tmp40_;
	_tmp60_[1] = _tmp41_;
	_tmp60_[2] = _tmp42_;
	_tmp60_[3] = _tmp43_;
	_tmp60_[4] = _tmp44_;
	_tmp60_[5] = _tmp45_;
	_tmp60_[6] = _tmp46_;
	_tmp60_[7] = _tmp47_;
	_tmp60_[8] = _tmp48_;
	_tmp60_[9] = _tmp49_;
	_tmp60_[10] = _tmp50_;
	_tmp60_[11] = _tmp51_;
	_tmp60_[12] = _tmp52_;
	_tmp60_[13] = _tmp53_;
	_tmp60_[14] = _tmp54_;
	_tmp60_[15] = _tmp55_;
	_tmp60_[16] = _tmp56_;
	_tmp60_[17] = _tmp57_;
	_tmp60_[18] = _tmp58_;
	_tmp60_[19] = _tmp59_;
	_tmp61_ = _tmp60_;
	_tmp61__length1 = 20;
	_tmp62_ = fso_gsm_at_command_sequence_new (_tmp61_, 20);
	_tmp63_ = _tmp62_;
	fso_gsm_modem_registerAtCommandSequence ((FsoGsmModem*) self, "urc", "init", _tmp63_);
	_fso_gsm_at_command_sequence_unref0 (_tmp63_);
	_tmp61_ = (_vala_array_free (_tmp61_, _tmp61__length1, (GDestroyNotify) g_free), NULL);
	_tmp65_ = ((FsoGsmAbstractModem*) self)->modem_data;
	_tmp66_ = _tmp65_->simBuffersSms;
	if (_tmp66_) {
		_tmp64_ = "+CNMI=2,1,2,1,1";
	} else {
		_tmp64_ = "+CNMI=2,2,2,1,1";
	}
	_tmp67_ = _tmp64_;
	_tmp68_ = g_strdup (_tmp67_);
	cnmiCommand = _tmp68_;
	_tmp69_ = g_strdup (cnmiCommand);
	_tmp70_ = g_strdup ("+CSMS=1");
	_tmp71_ = g_strdup ("%CPHS=1");
	_tmp72_ = g_new0 (gchar*, 3 + 1);
	_tmp72_[0] = _tmp69_;
	_tmp72_[1] = _tmp70_;
	_tmp72_[2] = _tmp71_;
	_tmp73_ = _tmp72_;
	_tmp73__length1 = 3;
	_tmp74_ = fso_gsm_at_command_sequence_new (_tmp73_, 3);
	_tmp75_ = _tmp74_;
	fso_gsm_modem_registerAtCommandSequence ((FsoGsmModem*) self, "urc", "registered", _tmp75_);
	_fso_gsm_at_command_sequence_unref0 (_tmp75_);
	_tmp73_ = (_vala_array_free (_tmp73_, _tmp73__length1, (GDestroyNotify) g_free), NULL);
	_tmp76_ = g_strdup ("+CREG=0");
	_tmp77_ = g_strdup ("+CGEREP=0,0");
	_tmp78_ = g_strdup ("+CGREG=0");
	_tmp79_ = g_strdup ("+CTZU=0");
	_tmp80_ = g_strdup ("+CTZR=0");
	_tmp81_ = g_strdup ("%CBHZ=0");
	_tmp82_ = g_strdup ("%CPI=0");
	_tmp83_ = g_strdup ("%CPRI=0");
	_tmp84_ = g_strdup ("%CSQ=0");
	_tmp85_ = g_strdup ("%CNIV=0");
	_tmp86_ = g_new0 (gchar*, 10 + 1);
	_tmp86_[0] = _tmp76_;
	_tmp86_[1] = _tmp77_;
	_tmp86_[2] = _tmp78_;
	_tmp86_[3] = _tmp79_;
	_tmp86_[4] = _tmp80_;
	_tmp86_[5] = _tmp81_;
	_tmp86_[6] = _tmp82_;
	_tmp86_[7] = _tmp83_;
	_tmp86_[8] = _tmp84_;
	_tmp86_[9] = _tmp85_;
	_tmp87_ = _tmp86_;
	_tmp87__length1 = 10;
	_tmp88_ = fso_gsm_at_command_sequence_new (_tmp87_, 10);
	_tmp89_ = _tmp88_;
	fso_gsm_modem_registerAtCommandSequence ((FsoGsmModem*) self, "urc", "suspend", _tmp89_);
	_fso_gsm_at_command_sequence_unref0 (_tmp89_);
	_tmp87_ = (_vala_array_free (_tmp87_, _tmp87__length1, (GDestroyNotify) g_free), NULL);
	_tmp90_ = g_strdup ("+CREG=2");
	_tmp91_ = g_strdup ("+CGEREP=2,1");
	_tmp92_ = g_strdup ("+CGREG=2");
	_tmp93_ = g_strdup ("+CTZU=1");
	_tmp94_ = g_strdup ("+CTZR=1");
	_tmp95_ = g_strdup ("%CPI=3");
	_tmp96_ = g_strdup ("%CPRI=1");
	_tmp97_ = g_strdup ("%CNIV=1");
	_tmp98_ = g_strdup ("%CSQ=1");
	_tmp99_ = g_new0 (gchar*, 9 + 1);
	_tmp99_[0] = _tmp90_;
	_tmp99_[1] = _tmp91_;
	_tmp99_[2] = _tmp92_;
	_tmp99_[3] = _tmp93_;
	_tmp99_[4] = _tmp94_;
	_tmp99_[5] = _tmp95_;
	_tmp99_[6] = _tmp96_;
	_tmp99_[7] = _tmp97_;
	_tmp99_[8] = _tmp98_;
	_tmp100_ = _tmp99_;
	_tmp100__length1 = 9;
	_tmp101_ = fso_gsm_at_command_sequence_new (_tmp100_, 9);
	_tmp102_ = _tmp101_;
	fso_gsm_modem_registerAtCommandSequence ((FsoGsmModem*) self, "urc", "resume", _tmp102_);
	_fso_gsm_at_command_sequence_unref0 (_tmp102_);
	_tmp100_ = (_vala_array_free (_tmp100_, _tmp100__length1, (GDestroyNotify) g_free), NULL);
	_tmp103_ = ((FsoGsmAbstractModem*) self)->modem_data;
	_tmp104_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp105_ = g_strdup ("115200");
	_tmp106_ = g_strdup ("nodetach");
	_tmp107_ = g_strdup ("nodefaultroute");
	_tmp108_ = g_strdup ("noreplacedefaultroute");
	_tmp109_ = g_strdup ("debug");
	_tmp110_ = g_strdup ("hide-password");
	_tmp111_ = g_strdup ("holdoff");
	_tmp112_ = g_strdup ("3");
	_tmp113_ = g_strdup ("ipcp-accept-local");
	_tmp114_ = g_strdup ("ktune");
	_tmp115_ = g_strdup ("ipcp-max-configure");
	_tmp116_ = g_strdup ("4");
	_tmp117_ = g_strdup ("noipdefault");
	_tmp118_ = g_strdup ("novj");
	_tmp119_ = g_strdup ("novjccomp");
	_tmp120_ = g_strdup ("proxyarp");
	_tmp121_ = g_strdup ("usepeerdns");
	_tmp122_ = g_new0 (gchar*, 17 + 1);
	_tmp122_[0] = _tmp105_;
	_tmp122_[1] = _tmp106_;
	_tmp122_[2] = _tmp107_;
	_tmp122_[3] = _tmp108_;
	_tmp122_[4] = _tmp109_;
	_tmp122_[5] = _tmp110_;
	_tmp122_[6] = _tmp111_;
	_tmp122_[7] = _tmp112_;
	_tmp122_[8] = _tmp113_;
	_tmp122_[9] = _tmp114_;
	_tmp122_[10] = _tmp115_;
	_tmp122_[11] = _tmp116_;
	_tmp122_[12] = _tmp117_;
	_tmp122_[13] = _tmp118_;
	_tmp122_[14] = _tmp119_;
	_tmp122_[15] = _tmp120_;
	_tmp122_[16] = _tmp121_;
	_tmp123_ = _tmp122_;
	_tmp123__length1 = 17;
	_tmp125_ = fso_framework_smart_key_file_stringListValue (_tmp104_, FSO_GSM_CONFIG_SECTION, "ppp_options", _tmp123_, 17, &_tmp124_);
	_tmp103_->pppOptions = (_vala_array_free (_tmp103_->pppOptions, _tmp103_->pppOptions_length1, (GDestroyNotify) g_free), NULL);
	_tmp103_->pppOptions = _tmp125_;
	_tmp103_->pppOptions_length1 = _tmp124_;
	_tmp123_ = (_vala_array_free (_tmp123_, _tmp123__length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (cnmiCommand);
	_g_free0 (deep_sleep);
}


static void ti_calypso_modem_real_createChannels (FsoGsmAbstractModem* base) {
	TiCalypsoModem * self;
	self = (TiCalypsoModem*) base;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				gint _tmp3_;
				gint _tmp4_;
				FsoGsmLibGsm0710muxTransport* _tmp5_;
				FsoGsmLibGsm0710muxTransport* transport;
				FsoGsmStateBasedAtParser* _tmp6_;
				FsoGsmStateBasedAtParser* parser;
				gint _tmp7_;
				const gchar* _tmp8_;
				FsoGsmLibGsm0710muxTransport* _tmp9_;
				FsoGsmStateBasedAtParser* _tmp10_;
				FsoGsmAtChannel* _tmp11_;
				FsoGsmAtChannel* _tmp12_;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp3_ = i;
				if (!(_tmp3_ < G_N_ELEMENTS (TI_CALYPSO_CHANNEL_NAMES))) {
					break;
				}
				_tmp4_ = i;
				_tmp5_ = fso_gsm_lib_gsm0710mux_transport_new (_tmp4_ + 1);
				transport = _tmp5_;
				_tmp6_ = fso_gsm_state_based_at_parser_new ();
				parser = _tmp6_;
				_tmp7_ = i;
				_tmp8_ = TI_CALYPSO_CHANNEL_NAMES[_tmp7_];
				_tmp9_ = transport;
				_tmp10_ = parser;
				_tmp11_ = fso_gsm_at_channel_new (_tmp8_, (FsoFrameworkTransport*) _tmp9_, (FsoFrameworkParser*) _tmp10_);
				_tmp12_ = _tmp11_;
				_g_object_unref0 (_tmp12_);
				_g_object_unref0 (parser);
				_g_object_unref0 (transport);
			}
		}
	}
}


static void ti_calypso_modem_real_registerCustomMediators (FsoGsmAbstractModem* base, GeeHashMap* mediators) {
	TiCalypsoModem * self;
	GeeHashMap* _tmp0_;
	self = (TiCalypsoModem*) base;
	g_return_if_fail (mediators != NULL);
	_tmp0_ = mediators;
	ti_calypso_registerCustomMediators (_tmp0_);
}


static void ti_calypso_modem_real_registerCustomAtCommands (FsoGsmAbstractModem* base, GeeHashMap* commands) {
	TiCalypsoModem * self;
	GeeHashMap* _tmp0_;
	self = (TiCalypsoModem*) base;
	g_return_if_fail (commands != NULL);
	_tmp0_ = commands;
	ti_calypso_registerCustomAtCommands (_tmp0_);
}


static FsoGsmUnsolicitedResponseHandler* ti_calypso_modem_real_createUnsolicitedHandler (FsoGsmAbstractModem* base) {
	TiCalypsoModem * self;
	FsoGsmUnsolicitedResponseHandler* result = NULL;
	TiCalypsoUnsolicitedResponseHandler* _tmp0_;
	self = (TiCalypsoModem*) base;
	_tmp0_ = ti_calypso_unsolicited_response_handler_new ();
	result = (FsoGsmUnsolicitedResponseHandler*) _tmp0_;
	return result;
}


static FsoGsmChannel* ti_calypso_modem_real_channelForCommand (FsoGsmAbstractModem* base, FsoGsmAtCommand* command, const gchar* query) {
	TiCalypsoModem * self;
	FsoGsmChannel* result = NULL;
	const gchar* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp9_;
	const gchar* _tmp12_;
	gboolean _tmp13_ = FALSE;
	const gchar* _tmp16_;
	gboolean _tmp17_ = FALSE;
	GeeHashMap* _tmp20_;
	gpointer _tmp21_ = NULL;
	self = (TiCalypsoModem*) base;
	g_return_val_if_fail (command != NULL, NULL);
	g_return_val_if_fail (query != NULL, NULL);
	_tmp0_ = query;
	_tmp1_ = g_str_has_prefix (_tmp0_, "D*99");
	if (_tmp1_) {
		GeeHashMap* _tmp2_;
		gpointer _tmp3_ = NULL;
		_tmp2_ = ((FsoGsmAbstractModem*) self)->channels;
		_tmp3_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp2_, "data");
		result = (FsoGsmChannel*) _tmp3_;
		return result;
	}
	_tmp5_ = query;
	_tmp6_ = g_str_has_prefix (_tmp5_, "D");
	if (_tmp6_) {
		const gchar* _tmp7_;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = query;
		_tmp8_ = g_str_has_suffix (_tmp7_, ";");
		_tmp4_ = _tmp8_;
	} else {
		_tmp4_ = FALSE;
	}
	_tmp9_ = _tmp4_;
	if (_tmp9_) {
		GeeHashMap* _tmp10_;
		gpointer _tmp11_ = NULL;
		_tmp10_ = ((FsoGsmAbstractModem*) self)->channels;
		_tmp11_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp10_, "call");
		result = (FsoGsmChannel*) _tmp11_;
		return result;
	}
	_tmp12_ = query;
	_tmp13_ = g_str_has_prefix (_tmp12_, "%CHLD");
	if (_tmp13_) {
		GeeHashMap* _tmp14_;
		gpointer _tmp15_ = NULL;
		_tmp14_ = ((FsoGsmAbstractModem*) self)->channels;
		_tmp15_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp14_, "call");
		result = (FsoGsmChannel*) _tmp15_;
		return result;
	}
	_tmp16_ = query;
	_tmp17_ = g_str_has_prefix (_tmp16_, "+CLIR");
	if (_tmp17_) {
		GeeHashMap* _tmp18_;
		gpointer _tmp19_ = NULL;
		_tmp18_ = ((FsoGsmAbstractModem*) self)->channels;
		_tmp19_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp18_, "call");
		result = (FsoGsmChannel*) _tmp19_;
		return result;
	}
	_tmp20_ = ((FsoGsmAbstractModem*) self)->channels;
	_tmp21_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp20_, "main");
	result = (FsoGsmChannel*) _tmp21_;
	return result;
}


static gchar* ti_calypso_modem_real_allocateDataPort (FsoGsmAbstractModem* base) {
	TiCalypsoModem * self;
	gchar* result = NULL;
	self = (TiCalypsoModem*) base;
	g_assert_not_reached ();
	return result;
}


TiCalypsoModem* ti_calypso_modem_construct (GType object_type) {
	TiCalypsoModem * self = NULL;
	self = (TiCalypsoModem*) fso_gsm_abstract_modem_construct (object_type);
	return self;
}


TiCalypsoModem* ti_calypso_modem_new (void) {
	return ti_calypso_modem_construct (TI_CALYPSO_TYPE_MODEM);
}


static GObject * ti_calypso_modem_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	TiCalypsoModem * self;
	FsoFrameworkSmartKeyFile* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_;
	parent_class = G_OBJECT_CLASS (ti_calypso_modem_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = TI_CALYPSO_MODEM (obj);
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp1_ = fso_framework_smart_key_file_stringValue (_tmp0_, TI_CALYPSO_MODULE_NAME, "dsp_mode", "0187");
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("%N", _tmp2_, NULL);
	_g_free0 (self->dspCommand);
	self->dspCommand = _tmp3_;
	_g_free0 (_tmp2_);
	return obj;
}


static void ti_calypso_modem_class_init (TiCalypsoModemClass * klass) {
	ti_calypso_modem_parent_class = g_type_class_peek_parent (klass);
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = ti_calypso_modem_real_repr;
	FSO_GSM_ABSTRACT_MODEM_CLASS (klass)->configureData = ti_calypso_modem_real_configureData;
	FSO_GSM_ABSTRACT_MODEM_CLASS (klass)->createChannels = ti_calypso_modem_real_createChannels;
	FSO_GSM_ABSTRACT_MODEM_CLASS (klass)->registerCustomMediators = ti_calypso_modem_real_registerCustomMediators;
	FSO_GSM_ABSTRACT_MODEM_CLASS (klass)->registerCustomAtCommands = ti_calypso_modem_real_registerCustomAtCommands;
	FSO_GSM_ABSTRACT_MODEM_CLASS (klass)->createUnsolicitedHandler = ti_calypso_modem_real_createUnsolicitedHandler;
	FSO_GSM_ABSTRACT_MODEM_CLASS (klass)->channelForCommand = ti_calypso_modem_real_channelForCommand;
	FSO_GSM_ABSTRACT_MODEM_CLASS (klass)->allocateDataPort = ti_calypso_modem_real_allocateDataPort;
	G_OBJECT_CLASS (klass)->constructor = ti_calypso_modem_constructor;
	G_OBJECT_CLASS (klass)->finalize = ti_calypso_modem_finalize;
}


static void ti_calypso_modem_instance_init (TiCalypsoModem * self) {
}


static void ti_calypso_modem_finalize (GObject* obj) {
	TiCalypsoModem * self;
	self = TI_CALYPSO_MODEM (obj);
	_g_free0 (self->dspCommand);
	G_OBJECT_CLASS (ti_calypso_modem_parent_class)->finalize (obj);
}


/**
 * @class TiCalypso.Modem
 *
 * This modem plugin supports the TEXAS INSTRUMENTS Calypso chipset.
 *
 * We're operating this modem in advanced MUX mode and use all of its four channels:
 * 'call': First channel will be reserved for calling commands (ATD and friends).
 * 'main': Second channel will be used for misc. commands.
 * 'urc': Third channel will be used for receiving URCs.
 * 'data': Fourth channel will be used for data connectivity (ppp), but also misc. commands,
 * when the data connection is not in use.
 *
 **/
GType ti_calypso_modem_get_type (void) {
	return ti_calypso_modem_type_id;
}


GType ti_calypso_modem_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (TiCalypsoModemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ti_calypso_modem_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TiCalypsoModem), 0, (GInstanceInitFunc) ti_calypso_modem_instance_init, NULL };
	ti_calypso_modem_type_id = g_type_module_register_type (module, FSO_GSM_TYPE_ABSTRACT_MODEM, "TiCalypsoModem", &g_define_type_info, 0);
	return ti_calypso_modem_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	FsoFrameworkLogger* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "fsogsm.ti_calypso fso_factory_function");
	_tmp1_ = g_strdup (TI_CALYPSO_MODULE_NAME);
	result = _tmp1_;
	return result;
}


void fso_register_function (GTypeModule* module) {
	g_return_if_fail (module != NULL);
	ti_calypso_percent_cpmb_register_type (module);
	ti_calypso_percent_cpri_register_type (module);
	ti_calypso_percent_cstat_register_type (module);
	ti_calypso_percent_csq_register_type (module);
	ti_calypso_percent_em21_register_type (module);
	ti_calypso_percent_em23_register_type (module);
	ti_calypso_percent_pvrf_register_type (module);
	ti_calypso_at_monitor_get_serving_cell_information_register_type (module);
	ti_calypso_at_monitor_get_neighbour_cell_information_register_type (module);
	ti_calypso_at_sim_get_unlock_counters_register_type (module);
	ti_calypso_at_voice_mailbox_get_number_register_type (module);
	ti_calypso_unsolicited_response_handler_register_type (module);
	ti_calypso_modem_register_type (module);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



