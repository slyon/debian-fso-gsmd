/* utils.c generated by valac 0.14.2, the Vala compiler
 * generated from utils.vala, do not modify */

/*
 * Copyright (C) 2010-2011 Simon Busch <morphis@gravedo.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsogsm.h>
#include <msmcomm-specs.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))


extern MsmcommOperationMode msm_data_operation_mode;

gchar* gatherFunctionalityLevel (void);
gchar* networkDataServiceToActString (MsmcommNetworkDataService data_service);
FsoGsmCallInfo* createCallInfo (MsmcommCallStatusInfo* info);
static GVariant* _variant_new31 (const gchar* value);
gint32 convertRawRssiToPercentage (guint raw_rssi);


gchar* gatherFunctionalityLevel (void) {
	gchar* result = NULL;
	gchar* _tmp0_;
	gchar* functionality_level;
	gboolean _tmp1_ = FALSE;
	FsoGsmModem* _tmp2_;
	FsoGsmModemStatus _tmp3_ = 0;
	gboolean _tmp6_;
	_tmp0_ = g_strdup ("minimal");
	functionality_level = _tmp0_;
	_tmp2_ = fso_gsm_theModem;
	_tmp3_ = fso_gsm_modem_status (_tmp2_);
	if (_tmp3_ == FSO_GSM_MODEM_STATUS_ALIVE_SIM_READY) {
		_tmp1_ = TRUE;
	} else {
		FsoGsmModem* _tmp4_;
		FsoGsmModemStatus _tmp5_ = 0;
		_tmp4_ = fso_gsm_theModem;
		_tmp5_ = fso_gsm_modem_status (_tmp4_);
		_tmp1_ = _tmp5_ == FSO_GSM_MODEM_STATUS_ALIVE_REGISTERED;
	}
	_tmp6_ = _tmp1_;
	if (_tmp6_) {
		gchar* _tmp7_;
		gboolean _tmp8_ = FALSE;
		FsoGsmModem* _tmp9_;
		FsoGsmModemStatus _tmp10_ = 0;
		gboolean _tmp12_;
		_tmp7_ = g_strdup ("airplane");
		_g_free0 (functionality_level);
		functionality_level = _tmp7_;
		_tmp9_ = fso_gsm_theModem;
		_tmp10_ = fso_gsm_modem_status (_tmp9_);
		if (_tmp10_ == FSO_GSM_MODEM_STATUS_ALIVE_REGISTERED) {
			MsmcommOperationMode _tmp11_;
			_tmp11_ = msm_data_operation_mode;
			_tmp8_ = _tmp11_ == MSMCOMM_OPERATION_MODE_ONLINE;
		} else {
			_tmp8_ = FALSE;
		}
		_tmp12_ = _tmp8_;
		if (_tmp12_) {
			gchar* _tmp13_;
			_tmp13_ = g_strdup ("full");
			_g_free0 (functionality_level);
			functionality_level = _tmp13_;
		}
	}
	result = functionality_level;
	return result;
}


gchar* networkDataServiceToActString (MsmcommNetworkDataService data_service) {
	gchar* result = NULL;
	gchar* _tmp0_;
	gchar* _result_;
	MsmcommNetworkDataService _tmp1_;
	_tmp0_ = g_strdup ("GSM");
	_result_ = _tmp0_;
	_tmp1_ = data_service;
	switch (_tmp1_) {
		case MSMCOMM_NETWORK_DATA_SERVICE_EDGE:
		{
			gchar* _tmp2_;
			_tmp2_ = g_strdup ("EDGE");
			_g_free0 (_result_);
			_result_ = _tmp2_;
			break;
		}
		case MSMCOMM_NETWORK_DATA_SERVICE_HSDPA:
		{
			gchar* _tmp3_;
			_tmp3_ = g_strdup ("HSDPA");
			_g_free0 (_result_);
			_result_ = _tmp3_;
			break;
		}
		default:
		break;
	}
	result = _result_;
	return result;
}


static GVariant* _variant_new31 (const gchar* value) {
	return g_variant_ref_sink (g_variant_new_string (value));
}


FsoGsmCallInfo* createCallInfo (MsmcommCallStatusInfo* info) {
	FsoGsmCallInfo* result = NULL;
	FsoGsmCallInfo* _tmp0_;
	FsoGsmCallInfo* _result_;
	FsoGsmCallInfo* _tmp1_;
	MsmcommCallStatusInfo _tmp2_;
	guint _tmp3_;
	MsmcommCallStatusInfo _tmp4_;
	MsmcommCallType _tmp5_;
	FsoGsmCallInfo* _tmp8_;
	GHashTable* _tmp9_;
	gchar* _tmp10_;
	MsmcommCallStatusInfo _tmp11_;
	const gchar* _tmp12_;
	GVariant* _tmp13_;
	g_return_val_if_fail (info != NULL, NULL);
	_tmp0_ = fso_gsm_call_info_new ();
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	_tmp2_ = *info;
	_tmp3_ = _tmp2_.id;
	fso_gsm_call_info_set_id (_tmp1_, (gint) _tmp3_);
	_tmp4_ = *info;
	_tmp5_ = _tmp4_.type;
	switch (_tmp5_) {
		case MSMCOMM_CALL_TYPE_DATA:
		{
			FsoGsmCallInfo* _tmp6_;
			_tmp6_ = _result_;
			fso_gsm_call_info_set_ctype (_tmp6_, "data");
			break;
		}
		case MSMCOMM_CALL_TYPE_AUDIO:
		{
			FsoGsmCallInfo* _tmp7_;
			_tmp7_ = _result_;
			fso_gsm_call_info_set_ctype (_tmp7_, "voice");
			break;
		}
		default:
		break;
	}
	_tmp8_ = _result_;
	_tmp9_ = _tmp8_->cinfo;
	_tmp10_ = g_strdup ("number");
	_tmp11_ = *info;
	_tmp12_ = _tmp11_.number;
	_tmp13_ = _variant_new31 (_tmp12_);
	g_hash_table_insert (_tmp9_, _tmp10_, _tmp13_);
	result = _result_;
	return result;
}


gint32 convertRawRssiToPercentage (guint raw_rssi) {
	gint32 result = 0;
	gint32 _result_;
	guint _tmp0_;
	_result_ = (gint32) 0;
	_tmp0_ = raw_rssi;
	if (_tmp0_ < ((guint) 72)) {
		_result_ = (gint32) 100;
	} else {
		guint _tmp1_;
		_tmp1_ = raw_rssi;
		if (_tmp1_ < ((guint) 86)) {
			_result_ = (gint32) 80;
		} else {
			guint _tmp2_;
			_tmp2_ = raw_rssi;
			if (_tmp2_ < ((guint) 100)) {
				_result_ = (gint32) 60;
			} else {
				guint _tmp3_;
				_tmp3_ = raw_rssi;
				if (_tmp3_ < ((guint) 107)) {
					_result_ = (gint32) 40;
				} else {
					guint _tmp4_;
					_tmp4_ = raw_rssi;
					if (_tmp4_ < ((guint) 117)) {
						_result_ = (gint32) 20;
					}
				}
			}
		}
	}
	result = _result_;
	return result;
}



