/* unsolicited.c generated by valac 0.14.2, the Vala compiler
 * generated from unsolicited.vala, do not modify */

/*
 * Copyright (C) 2009-2011 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *                         Simon Busch <morphis@gravedo.de>
 *                         Lukas MÃ¤rdian <lukasmaerdian@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 */

#include <glib.h>
#include <glib-object.h>
#include <freesmartphone.h>
#include <fsobasics.h>
#include <fsogsm.h>
#include <fsotransport.h>
#include <stdlib.h>
#include <string.h>
#include <msmcomm-specs.h>
#include <gio/gio.h>
#include <time.h>
#include <gobject/gvaluecollector.h>


#define TYPE_MSM_URC_TYPE (msm_urc_type_get_type ())

#define TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA (wait_for_unsolicited_response_data_get_type ())
#define WAIT_FOR_UNSOLICITED_RESPONSE_DATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA, WaitForUnsolicitedResponseData))
#define WAIT_FOR_UNSOLICITED_RESPONSE_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA, WaitForUnsolicitedResponseDataClass))
#define IS_WAIT_FOR_UNSOLICITED_RESPONSE_DATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA))
#define IS_WAIT_FOR_UNSOLICITED_RESPONSE_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA))
#define WAIT_FOR_UNSOLICITED_RESPONSE_DATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA, WaitForUnsolicitedResponseDataClass))

typedef struct _WaitForUnsolicitedResponseData WaitForUnsolicitedResponseData;
typedef struct _WaitForUnsolicitedResponseDataClass WaitForUnsolicitedResponseDataClass;
typedef struct _WaitForUnsolicitedResponseDataPrivate WaitForUnsolicitedResponseDataPrivate;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
typedef struct _ParamSpecWaitForUnsolicitedResponseData ParamSpecWaitForUnsolicitedResponseData;

#define TYPE_MSM_PIN_STATUS (msm_pin_status_get_type ())

#define TYPE_MSM_UNSOLICITED_RESPONSE_HANDLER (msm_unsolicited_response_handler_get_type ())
#define MSM_UNSOLICITED_RESPONSE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_UNSOLICITED_RESPONSE_HANDLER, MsmUnsolicitedResponseHandler))
#define MSM_UNSOLICITED_RESPONSE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_UNSOLICITED_RESPONSE_HANDLER, MsmUnsolicitedResponseHandlerClass))
#define IS_MSM_UNSOLICITED_RESPONSE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_UNSOLICITED_RESPONSE_HANDLER))
#define IS_MSM_UNSOLICITED_RESPONSE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_UNSOLICITED_RESPONSE_HANDLER))
#define MSM_UNSOLICITED_RESPONSE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_UNSOLICITED_RESPONSE_HANDLER, MsmUnsolicitedResponseHandlerClass))

typedef struct _MsmUnsolicitedResponseHandler MsmUnsolicitedResponseHandler;
typedef struct _MsmUnsolicitedResponseHandlerClass MsmUnsolicitedResponseHandlerClass;
typedef struct _MsmUnsolicitedResponseHandlerPrivate MsmUnsolicitedResponseHandlerPrivate;
#define __g_list_free__wait_for_unsolicited_response_data_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__wait_for_unsolicited_response_data_unref0_ (var), NULL)))

#define TYPE_MSM_CHANNEL (msm_channel_get_type ())
#define MSM_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_CHANNEL, MsmChannel))
#define MSM_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_CHANNEL, MsmChannelClass))
#define IS_MSM_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_CHANNEL))
#define IS_MSM_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_CHANNEL))
#define MSM_CHANNEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_CHANNEL, MsmChannelClass))

typedef struct _MsmChannel MsmChannel;
typedef struct _MsmChannelClass MsmChannelClass;
typedef struct _Block4Data Block4Data;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _MsmChannelPrivate MsmChannelPrivate;

#define TYPE_MSM_PHONEBOOK_HANDLER (msm_phonebook_handler_get_type ())
#define MSM_PHONEBOOK_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_PHONEBOOK_HANDLER, MsmPhonebookHandler))
#define MSM_PHONEBOOK_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_PHONEBOOK_HANDLER, MsmPhonebookHandlerClass))
#define IS_MSM_PHONEBOOK_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_PHONEBOOK_HANDLER))
#define IS_MSM_PHONEBOOK_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_PHONEBOOK_HANDLER))
#define MSM_PHONEBOOK_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_PHONEBOOK_HANDLER, MsmPhonebookHandlerClass))

typedef struct _MsmPhonebookHandler MsmPhonebookHandler;
typedef struct _MsmPhonebookHandlerClass MsmPhonebookHandlerClass;

#define TYPE_MSM_SMS_HANDLER (msm_sms_handler_get_type ())
#define MSM_SMS_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_SMS_HANDLER, MsmSmsHandler))
#define MSM_SMS_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_SMS_HANDLER, MsmSmsHandlerClass))
#define IS_MSM_SMS_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_SMS_HANDLER))
#define IS_MSM_SMS_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_SMS_HANDLER))
#define MSM_SMS_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_SMS_HANDLER, MsmSmsHandlerClass))

typedef struct _MsmSmsHandler MsmSmsHandler;
typedef struct _MsmSmsHandlerClass MsmSmsHandlerClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define MSM_DATA_TYPE_NETWORK_INFO (msm_data_network_info_get_type ())
typedef struct _MsmDataNetworkInfo MsmDataNetworkInfo;
typedef struct _Block5Data Block5Data;
#define _wait_for_unsolicited_response_data_unref0(var) ((var == NULL) ? NULL : (var = (wait_for_unsolicited_response_data_unref (var), NULL)))
typedef struct _msm_unsolicited_response_handler_waitForUnsolicitedResponseData msm_unsolicited_response_handler_waitForUnsolicitedResponseData;
typedef struct _msm_unsolicited_response_handler_notifyUnsolicitedResponseData msm_unsolicited_response_handler_notifyUnsolicitedResponseData;

typedef enum  {
	MSM_URC_TYPE_INVALID,
	MSM_URC_TYPE_RESET_RADIO_IND,
	MSM_URC_TYPE_CALL_ORIGINATION,
	MSM_URC_TYPE_EXTENDED_FILE_INFO,
	MSM_URC_TYPE_NETWORK_STATE_INFO,
	MSM_URC_TYPE_OPERATION_MODE,
	MSM_URC_TYPE_PIN1_VERIFIED
} MsmUrcType;

struct _WaitForUnsolicitedResponseData {
	GTypeInstance parent_instance;
	volatile int ref_count;
	WaitForUnsolicitedResponseDataPrivate * priv;
	GSourceFunc callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
	MsmUrcType urc_type;
	GVariant* response;
	guint timeout;
	GSourceFunc timeout_func;
	gpointer timeout_func_target;
	GDestroyNotify timeout_func_target_destroy_notify;
};

struct _WaitForUnsolicitedResponseDataClass {
	GTypeClass parent_class;
	void (*finalize) (WaitForUnsolicitedResponseData *self);
};

struct _ParamSpecWaitForUnsolicitedResponseData {
	GParamSpec parent_instance;
};

typedef enum  {
	MSM_PIN_STATUS_DISABLED,
	MSM_PIN_STATUS_ENABLED,
	MSM_PIN_STATUS_BLOCKED,
	MSM_PIN_STATUS_PERM_BLOCKED
} MsmPinStatus;

struct _MsmUnsolicitedResponseHandler {
	FsoFrameworkAbstractObject parent_instance;
	MsmUnsolicitedResponseHandlerPrivate * priv;
};

struct _MsmUnsolicitedResponseHandlerClass {
	FsoFrameworkAbstractObjectClass parent_class;
};

struct _MsmUnsolicitedResponseHandlerPrivate {
	GList* urc_waiters;
	gboolean already_connected;
};

struct _Block4Data {
	int _ref_count_;
	MsmUnsolicitedResponseHandler * self;
	MsmChannel* channel;
};

struct _MsmChannel {
	FsoFrameworkAbstractObject parent_instance;
	MsmChannelPrivate * priv;
	gchar* name;
	MsmUnsolicitedResponseHandler* urc_handler;
	MsmcommManagement* management_service;
	MsmcommState* state_service;
	MsmcommMisc* misc_service;
	MsmcommCall* call_service;
	MsmcommSim* sim_service;
	MsmcommPhonebook* phonebook_service;
	MsmcommNetwork* network_service;
	MsmcommSound* sound_service;
	MsmcommSms* sms_service;
};

struct _MsmChannelClass {
	FsoFrameworkAbstractObjectClass parent_class;
};

struct _MsmDataNetworkInfo {
	MsmcommNetworkRegistrationStatus reg_status;
	MsmcommNetworkServiceStatus service_status;
	MsmcommNetworkDataService data_service;
	gchar* operator_name;
	guint rssi;
	guint ecio;
	guint mcc;
	guint mnc;
};

struct _Block5Data {
	int _ref_count_;
	MsmUnsolicitedResponseHandler * self;
	WaitForUnsolicitedResponseData* data;
	gpointer _async_data_;
};

struct _msm_unsolicited_response_handler_waitForUnsolicitedResponseData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	MsmUnsolicitedResponseHandler* self;
	MsmUrcType type;
	gint timeout;
	GSourceFunc timeout_func;
	gpointer timeout_func_target;
	GVariant* result;
	Block5Data* _data5_;
	FsoFrameworkLogger* _tmp0_;
	MsmUrcType _tmp1_;
	GEnumValue* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	WaitForUnsolicitedResponseData* _tmp5_;
	WaitForUnsolicitedResponseData* _tmp6_;
	MsmUrcType _tmp7_;
	WaitForUnsolicitedResponseData* _tmp8_;
	WaitForUnsolicitedResponseData* _tmp9_;
	GSourceFunc _tmp10_;
	void* _tmp10__target;
	WaitForUnsolicitedResponseData* _tmp11_;
	WaitForUnsolicitedResponseData* _tmp12_;
	gint _tmp13_;
	WaitForUnsolicitedResponseData* _tmp14_;
	gint _tmp15_;
	guint _tmp16_;
	WaitForUnsolicitedResponseData* _tmp17_;
	WaitForUnsolicitedResponseData* _tmp18_;
	GVariant* _tmp19_;
	GVariant* _tmp20_;
};

struct _msm_unsolicited_response_handler_notifyUnsolicitedResponseData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	MsmUnsolicitedResponseHandler* self;
	MsmUrcType type;
	GVariant* response;
	FsoFrameworkLogger* _tmp0_;
	MsmUrcType _tmp1_;
	GEnumValue* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	MsmUrcType _tmp5_;
	GList* _tmp6_;
	GList* waiters;
	GList* _tmp7_;
	GList* waiter_collection;
	GList* waiter_it;
	WaitForUnsolicitedResponseData* _tmp8_;
	WaitForUnsolicitedResponseData* waiter;
	WaitForUnsolicitedResponseData* _tmp9_;
	guint _tmp10_;
	WaitForUnsolicitedResponseData* _tmp11_;
	guint _tmp12_;
	WaitForUnsolicitedResponseData* _tmp13_;
	WaitForUnsolicitedResponseData* _tmp14_;
	WaitForUnsolicitedResponseData* _tmp15_;
	GVariant* _tmp16_;
	GVariant* _tmp17_;
	WaitForUnsolicitedResponseData* _tmp18_;
	GSourceFunc _tmp19_;
	void* _tmp19__target;
};


static gpointer wait_for_unsolicited_response_data_parent_class = NULL;
static GType wait_for_unsolicited_response_data_type_id = 0;
extern MsmPinStatus msm_data_pin_status;
static gpointer msm_unsolicited_response_handler_parent_class = NULL;
extern guint msm_data_cell_id;
extern gboolean msm_data_sim_available;
extern FreeSmartphoneGSMSIMAuthStatus msm_data_sim_auth_status;
extern MsmDataNetworkInfo msm_data_network_info;
static GType msm_unsolicited_response_handler_type_id = 0;

GType msm_urc_type_get_type (void) G_GNUC_CONST;
gpointer wait_for_unsolicited_response_data_ref (gpointer instance);
void wait_for_unsolicited_response_data_unref (gpointer instance);
GParamSpec* param_spec_wait_for_unsolicited_response_data (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_wait_for_unsolicited_response_data (GValue* value, gpointer v_object);
void value_take_wait_for_unsolicited_response_data (GValue* value, gpointer v_object);
gpointer value_get_wait_for_unsolicited_response_data (const GValue* value);
GType wait_for_unsolicited_response_data_get_type (void) G_GNUC_CONST;
GType wait_for_unsolicited_response_data_register_type (GTypeModule * module);
enum  {
	WAIT_FOR_UNSOLICITED_RESPONSE_DATA_DUMMY_PROPERTY
};
WaitForUnsolicitedResponseData* wait_for_unsolicited_response_data_new (void);
WaitForUnsolicitedResponseData* wait_for_unsolicited_response_data_construct (GType object_type);
static void wait_for_unsolicited_response_data_finalize (WaitForUnsolicitedResponseData* obj);
GType msm_pin_status_get_type (void) G_GNUC_CONST;
void updateSimPinStatus (MsmPinStatus status);
void updateMsmSimAuthStatus (FreeSmartphoneGSMSIMAuthStatus status);
GType msm_unsolicited_response_handler_get_type (void) G_GNUC_CONST;
GType msm_unsolicited_response_handler_register_type (GTypeModule * module);
#define MSM_UNSOLICITED_RESPONSE_HANDLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MSM_UNSOLICITED_RESPONSE_HANDLER, MsmUnsolicitedResponseHandlerPrivate))
enum  {
	MSM_UNSOLICITED_RESPONSE_HANDLER_DUMMY_PROPERTY
};
static void _wait_for_unsolicited_response_data_unref0_ (gpointer var);
static void _g_list_free__wait_for_unsolicited_response_data_unref0_ (GList* self);
MsmUnsolicitedResponseHandler* msm_unsolicited_response_handler_new (void);
MsmUnsolicitedResponseHandler* msm_unsolicited_response_handler_construct (GType object_type);
void msm_unsolicited_response_handler_setup (MsmUnsolicitedResponseHandler* self);
GType msm_channel_get_type (void) G_GNUC_CONST;
GType msm_channel_register_type (GTypeModule * module);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (Block4Data* _data4_);
static void __lambda0_ (MsmUnsolicitedResponseHandler* self, MsmcommStateInfo* info);
void msm_unsolicited_response_handler_notifyUnsolicitedResponse (MsmUnsolicitedResponseHandler* self, MsmUrcType type, GVariant* response, GAsyncReadyCallback _callback_, gpointer _user_data_);
void msm_unsolicited_response_handler_notifyUnsolicitedResponse_finish (MsmUnsolicitedResponseHandler* self, GAsyncResult* _res_);
static GVariant* _variant_new1 (MsmcommStateInfo value);
static void ___lambda0__msmcomm_state_operation_mode (MsmcommState* _sender, MsmcommStateInfo* info, gpointer self);
static void __lambda1_ (MsmUnsolicitedResponseHandler* self);
static void ___lambda1__msmcomm_misc_radio_reset_ind (MsmcommMisc* _sender, gpointer self);
static void __lambda2_ (MsmUnsolicitedResponseHandler* self, guint cell_id, guint num_cells, guint active_rat, guint status);
static void ___lambda2__msmcomm_misc_cell_status (MsmcommMisc* _sender, guint cell_id, guint num_cells, guint active_rat, guint status, gpointer self);
static void __lambda3_ (Block4Data* _data4_, const gchar* urc_name);
gboolean msm_channel_is_ready (MsmChannel* self);
GType msm_phonebook_handler_get_type (void) G_GNUC_CONST;
GType msm_phonebook_handler_register_type (GTypeModule * module);
void msm_phonebook_handler_initializeStorage (MsmPhonebookHandler* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void msm_phonebook_handler_initializeStorage_finish (MsmPhonebookHandler* self, GAsyncResult* _res_);
static void ___lambda3__msmcomm_sim_sim_status (MsmcommSim* _sender, const gchar* name, gpointer self);
static void __lambda4_ (MsmUnsolicitedResponseHandler* self, MsmcommPhonebookBookType book_type);
void msm_phonebook_handler_syncPhonebook (MsmPhonebookHandler* self, MsmcommPhonebookBookType book_type, GAsyncReadyCallback _callback_, gpointer _user_data_);
void msm_phonebook_handler_syncPhonebook_finish (MsmPhonebookHandler* self, GAsyncResult* _res_, GError** error);
static void ___lambda4__msmcomm_phonebook_ready (MsmcommPhonebook* _sender, MsmcommPhonebookBookType book_type, gpointer self);
static void __lambda5_ (MsmUnsolicitedResponseHandler* self, MsmcommSmsMessage* message);
GType msm_sms_handler_get_type (void) G_GNUC_CONST;
GType msm_sms_handler_register_type (GTypeModule * module);
static void ___lambda5__msmcomm_sms_incoming_message (MsmcommSms* _sender, MsmcommSmsMessage* message, gpointer self);
static void __lambda7_ (MsmUnsolicitedResponseHandler* self, const gchar* name, MsmcommNetworkStateInfo* info);
GType msm_data_network_info_get_type (void) G_GNUC_CONST;
MsmDataNetworkInfo* msm_data_network_info_dup (const MsmDataNetworkInfo* self);
void msm_data_network_info_free (MsmDataNetworkInfo* self);
void msm_data_network_info_copy (const MsmDataNetworkInfo* self, MsmDataNetworkInfo* dest);
void msm_data_network_info_destroy (MsmDataNetworkInfo* self);
static GVariant* _variant_new2 (MsmcommNetworkStateInfo value);
void triggerUpdateNetworkStatus (GAsyncReadyCallback _callback_, gpointer _user_data_);
void triggerUpdateNetworkStatus_finish (GAsyncResult* _res_);
static void ___lambda7__msmcomm_network_network_status (MsmcommNetwork* _sender, const gchar* name, MsmcommNetworkStateInfo* info, gpointer self);
static void __lambda8_ (MsmUnsolicitedResponseHandler* self, const gchar* name, MsmcommCallStatusInfo* info);
FsoGsmCallInfo* createCallInfo (MsmcommCallStatusInfo* info);
static GVariant* _variant_new3 (MsmcommCallStatusInfo value);
static void ___lambda8__msmcomm_call_call_status (MsmcommCall* _sender, const gchar* type, MsmcommCallStatusInfo* info, gpointer self);
static gchar* msm_unsolicited_response_handler_real_repr (FsoFrameworkAbstractObject* base);
static void msm_unsolicited_response_handler_waitForUnsolicitedResponse_data_free (gpointer _data);
void msm_unsolicited_response_handler_waitForUnsolicitedResponse (MsmUnsolicitedResponseHandler* self, MsmUrcType type, gint timeout, GSourceFunc timeout_func, void* timeout_func_target, GAsyncReadyCallback _callback_, gpointer _user_data_);
GVariant* msm_unsolicited_response_handler_waitForUnsolicitedResponse_finish (MsmUnsolicitedResponseHandler* self, GAsyncResult* _res_);
static gboolean msm_unsolicited_response_handler_waitForUnsolicitedResponse_co (msm_unsolicited_response_handler_waitForUnsolicitedResponseData* _data_);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (Block5Data* _data5_);
const gchar* msm_urc_type_to_string (MsmUrcType self);
static gboolean _msm_unsolicited_response_handler_waitForUnsolicitedResponse_co_gsource_func (gpointer self);
static gboolean ___lambda9_ (Block5Data* _data5_);
static gboolean ____lambda9__gsource_func (gpointer self);
static void msm_unsolicited_response_handler_notifyUnsolicitedResponse_data_free (gpointer _data);
static gboolean msm_unsolicited_response_handler_notifyUnsolicitedResponse_co (msm_unsolicited_response_handler_notifyUnsolicitedResponseData* _data_);
static GList* msm_unsolicited_response_handler_retriveUrcWaiters (MsmUnsolicitedResponseHandler* self, MsmUrcType type);
static void msm_unsolicited_response_handler_finalize (GObject* obj);


GType msm_urc_type_get_type (void) {
	static volatile gsize msm_urc_type_type_id__volatile = 0;
	if (g_once_init_enter (&msm_urc_type_type_id__volatile)) {
		static const GEnumValue values[] = {{MSM_URC_TYPE_INVALID, "MSM_URC_TYPE_INVALID", "invalid"}, {MSM_URC_TYPE_RESET_RADIO_IND, "MSM_URC_TYPE_RESET_RADIO_IND", "reset-radio-ind"}, {MSM_URC_TYPE_CALL_ORIGINATION, "MSM_URC_TYPE_CALL_ORIGINATION", "call-origination"}, {MSM_URC_TYPE_EXTENDED_FILE_INFO, "MSM_URC_TYPE_EXTENDED_FILE_INFO", "extended-file-info"}, {MSM_URC_TYPE_NETWORK_STATE_INFO, "MSM_URC_TYPE_NETWORK_STATE_INFO", "network-state-info"}, {MSM_URC_TYPE_OPERATION_MODE, "MSM_URC_TYPE_OPERATION_MODE", "operation-mode"}, {MSM_URC_TYPE_PIN1_VERIFIED, "MSM_URC_TYPE_PIN1_VERIFIED", "pin1-verified"}, {0, NULL, NULL}};
		GType msm_urc_type_type_id;
		msm_urc_type_type_id = g_enum_register_static ("MsmUrcType", values);
		g_once_init_leave (&msm_urc_type_type_id__volatile, msm_urc_type_type_id);
	}
	return msm_urc_type_type_id__volatile;
}


WaitForUnsolicitedResponseData* wait_for_unsolicited_response_data_construct (GType object_type) {
	WaitForUnsolicitedResponseData* self = NULL;
	self = (WaitForUnsolicitedResponseData*) g_type_create_instance (object_type);
	return self;
}


WaitForUnsolicitedResponseData* wait_for_unsolicited_response_data_new (void) {
	return wait_for_unsolicited_response_data_construct (TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA);
}


static void value_wait_for_unsolicited_response_data_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_wait_for_unsolicited_response_data_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		wait_for_unsolicited_response_data_unref (value->data[0].v_pointer);
	}
}


static void value_wait_for_unsolicited_response_data_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = wait_for_unsolicited_response_data_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_wait_for_unsolicited_response_data_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_wait_for_unsolicited_response_data_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		WaitForUnsolicitedResponseData* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = wait_for_unsolicited_response_data_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_wait_for_unsolicited_response_data_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	WaitForUnsolicitedResponseData** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = wait_for_unsolicited_response_data_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_wait_for_unsolicited_response_data (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecWaitForUnsolicitedResponseData* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_wait_for_unsolicited_response_data (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA), NULL);
	return value->data[0].v_pointer;
}


void value_set_wait_for_unsolicited_response_data (GValue* value, gpointer v_object) {
	WaitForUnsolicitedResponseData* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		wait_for_unsolicited_response_data_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		wait_for_unsolicited_response_data_unref (old);
	}
}


void value_take_wait_for_unsolicited_response_data (GValue* value, gpointer v_object) {
	WaitForUnsolicitedResponseData* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_WAIT_FOR_UNSOLICITED_RESPONSE_DATA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		wait_for_unsolicited_response_data_unref (old);
	}
}


static void wait_for_unsolicited_response_data_class_init (WaitForUnsolicitedResponseDataClass * klass) {
	wait_for_unsolicited_response_data_parent_class = g_type_class_peek_parent (klass);
	WAIT_FOR_UNSOLICITED_RESPONSE_DATA_CLASS (klass)->finalize = wait_for_unsolicited_response_data_finalize;
}


static void wait_for_unsolicited_response_data_instance_init (WaitForUnsolicitedResponseData * self) {
	self->ref_count = 1;
}


static void wait_for_unsolicited_response_data_finalize (WaitForUnsolicitedResponseData* obj) {
	WaitForUnsolicitedResponseData * self;
	self = WAIT_FOR_UNSOLICITED_RESPONSE_DATA (obj);
	(self->callback_target_destroy_notify == NULL) ? NULL : (self->callback_target_destroy_notify (self->callback_target), NULL);
	self->callback = NULL;
	self->callback_target = NULL;
	self->callback_target_destroy_notify = NULL;
	_g_variant_unref0 (self->response);
	(self->timeout_func_target_destroy_notify == NULL) ? NULL : (self->timeout_func_target_destroy_notify (self->timeout_func_target), NULL);
	self->timeout_func = NULL;
	self->timeout_func_target = NULL;
	self->timeout_func_target_destroy_notify = NULL;
}


GType wait_for_unsolicited_response_data_get_type (void) {
	return wait_for_unsolicited_response_data_type_id;
}


GType wait_for_unsolicited_response_data_register_type (GTypeModule * module) {
	static const GTypeValueTable g_define_type_value_table = { value_wait_for_unsolicited_response_data_init, value_wait_for_unsolicited_response_data_free_value, value_wait_for_unsolicited_response_data_copy_value, value_wait_for_unsolicited_response_data_peek_pointer, "p", value_wait_for_unsolicited_response_data_collect_value, "p", value_wait_for_unsolicited_response_data_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (WaitForUnsolicitedResponseDataClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) wait_for_unsolicited_response_data_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (WaitForUnsolicitedResponseData), 0, (GInstanceInitFunc) wait_for_unsolicited_response_data_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	wait_for_unsolicited_response_data_type_id = g_type_register_fundamental (g_type_fundamental_next (), "WaitForUnsolicitedResponseData", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return wait_for_unsolicited_response_data_type_id;
}


gpointer wait_for_unsolicited_response_data_ref (gpointer instance) {
	WaitForUnsolicitedResponseData* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void wait_for_unsolicited_response_data_unref (gpointer instance) {
	WaitForUnsolicitedResponseData* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		WAIT_FOR_UNSOLICITED_RESPONSE_DATA_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


void updateSimPinStatus (MsmPinStatus status) {
	MsmPinStatus _tmp0_;
	MsmPinStatus _tmp2_;
	_tmp0_ = status;
	if (_tmp0_ == MSM_PIN_STATUS_BLOCKED) {
		updateMsmSimAuthStatus (FREE_SMARTPHONE_GSM_SIM_AUTH_STATUS_PUK_REQUIRED);
	} else {
		MsmPinStatus _tmp1_;
		_tmp1_ = status;
		if (_tmp1_ == MSM_PIN_STATUS_PERM_BLOCKED) {
			updateMsmSimAuthStatus (FREE_SMARTPHONE_GSM_SIM_AUTH_STATUS_PUK2_REQUIRED);
		}
	}
	_tmp2_ = status;
	msm_data_pin_status = _tmp2_;
}


static void _wait_for_unsolicited_response_data_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (wait_for_unsolicited_response_data_unref (var), NULL));
}


static void _g_list_free__wait_for_unsolicited_response_data_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _wait_for_unsolicited_response_data_unref0_, NULL);
	g_list_free (self);
}


MsmUnsolicitedResponseHandler* msm_unsolicited_response_handler_construct (GType object_type) {
	MsmUnsolicitedResponseHandler * self = NULL;
	self = (MsmUnsolicitedResponseHandler*) fso_framework_abstract_object_construct (object_type);
	__g_list_free__wait_for_unsolicited_response_data_unref0_0 (self->priv->urc_waiters);
	self->priv->urc_waiters = NULL;
	return self;
}


MsmUnsolicitedResponseHandler* msm_unsolicited_response_handler_new (void) {
	return msm_unsolicited_response_handler_construct (TYPE_MSM_UNSOLICITED_RESPONSE_HANDLER);
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (Block4Data* _data4_) {
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		_g_object_unref0 (_data4_->self);
		_g_object_unref0 (_data4_->channel);
		g_slice_free (Block4Data, _data4_);
	}
}


static GVariant* _variant_new1 (MsmcommStateInfo value) {
	GVariantBuilder _tmp3_;
	g_variant_builder_init (&_tmp3_, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_tmp3_, g_variant_new_string (msmcomm_operation_mode_to_string (value.mode)));
	g_variant_builder_add_value (&_tmp3_, g_variant_new_uint32 (value.line));
	g_variant_builder_add_value (&_tmp3_, g_variant_new_uint32 (value.als_allowed));
	return g_variant_ref_sink (g_variant_builder_end (&_tmp3_));
}


static void __lambda0_ (MsmUnsolicitedResponseHandler* self, MsmcommStateInfo* info) {
	MsmcommStateInfo _tmp0_;
	MsmcommOperationMode _tmp1_;
	MsmcommStateInfo _tmp2_;
	GVariant* _tmp4_;
	g_return_if_fail (info != NULL);
	_tmp0_ = *info;
	_tmp1_ = _tmp0_.mode;
	if (_tmp1_ == MSMCOMM_OPERATION_MODE_OFFLINE) {
		updateMsmSimAuthStatus (FREE_SMARTPHONE_GSM_SIM_AUTH_STATUS_PIN_REQUIRED);
	}
	_tmp2_ = *info;
	_tmp4_ = _variant_new1 (_tmp2_);
	msm_unsolicited_response_handler_notifyUnsolicitedResponse (self, MSM_URC_TYPE_OPERATION_MODE, _tmp4_, NULL, NULL);
}


static void ___lambda0__msmcomm_state_operation_mode (MsmcommState* _sender, MsmcommStateInfo* info, gpointer self) {
	__lambda0_ (self, info);
}


static void __lambda1_ (MsmUnsolicitedResponseHandler* self) {
	msm_unsolicited_response_handler_notifyUnsolicitedResponse (self, MSM_URC_TYPE_RESET_RADIO_IND, NULL, NULL, NULL);
}


static void ___lambda1__msmcomm_misc_radio_reset_ind (MsmcommMisc* _sender, gpointer self) {
	__lambda1_ (self);
}


static void __lambda2_ (MsmUnsolicitedResponseHandler* self, guint cell_id, guint num_cells, guint active_rat, guint status) {
	guint _tmp0_;
	_tmp0_ = cell_id;
	msm_data_cell_id = _tmp0_;
}


static void ___lambda2__msmcomm_misc_cell_status (MsmcommMisc* _sender, guint cell_id, guint num_cells, guint active_rat, guint status, gpointer self) {
	__lambda2_ (self, cell_id, num_cells, active_rat, status);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda3_ (Block4Data* _data4_, const gchar* urc_name) {
	MsmUnsolicitedResponseHandler * self;
	MsmChannel* _tmp0_;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	GQuark _tmp5_ = 0U;
	static GQuark _tmp4_label0 = 0;
	static GQuark _tmp4_label1 = 0;
	static GQuark _tmp4_label2 = 0;
	static GQuark _tmp4_label3 = 0;
	static GQuark _tmp4_label4 = 0;
	static GQuark _tmp4_label5 = 0;
	static GQuark _tmp4_label6 = 0;
	static GQuark _tmp4_label7 = 0;
	static GQuark _tmp4_label8 = 0;
	static GQuark _tmp4_label9 = 0;
	self = _data4_->self;
	g_return_if_fail (urc_name != NULL);
	_tmp0_ = _data4_->channel;
	_tmp1_ = msm_channel_is_ready (_tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = urc_name;
	_tmp3_ = _tmp2_;
	_tmp5_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
	if (_tmp5_ == ((0 != _tmp4_label0) ? _tmp4_label0 : (_tmp4_label0 = g_quark_from_static_string ("sim-inserted")))) {
		switch (0) {
			default:
			{
				msm_data_sim_available = TRUE;
				updateMsmSimAuthStatus (FREE_SMARTPHONE_GSM_SIM_AUTH_STATUS_PIN_REQUIRED);
				break;
			}
		}
	} else if ((_tmp5_ == ((0 != _tmp4_label1) ? _tmp4_label1 : (_tmp4_label1 = g_quark_from_static_string ("no-sim")))) || (_tmp5_ == ((0 != _tmp4_label2) ? _tmp4_label2 : (_tmp4_label2 = g_quark_from_static_string ("no-sim-event"))))) {
		switch (0) {
			default:
			{
				msm_data_sim_available = FALSE;
				break;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label3) ? _tmp4_label3 : (_tmp4_label3 = g_quark_from_static_string ("sim-init-completed")))) {
		switch (0) {
			default:
			{
				FsoGsmModem* _tmp6_;
				FsoGsmPhonebookHandler* _tmp7_;
				FsoGsmPhonebookHandler* _tmp8_;
				MsmPhonebookHandler* _tmp9_;
				MsmPhonebookHandler* pbhandler;
				MsmPhonebookHandler* _tmp10_;
				updateMsmSimAuthStatus (FREE_SMARTPHONE_GSM_SIM_AUTH_STATUS_READY);
				_tmp6_ = fso_gsm_theModem;
				_tmp7_ = fso_gsm_modem_get_pbhandler (_tmp6_);
				_tmp8_ = _tmp7_;
				_tmp9_ = _g_object_ref0 (IS_MSM_PHONEBOOK_HANDLER (_tmp8_) ? ((MsmPhonebookHandler*) _tmp8_) : NULL);
				pbhandler = _tmp9_;
				_tmp10_ = pbhandler;
				msm_phonebook_handler_initializeStorage (_tmp10_, NULL, NULL);
				_g_object_unref0 (pbhandler);
				break;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label4) ? _tmp4_label4 : (_tmp4_label4 = g_quark_from_static_string ("pin1-enabled")))) {
		switch (0) {
			default:
			{
				updateSimPinStatus (MSM_PIN_STATUS_ENABLED);
				break;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label5) ? _tmp4_label5 : (_tmp4_label5 = g_quark_from_static_string ("pin1-disabled")))) {
		switch (0) {
			default:
			{
				updateSimPinStatus (MSM_PIN_STATUS_DISABLED);
				break;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label6) ? _tmp4_label6 : (_tmp4_label6 = g_quark_from_static_string ("pin1-unblocked")))) {
		switch (0) {
			default:
			{
				break;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label7) ? _tmp4_label7 : (_tmp4_label7 = g_quark_from_static_string ("pin1-blocked")))) {
		switch (0) {
			default:
			{
				updateSimPinStatus (MSM_PIN_STATUS_BLOCKED);
				break;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label8) ? _tmp4_label8 : (_tmp4_label8 = g_quark_from_static_string ("pin1-perm-blocked")))) {
		switch (0) {
			default:
			{
				updateSimPinStatus (MSM_PIN_STATUS_PERM_BLOCKED);
				break;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label9) ? _tmp4_label9 : (_tmp4_label9 = g_quark_from_static_string ("pin1-verified")))) {
		switch (0) {
			default:
			{
				msm_data_sim_auth_status = FREE_SMARTPHONE_GSM_SIM_AUTH_STATUS_READY;
				msm_unsolicited_response_handler_notifyUnsolicitedResponse (self, MSM_URC_TYPE_PIN1_VERIFIED, NULL, NULL, NULL);
				break;
			}
		}
	}
}


static void ___lambda3__msmcomm_sim_sim_status (MsmcommSim* _sender, const gchar* name, gpointer self) {
	__lambda3_ (self, name);
}


static void __lambda4_ (MsmUnsolicitedResponseHandler* self, MsmcommPhonebookBookType book_type) {
	FsoGsmModem* _tmp0_;
	FsoGsmPhonebookHandler* _tmp1_;
	FsoGsmPhonebookHandler* _tmp2_;
	MsmPhonebookHandler* _tmp3_;
	MsmPhonebookHandler* pbhandler;
	MsmPhonebookHandler* _tmp4_;
	_tmp0_ = fso_gsm_theModem;
	_tmp1_ = fso_gsm_modem_get_pbhandler (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _g_object_ref0 (IS_MSM_PHONEBOOK_HANDLER (_tmp2_) ? ((MsmPhonebookHandler*) _tmp2_) : NULL);
	pbhandler = _tmp3_;
	_tmp4_ = pbhandler;
	if (_tmp4_ != NULL) {
		MsmPhonebookHandler* _tmp5_;
		MsmcommPhonebookBookType _tmp6_;
		_tmp5_ = pbhandler;
		_tmp6_ = book_type;
		msm_phonebook_handler_syncPhonebook (_tmp5_, _tmp6_, NULL, NULL);
	}
	_g_object_unref0 (pbhandler);
}


static void ___lambda4__msmcomm_phonebook_ready (MsmcommPhonebook* _sender, MsmcommPhonebookBookType book_type, gpointer self) {
	__lambda4_ (self, book_type);
}


static void __lambda5_ (MsmUnsolicitedResponseHandler* self, MsmcommSmsMessage* message) {
	FsoGsmModem* _tmp0_;
	FsoGsmSmsHandler* _tmp1_;
	FsoGsmSmsHandler* _tmp2_;
	MsmSmsHandler* _tmp3_;
	MsmSmsHandler* smshandler;
	MsmSmsHandler* _tmp4_;
	g_return_if_fail (message != NULL);
	_tmp0_ = fso_gsm_theModem;
	_tmp1_ = fso_gsm_modem_get_smshandler (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _g_object_ref0 (IS_MSM_SMS_HANDLER (_tmp2_) ? ((MsmSmsHandler*) _tmp2_) : NULL);
	smshandler = _tmp3_;
	_tmp4_ = smshandler;
	if (_tmp4_ != NULL) {
		gchar* _tmp5_;
		gchar* hexpdu;
		MsmcommSmsMessage _tmp6_;
		guint8* _tmp7_;
		gint _tmp7__length1;
		gint tpdulen;
		MsmcommSmsMessage _tmp8_;
		guint8* _tmp9_;
		gint _tmp9__length1;
		MsmSmsHandler* _tmp15_;
		const gchar* _tmp16_;
		gint _tmp17_;
		_tmp5_ = g_strdup ("");
		hexpdu = _tmp5_;
		_tmp6_ = *message;
		_tmp7_ = _tmp6_.pdu;
		_tmp7__length1 = _tmp6_.pdu_length1;
		tpdulen = _tmp7__length1;
		_tmp8_ = *message;
		_tmp9_ = _tmp8_.pdu;
		_tmp9__length1 = _tmp8_.pdu_length1;
		{
			guint8* byte_collection = NULL;
			gint byte_collection_length1 = 0;
			gint _byte_collection_size_ = 0;
			gint byte_it = 0;
			byte_collection = _tmp9_;
			byte_collection_length1 = _tmp9__length1;
			for (byte_it = 0; byte_it < _tmp9__length1; byte_it = byte_it + 1) {
				guint8 byte = 0U;
				byte = byte_collection[byte_it];
				{
					const gchar* _tmp10_;
					guint8 _tmp11_;
					gchar* _tmp12_ = NULL;
					gchar* _tmp13_;
					gchar* _tmp14_;
					_tmp10_ = hexpdu;
					_tmp11_ = byte;
					_tmp12_ = g_strdup_printf ("%02x", (guint) _tmp11_);
					_tmp13_ = _tmp12_;
					_tmp14_ = g_strconcat (_tmp10_, _tmp13_, NULL);
					_g_free0 (hexpdu);
					hexpdu = _tmp14_;
					_g_free0 (_tmp13_);
				}
			}
		}
		_tmp15_ = smshandler;
		_tmp16_ = hexpdu;
		_tmp17_ = tpdulen;
		fso_gsm_sms_handler_handleIncomingSms ((FsoGsmSmsHandler*) _tmp15_, _tmp16_, _tmp17_, NULL, NULL);
		_g_free0 (hexpdu);
	}
	_g_object_unref0 (smshandler);
}


static void ___lambda5__msmcomm_sms_incoming_message (MsmcommSms* _sender, MsmcommSmsMessage* message, gpointer self) {
	__lambda5_ (self, message);
}


static GVariant* _variant_new2 (MsmcommNetworkStateInfo value) {
	GVariantBuilder _tmp49_;
	GVariantBuilder _tmp50_;
	g_variant_builder_init (&_tmp49_, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_tmp49_, g_variant_new_uint32 (value.mcc));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_uint32 (value.mnc));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_string (msmcomm_network_registration_status_to_string (value.reg_status)));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_string (msmcomm_network_service_status_to_string (value.service_status)));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_string (value.operator_name));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_string (value.hplmn));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_uint32 (value.rssi));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_uint32 (value.ecio));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_boolean (value.gprs_attached));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_boolean (value.roam));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_string (msmcomm_network_data_service_to_string (value.data_service)));
	g_variant_builder_add_value (&_tmp49_, g_variant_new_boolean (value.with_time_update));
	g_variant_builder_init (&_tmp50_, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_tmp50_, g_variant_new_uint32 (value.time.year));
	g_variant_builder_add_value (&_tmp50_, g_variant_new_uint32 (value.time.month));
	g_variant_builder_add_value (&_tmp50_, g_variant_new_uint32 (value.time.day));
	g_variant_builder_add_value (&_tmp50_, g_variant_new_uint32 (value.time.hours));
	g_variant_builder_add_value (&_tmp50_, g_variant_new_uint32 (value.time.minutes));
	g_variant_builder_add_value (&_tmp50_, g_variant_new_uint32 (value.time.seconds));
	g_variant_builder_add_value (&_tmp50_, g_variant_new_uint32 (value.time.timezone_offset));
	g_variant_builder_add_value (&_tmp49_, g_variant_builder_end (&_tmp50_));
	return g_variant_ref_sink (g_variant_builder_end (&_tmp49_));
}


static void __lambda7_ (MsmUnsolicitedResponseHandler* self, const gchar* name, MsmcommNetworkStateInfo* info) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GQuark _tmp3_ = 0U;
	static GQuark _tmp2_label0 = 0;
	static GQuark _tmp2_label1 = 0;
	g_return_if_fail (name != NULL);
	g_return_if_fail (info != NULL);
	_tmp0_ = name;
	_tmp1_ = _tmp0_;
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	if ((_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("rssi")))) || (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("srv-changed"))))) {
		switch (0) {
			default:
			{
				MsmcommNetworkStateInfo _tmp4_;
				guint _tmp5_;
				MsmcommNetworkStateInfo _tmp6_;
				guint _tmp7_;
				MsmcommNetworkStateInfo _tmp8_;
				const gchar* _tmp9_;
				gchar* _tmp10_;
				MsmcommNetworkStateInfo _tmp11_;
				MsmcommNetworkRegistrationStatus _tmp12_;
				MsmcommNetworkStateInfo _tmp13_;
				MsmcommNetworkServiceStatus _tmp14_;
				MsmcommNetworkStateInfo _tmp15_;
				guint _tmp16_;
				MsmcommNetworkStateInfo _tmp17_;
				guint _tmp18_;
				MsmcommNetworkStateInfo _tmp19_;
				gboolean _tmp20_;
				MsmcommNetworkStateInfo _tmp48_;
				GVariant* _tmp51_;
				_tmp4_ = *info;
				_tmp5_ = _tmp4_.rssi;
				msm_data_network_info.rssi = _tmp5_;
				_tmp6_ = *info;
				_tmp7_ = _tmp6_.ecio;
				msm_data_network_info.ecio = _tmp7_;
				_tmp8_ = *info;
				_tmp9_ = _tmp8_.operator_name;
				_tmp10_ = g_strdup (_tmp9_);
				_g_free0 (msm_data_network_info.operator_name);
				msm_data_network_info.operator_name = _tmp10_;
				_tmp11_ = *info;
				_tmp12_ = _tmp11_.reg_status;
				msm_data_network_info.reg_status = _tmp12_;
				_tmp13_ = *info;
				_tmp14_ = _tmp13_.service_status;
				msm_data_network_info.service_status = _tmp14_;
				_tmp15_ = *info;
				_tmp16_ = _tmp15_.mcc;
				msm_data_network_info.mcc = _tmp16_;
				_tmp17_ = *info;
				_tmp18_ = _tmp17_.mnc;
				msm_data_network_info.mnc = _tmp18_;
				_tmp19_ = *info;
				_tmp20_ = _tmp19_.with_time_update;
				if (_tmp20_) {
					FsoGsmModem* _tmp21_;
					FsoGsmModemData* _tmp22_ = NULL;
					FsoGsmModemData* data;
					MsmcommNetworkStateInfo _tmp23_;
					MsmcommNetworkTimeUpdate _tmp24_;
					guint _tmp25_;
					MsmcommNetworkStateInfo _tmp26_;
					MsmcommNetworkTimeUpdate _tmp27_;
					guint _tmp28_;
					MsmcommNetworkStateInfo _tmp29_;
					MsmcommNetworkTimeUpdate _tmp30_;
					guint _tmp31_;
					MsmcommNetworkStateInfo _tmp32_;
					MsmcommNetworkTimeUpdate _tmp33_;
					guint _tmp34_;
					MsmcommNetworkStateInfo _tmp35_;
					MsmcommNetworkTimeUpdate _tmp36_;
					guint _tmp37_;
					MsmcommNetworkStateInfo _tmp38_;
					MsmcommNetworkTimeUpdate _tmp39_;
					guint _tmp40_;
					gchar* _tmp41_ = NULL;
					gchar* timestr;
					gchar* _tmp42_;
					gchar* formatstr;
					struct tm t = {0};
					const gchar* _tmp43_;
					const gchar* _tmp44_;
					FsoGsmModemData* _tmp45_;
					FsoGsmNetworkTimeReport* _tmp46_;
					time_t _tmp47_ = 0;
					_tmp21_ = fso_gsm_theModem;
					_tmp22_ = fso_gsm_modem_data (_tmp21_);
					data = _tmp22_;
					_tmp23_ = *info;
					_tmp24_ = _tmp23_.time;
					_tmp25_ = _tmp24_.year;
					_tmp26_ = *info;
					_tmp27_ = _tmp26_.time;
					_tmp28_ = _tmp27_.month;
					_tmp29_ = *info;
					_tmp30_ = _tmp29_.time;
					_tmp31_ = _tmp30_.day;
					_tmp32_ = *info;
					_tmp33_ = _tmp32_.time;
					_tmp34_ = _tmp33_.hours;
					_tmp35_ = *info;
					_tmp36_ = _tmp35_.time;
					_tmp37_ = _tmp36_.minutes;
					_tmp38_ = *info;
					_tmp39_ = _tmp38_.time;
					_tmp40_ = _tmp39_.seconds;
					_tmp41_ = g_strdup_printf ("%02d/%02d/%02d,%02d:%02d:%02d", (gint) _tmp25_, (gint) _tmp28_, (gint) _tmp31_, (gint) _tmp34_, (gint) _tmp37_, (gint) _tmp40_);
					timestr = _tmp41_;
					_tmp42_ = g_strdup ("%y/%m/%d,%H:%M:%S");
					formatstr = _tmp42_;
					memset (&t, 0, sizeof (struct tm));
					_tmp43_ = timestr;
					_tmp44_ = formatstr;
					strptime (_tmp43_, _tmp44_, &t);
					_tmp45_ = data;
					_tmp46_ = _tmp45_->networkTimeReport;
					_tmp47_ = mktime (&t);
					fso_gsm_network_time_report_setTime (_tmp46_, (gint) _tmp47_);
					_g_free0 (formatstr);
					_g_free0 (timestr);
					_g_object_unref0 (data);
				}
				_tmp48_ = *info;
				_tmp51_ = _variant_new2 (_tmp48_);
				msm_unsolicited_response_handler_notifyUnsolicitedResponse (self, MSM_URC_TYPE_NETWORK_STATE_INFO, _tmp51_, NULL, NULL);
				triggerUpdateNetworkStatus (NULL, NULL);
				break;
			}
		}
	}
}


static void ___lambda7__msmcomm_network_network_status (MsmcommNetwork* _sender, const gchar* name, MsmcommNetworkStateInfo* info, gpointer self) {
	__lambda7_ (self, name, info);
}


static GVariant* _variant_new3 (MsmcommCallStatusInfo value) {
	GVariantBuilder _tmp7_;
	g_variant_builder_init (&_tmp7_, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_tmp7_, g_variant_new_uint32 (value.id));
	g_variant_builder_add_value (&_tmp7_, g_variant_new_string (msmcomm_call_type_to_string (value.type)));
	g_variant_builder_add_value (&_tmp7_, g_variant_new_string (value.number));
	return g_variant_ref_sink (g_variant_builder_end (&_tmp7_));
}


static void __lambda8_ (MsmUnsolicitedResponseHandler* self, const gchar* name, MsmcommCallStatusInfo* info) {
	MsmcommCallStatusInfo _tmp0_;
	FsoGsmCallInfo* _tmp1_ = NULL;
	FsoGsmCallInfo* call_info;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	GQuark _tmp5_ = 0U;
	static GQuark _tmp4_label0 = 0;
	static GQuark _tmp4_label1 = 0;
	static GQuark _tmp4_label2 = 0;
	static GQuark _tmp4_label3 = 0;
	static GQuark _tmp4_label4 = 0;
	g_return_if_fail (name != NULL);
	g_return_if_fail (info != NULL);
	_tmp0_ = *info;
	_tmp1_ = createCallInfo (&_tmp0_);
	call_info = _tmp1_;
	_tmp2_ = name;
	_tmp3_ = _tmp2_;
	_tmp5_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
	if ((_tmp5_ == ((0 != _tmp4_label0) ? _tmp4_label0 : (_tmp4_label0 = g_quark_from_static_string ("orig-fwd-status")))) || (_tmp5_ == ((0 != _tmp4_label1) ? _tmp4_label1 : (_tmp4_label1 = g_quark_from_static_string ("orig"))))) {
		switch (0) {
			default:
			{
				MsmcommCallStatusInfo _tmp6_;
				GVariant* _tmp8_;
				_tmp6_ = *info;
				_tmp8_ = _variant_new3 (_tmp6_);
				msm_unsolicited_response_handler_notifyUnsolicitedResponse (self, MSM_URC_TYPE_CALL_ORIGINATION, _tmp8_, NULL, NULL);
				break;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label2) ? _tmp4_label2 : (_tmp4_label2 = g_quark_from_static_string ("end")))) {
		switch (0) {
			default:
			{
				FsoGsmModem* _tmp9_;
				FsoGsmCallHandler* _tmp10_;
				FsoGsmCallHandler* _tmp11_;
				FsoGsmCallInfo* _tmp12_;
				_tmp9_ = fso_gsm_theModem;
				_tmp10_ = fso_gsm_modem_get_callhandler (_tmp9_);
				_tmp11_ = _tmp10_;
				_tmp12_ = call_info;
				fso_gsm_call_handler_handleEndingCall (_tmp11_, _tmp12_);
				break;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label3) ? _tmp4_label3 : (_tmp4_label3 = g_quark_from_static_string ("incom")))) {
		switch (0) {
			default:
			{
				FsoGsmModem* _tmp13_;
				FsoGsmCallHandler* _tmp14_;
				FsoGsmCallHandler* _tmp15_;
				FsoGsmCallInfo* _tmp16_;
				_tmp13_ = fso_gsm_theModem;
				_tmp14_ = fso_gsm_modem_get_callhandler (_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = call_info;
				fso_gsm_call_handler_handleIncomingCall (_tmp15_, _tmp16_);
				break;
			}
		}
	} else if (_tmp5_ == ((0 != _tmp4_label4) ? _tmp4_label4 : (_tmp4_label4 = g_quark_from_static_string ("connect")))) {
		switch (0) {
			default:
			{
				FsoGsmModem* _tmp17_;
				FsoGsmCallHandler* _tmp18_;
				FsoGsmCallHandler* _tmp19_;
				FsoGsmCallInfo* _tmp20_;
				_tmp17_ = fso_gsm_theModem;
				_tmp18_ = fso_gsm_modem_get_callhandler (_tmp17_);
				_tmp19_ = _tmp18_;
				_tmp20_ = call_info;
				fso_gsm_call_handler_handleConnectingCall (_tmp19_, _tmp20_);
				break;
			}
		}
	}
	_g_object_unref0 (call_info);
}


static void ___lambda8__msmcomm_call_call_status (MsmcommCall* _sender, const gchar* type, MsmcommCallStatusInfo* info, gpointer self) {
	__lambda8_ (self, type, info);
}


void msm_unsolicited_response_handler_setup (MsmUnsolicitedResponseHandler* self) {
	Block4Data* _data4_;
	gboolean _tmp0_;
	FsoGsmModem* _tmp2_;
	FsoGsmChannel* _tmp3_ = NULL;
	MsmChannel* _tmp4_;
	MsmcommState* _tmp5_;
	MsmChannel* _tmp6_;
	MsmcommMisc* _tmp7_;
	MsmChannel* _tmp8_;
	MsmcommMisc* _tmp9_;
	MsmChannel* _tmp10_;
	MsmcommSim* _tmp11_;
	MsmChannel* _tmp12_;
	MsmcommPhonebook* _tmp13_;
	MsmChannel* _tmp14_;
	MsmcommSms* _tmp15_;
	MsmChannel* _tmp16_;
	MsmcommNetwork* _tmp17_;
	MsmChannel* _tmp18_;
	MsmcommCall* _tmp19_;
	g_return_if_fail (self != NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_tmp0_ = self->priv->already_connected;
	if (_tmp0_) {
		FsoFrameworkLogger* _tmp1_;
		_tmp1_ = ((FsoFrameworkAbstractObject*) self)->logger;
		fso_framework_logger_debug (_tmp1_, "We already have connected to the relevant dbus signals of the msmcomm " \
"daemon!");
		block4_data_unref (_data4_);
		_data4_ = NULL;
		return;
	}
	_tmp2_ = fso_gsm_theModem;
	_tmp3_ = fso_gsm_modem_channel (_tmp2_, "main");
	_data4_->channel = IS_MSM_CHANNEL (_tmp3_) ? ((MsmChannel*) _tmp3_) : NULL;
	_tmp4_ = _data4_->channel;
	_tmp5_ = _tmp4_->state_service;
	g_signal_connect_object (_tmp5_, "operation-mode", (GCallback) ___lambda0__msmcomm_state_operation_mode, self, 0);
	_tmp6_ = _data4_->channel;
	_tmp7_ = _tmp6_->misc_service;
	g_signal_connect_object (_tmp7_, "radio-reset-ind", (GCallback) ___lambda1__msmcomm_misc_radio_reset_ind, self, 0);
	_tmp8_ = _data4_->channel;
	_tmp9_ = _tmp8_->misc_service;
	g_signal_connect_object (_tmp9_, "cell-status", (GCallback) ___lambda2__msmcomm_misc_cell_status, self, 0);
	_tmp10_ = _data4_->channel;
	_tmp11_ = _tmp10_->sim_service;
	g_signal_connect_data (_tmp11_, "sim-status", (GCallback) ___lambda3__msmcomm_sim_sim_status, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
	_tmp12_ = _data4_->channel;
	_tmp13_ = _tmp12_->phonebook_service;
	g_signal_connect_object (_tmp13_, "ready", (GCallback) ___lambda4__msmcomm_phonebook_ready, self, 0);
	_tmp14_ = _data4_->channel;
	_tmp15_ = _tmp14_->sms_service;
	g_signal_connect_object (_tmp15_, "incoming-message", (GCallback) ___lambda5__msmcomm_sms_incoming_message, self, 0);
	_tmp16_ = _data4_->channel;
	_tmp17_ = _tmp16_->network_service;
	g_signal_connect_object (_tmp17_, "network-status", (GCallback) ___lambda7__msmcomm_network_network_status, self, 0);
	_tmp18_ = _data4_->channel;
	_tmp19_ = _tmp18_->call_service;
	g_signal_connect_object (_tmp19_, "call-status", (GCallback) ___lambda8__msmcomm_call_call_status, self, 0);
	self->priv->already_connected = TRUE;
	block4_data_unref (_data4_);
	_data4_ = NULL;
}


static gchar* msm_unsolicited_response_handler_real_repr (FsoFrameworkAbstractObject* base) {
	MsmUnsolicitedResponseHandler * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (MsmUnsolicitedResponseHandler*) base;
	_tmp0_ = g_strdup ("<>");
	result = _tmp0_;
	return result;
}


static void msm_unsolicited_response_handler_waitForUnsolicitedResponse_data_free (gpointer _data) {
	msm_unsolicited_response_handler_waitForUnsolicitedResponseData* _data_;
	_data_ = _data;
	_g_variant_unref0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (msm_unsolicited_response_handler_waitForUnsolicitedResponseData, _data_);
}


void msm_unsolicited_response_handler_waitForUnsolicitedResponse (MsmUnsolicitedResponseHandler* self, MsmUrcType type, gint timeout, GSourceFunc timeout_func, void* timeout_func_target, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	msm_unsolicited_response_handler_waitForUnsolicitedResponseData* _data_;
	MsmUnsolicitedResponseHandler* _tmp0_;
	MsmUrcType _tmp1_;
	gint _tmp2_;
	GSourceFunc _tmp3_;
	void* _tmp3__target;
	_data_ = g_slice_new0 (msm_unsolicited_response_handler_waitForUnsolicitedResponseData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, msm_unsolicited_response_handler_waitForUnsolicitedResponse);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, msm_unsolicited_response_handler_waitForUnsolicitedResponse_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = type;
	_data_->type = _tmp1_;
	_tmp2_ = timeout;
	_data_->timeout = _tmp2_;
	_tmp3_ = timeout_func;
	_tmp3__target = timeout_func_target;
	_data_->timeout_func = _tmp3_;
	_data_->timeout_func_target = _tmp3__target;
	msm_unsolicited_response_handler_waitForUnsolicitedResponse_co (_data_);
}


GVariant* msm_unsolicited_response_handler_waitForUnsolicitedResponse_finish (MsmUnsolicitedResponseHandler* self, GAsyncResult* _res_) {
	GVariant* result;
	msm_unsolicited_response_handler_waitForUnsolicitedResponseData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


/**
     * Lets wait for a specific unsolicited response to recieve and return it's payload
     * after it finaly recieves.
     **/
static Block5Data* block5_data_ref (Block5Data* _data5_) {
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}


static void block5_data_unref (Block5Data* _data5_) {
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		_g_object_unref0 (_data5_->self);
		_wait_for_unsolicited_response_data_unref0 (_data5_->data);
		g_slice_free (Block5Data, _data5_);
	}
}


static gboolean _msm_unsolicited_response_handler_waitForUnsolicitedResponse_co_gsource_func (gpointer self) {
	gboolean result;
	result = msm_unsolicited_response_handler_waitForUnsolicitedResponse_co (self);
	return result;
}


static gpointer _wait_for_unsolicited_response_data_ref0 (gpointer self) {
	return self ? wait_for_unsolicited_response_data_ref (self) : NULL;
}


static gboolean ___lambda9_ (Block5Data* _data5_) {
	MsmUnsolicitedResponseHandler * self;
	gboolean result = FALSE;
	WaitForUnsolicitedResponseData* _tmp0_;
	WaitForUnsolicitedResponseData* _tmp1_;
	GSourceFunc _tmp2_;
	void* _tmp2__target;
	WaitForUnsolicitedResponseData* _tmp5_;
	GSourceFunc _tmp6_;
	void* _tmp6__target;
	self = _data5_->self;
	_tmp0_ = _data5_->data;
	self->priv->urc_waiters = g_list_remove (self->priv->urc_waiters, _tmp0_);
	_tmp1_ = _data5_->data;
	_tmp2_ = _tmp1_->timeout_func;
	_tmp2__target = _tmp1_->timeout_func_target;
	if (_tmp2_ != NULL) {
		WaitForUnsolicitedResponseData* _tmp3_;
		GSourceFunc _tmp4_;
		void* _tmp4__target;
		_tmp3_ = _data5_->data;
		_tmp4_ = _tmp3_->timeout_func;
		_tmp4__target = _tmp3_->timeout_func_target;
		_tmp4_ (_tmp4__target);
	}
	_tmp5_ = _data5_->data;
	_tmp6_ = _tmp5_->callback;
	_tmp6__target = _tmp5_->callback_target;
	_tmp6_ (_tmp6__target);
	result = FALSE;
	return result;
}


static gboolean ____lambda9__gsource_func (gpointer self) {
	gboolean result;
	result = ___lambda9_ (self);
	return result;
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


static gboolean msm_unsolicited_response_handler_waitForUnsolicitedResponse_co (msm_unsolicited_response_handler_waitForUnsolicitedResponseData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_data5_ = g_slice_new0 (Block5Data);
	_data_->_data5_->_ref_count_ = 1;
	_data_->_data5_->self = g_object_ref (_data_->self);
	_data_->_data5_->_async_data_ = _data_;
	_data_->_tmp0_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
	_data_->_tmp1_ = _data_->type;
	_data_->_tmp2_ = g_enum_get_value (g_type_class_ref (TYPE_MSM_URC_TYPE), _data_->_tmp1_);
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = g_strconcat ("Create an new urc waiter with type = ", (_data_->_tmp2_ != NULL) ? _data_->_tmp2_->value_name : NULL, NULL);
	_data_->_tmp4_ = _data_->_tmp3_;
	fso_framework_logger_debug (_data_->_tmp0_, _data_->_tmp4_);
	_g_free0 (_data_->_tmp4_);
	_data_->_tmp5_ = wait_for_unsolicited_response_data_new ();
	_data_->_data5_->data = _data_->_tmp5_;
	_data_->_tmp6_ = _data_->_data5_->data;
	_data_->_tmp7_ = _data_->type;
	_data_->_tmp6_->urc_type = _data_->_tmp7_;
	_data_->_tmp8_ = _data_->_data5_->data;
	(_data_->_tmp8_->callback_target_destroy_notify == NULL) ? NULL : (_data_->_tmp8_->callback_target_destroy_notify (_data_->_tmp8_->callback_target), NULL);
	_data_->_tmp8_->callback = NULL;
	_data_->_tmp8_->callback_target = NULL;
	_data_->_tmp8_->callback_target_destroy_notify = NULL;
	_data_->_tmp8_->callback = _msm_unsolicited_response_handler_waitForUnsolicitedResponse_co_gsource_func;
	_data_->_tmp8_->callback_target = _data_;
	_data_->_tmp8_->callback_target_destroy_notify = NULL;
	_data_->_tmp9_ = _data_->_data5_->data;
	_data_->_tmp10_ = _data_->timeout_func;
	_data_->_tmp10__target = _data_->timeout_func_target;
	(_data_->_tmp9_->timeout_func_target_destroy_notify == NULL) ? NULL : (_data_->_tmp9_->timeout_func_target_destroy_notify (_data_->_tmp9_->timeout_func_target), NULL);
	_data_->_tmp9_->timeout_func = NULL;
	_data_->_tmp9_->timeout_func_target = NULL;
	_data_->_tmp9_->timeout_func_target_destroy_notify = NULL;
	_data_->_tmp9_->timeout_func = _data_->_tmp10_;
	_data_->_tmp9_->timeout_func_target = _data_->_tmp10__target;
	_data_->_tmp9_->timeout_func_target_destroy_notify = NULL;
	_data_->_tmp11_ = _data_->_data5_->data;
	_data_->_tmp12_ = _wait_for_unsolicited_response_data_ref0 (_data_->_tmp11_);
	_data_->self->priv->urc_waiters = g_list_append (_data_->self->priv->urc_waiters, _data_->_tmp12_);
	_data_->_tmp13_ = _data_->timeout;
	if (_data_->_tmp13_ > 0) {
		_data_->_tmp14_ = _data_->_data5_->data;
		_data_->_tmp15_ = _data_->timeout;
		_data_->_tmp16_ = 0U;
		_data_->_tmp16_ = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) _data_->_tmp15_, ____lambda9__gsource_func, block5_data_ref (_data_->_data5_), block5_data_unref);
		_data_->_tmp14_->timeout = _data_->_tmp16_;
	}
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	_data_->_tmp17_ = _data_->_data5_->data;
	_data_->self->priv->urc_waiters = g_list_remove (_data_->self->priv->urc_waiters, _data_->_tmp17_);
	_data_->_tmp18_ = _data_->_data5_->data;
	_data_->_tmp19_ = _data_->_tmp18_->response;
	_data_->_tmp20_ = _g_variant_ref0 (_data_->_tmp19_);
	_data_->result = _data_->_tmp20_;
	block5_data_unref (_data_->_data5_);
	_data_->_data5_ = NULL;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	block5_data_unref (_data_->_data5_);
	_data_->_data5_ = NULL;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void msm_unsolicited_response_handler_notifyUnsolicitedResponse_data_free (gpointer _data) {
	msm_unsolicited_response_handler_notifyUnsolicitedResponseData* _data_;
	_data_ = _data;
	_g_variant_unref0 (_data_->response);
	_g_object_unref0 (_data_->self);
	g_slice_free (msm_unsolicited_response_handler_notifyUnsolicitedResponseData, _data_);
}


void msm_unsolicited_response_handler_notifyUnsolicitedResponse (MsmUnsolicitedResponseHandler* self, MsmUrcType type, GVariant* response, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	msm_unsolicited_response_handler_notifyUnsolicitedResponseData* _data_;
	MsmUnsolicitedResponseHandler* _tmp0_;
	MsmUrcType _tmp1_;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	_data_ = g_slice_new0 (msm_unsolicited_response_handler_notifyUnsolicitedResponseData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, msm_unsolicited_response_handler_notifyUnsolicitedResponse);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, msm_unsolicited_response_handler_notifyUnsolicitedResponse_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = type;
	_data_->type = _tmp1_;
	_tmp2_ = response;
	_tmp3_ = _g_variant_ref0 (_tmp2_);
	_data_->response = _tmp3_;
	msm_unsolicited_response_handler_notifyUnsolicitedResponse_co (_data_);
}


void msm_unsolicited_response_handler_notifyUnsolicitedResponse_finish (MsmUnsolicitedResponseHandler* self, GAsyncResult* _res_) {
	msm_unsolicited_response_handler_notifyUnsolicitedResponseData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
     * Notify the occurence of a unsolicted response to the modem agent which informs all
     * registered clients for this type of message.
     **/
static gboolean msm_unsolicited_response_handler_notifyUnsolicitedResponse_co (msm_unsolicited_response_handler_notifyUnsolicitedResponseData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
	_data_->_tmp1_ = _data_->type;
	_data_->_tmp2_ = g_enum_get_value (g_type_class_ref (TYPE_MSM_URC_TYPE), _data_->_tmp1_);
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = g_strconcat ("Awake all waiters for urc type ", (_data_->_tmp2_ != NULL) ? _data_->_tmp2_->value_name : NULL, NULL);
	_data_->_tmp4_ = _data_->_tmp3_;
	fso_framework_logger_debug (_data_->_tmp0_, _data_->_tmp4_);
	_g_free0 (_data_->_tmp4_);
	_data_->_tmp5_ = _data_->type;
	_data_->_tmp6_ = NULL;
	_data_->_tmp6_ = msm_unsolicited_response_handler_retriveUrcWaiters (_data_->self, _data_->_tmp5_);
	_data_->waiters = _data_->_tmp6_;
	_data_->_tmp7_ = _data_->waiters;
	{
		_data_->waiter_collection = _data_->_tmp7_;
		_data_->waiter_it = NULL;
		for (_data_->waiter_it = _data_->waiter_collection; _data_->waiter_it != NULL; _data_->waiter_it = _data_->waiter_it->next) {
			_data_->_tmp8_ = _wait_for_unsolicited_response_data_ref0 ((WaitForUnsolicitedResponseData*) _data_->waiter_it->data);
			_data_->waiter = _data_->_tmp8_;
			{
				_data_->_tmp9_ = _data_->waiter;
				_data_->_tmp10_ = _data_->_tmp9_->timeout;
				if (_data_->_tmp10_ > ((guint) 0)) {
					_data_->_tmp11_ = _data_->waiter;
					_data_->_tmp12_ = _data_->_tmp11_->timeout;
					g_source_remove (_data_->_tmp12_);
					_data_->_tmp13_ = _data_->waiter;
					_data_->_tmp13_->timeout = (guint) 0;
				}
				_data_->_tmp14_ = _data_->waiter;
				_data_->self->priv->urc_waiters = g_list_remove (_data_->self->priv->urc_waiters, _data_->_tmp14_);
				_data_->_tmp15_ = _data_->waiter;
				_data_->_tmp16_ = _data_->response;
				_data_->_tmp17_ = _g_variant_ref0 (_data_->_tmp16_);
				_g_variant_unref0 (_data_->_tmp15_->response);
				_data_->_tmp15_->response = _data_->_tmp17_;
				_data_->_tmp18_ = _data_->waiter;
				_data_->_tmp19_ = _data_->_tmp18_->callback;
				_data_->_tmp19__target = _data_->_tmp18_->callback_target;
				_data_->_tmp19_ (_data_->_tmp19__target);
				_wait_for_unsolicited_response_data_unref0 (_data_->waiter);
			}
		}
	}
	__g_list_free__wait_for_unsolicited_response_data_unref0_0 (_data_->waiters);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static GList* msm_unsolicited_response_handler_retriveUrcWaiters (MsmUnsolicitedResponseHandler* self, MsmUrcType type) {
	GList* result = NULL;
	GList* _result_;
	GList* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = NULL;
	_tmp0_ = self->priv->urc_waiters;
	{
		GList* waiter_collection = NULL;
		GList* waiter_it = NULL;
		waiter_collection = _tmp0_;
		for (waiter_it = waiter_collection; waiter_it != NULL; waiter_it = waiter_it->next) {
			WaitForUnsolicitedResponseData* _tmp1_;
			WaitForUnsolicitedResponseData* waiter = NULL;
			_tmp1_ = _wait_for_unsolicited_response_data_ref0 ((WaitForUnsolicitedResponseData*) waiter_it->data);
			waiter = _tmp1_;
			{
				WaitForUnsolicitedResponseData* _tmp2_;
				MsmUrcType _tmp3_;
				MsmUrcType _tmp4_;
				_tmp2_ = waiter;
				_tmp3_ = _tmp2_->urc_type;
				_tmp4_ = type;
				if (_tmp3_ == _tmp4_) {
					WaitForUnsolicitedResponseData* _tmp5_;
					WaitForUnsolicitedResponseData* _tmp6_;
					_tmp5_ = waiter;
					_tmp6_ = _wait_for_unsolicited_response_data_ref0 (_tmp5_);
					_result_ = g_list_append (_result_, _tmp6_);
				}
				_wait_for_unsolicited_response_data_unref0 (waiter);
			}
		}
	}
	result = _result_;
	return result;
}


static void msm_unsolicited_response_handler_class_init (MsmUnsolicitedResponseHandlerClass * klass) {
	msm_unsolicited_response_handler_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MsmUnsolicitedResponseHandlerPrivate));
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = msm_unsolicited_response_handler_real_repr;
	G_OBJECT_CLASS (klass)->finalize = msm_unsolicited_response_handler_finalize;
}


static void msm_unsolicited_response_handler_instance_init (MsmUnsolicitedResponseHandler * self) {
	self->priv = MSM_UNSOLICITED_RESPONSE_HANDLER_GET_PRIVATE (self);
	self->priv->already_connected = FALSE;
}


static void msm_unsolicited_response_handler_finalize (GObject* obj) {
	MsmUnsolicitedResponseHandler * self;
	self = MSM_UNSOLICITED_RESPONSE_HANDLER (obj);
	__g_list_free__wait_for_unsolicited_response_data_unref0_0 (self->priv->urc_waiters);
	G_OBJECT_CLASS (msm_unsolicited_response_handler_parent_class)->finalize (obj);
}


/**
 * MSM Unsolicited Base Class and Handler
 **/
GType msm_unsolicited_response_handler_get_type (void) {
	return msm_unsolicited_response_handler_type_id;
}


GType msm_unsolicited_response_handler_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (MsmUnsolicitedResponseHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) msm_unsolicited_response_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MsmUnsolicitedResponseHandler), 0, (GInstanceInitFunc) msm_unsolicited_response_handler_instance_init, NULL };
	msm_unsolicited_response_handler_type_id = g_type_module_register_type (module, FSO_FRAMEWORK_TYPE_ABSTRACT_OBJECT, "MsmUnsolicitedResponseHandler", &g_define_type_info, 0);
	return msm_unsolicited_response_handler_type_id;
}



