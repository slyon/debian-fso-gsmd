/* mediators_call.c generated by valac 0.14.2, the Vala compiler
 * generated from mediators_call.vala, do not modify */

/*
 * Copyright (C) 2010-2011 Simon Busch <morphis@gravedo.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <fsogsm.h>
#include <gio/gio.h>
#include <freesmartphone.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_MSM_CALL_ACTIVATE (msm_call_activate_get_type ())
#define MSM_CALL_ACTIVATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_CALL_ACTIVATE, MsmCallActivate))
#define MSM_CALL_ACTIVATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_CALL_ACTIVATE, MsmCallActivateClass))
#define IS_MSM_CALL_ACTIVATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_CALL_ACTIVATE))
#define IS_MSM_CALL_ACTIVATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_CALL_ACTIVATE))
#define MSM_CALL_ACTIVATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_CALL_ACTIVATE, MsmCallActivateClass))

typedef struct _MsmCallActivate MsmCallActivate;
typedef struct _MsmCallActivateClass MsmCallActivateClass;
typedef struct _MsmCallActivatePrivate MsmCallActivatePrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _MsmCallActivateRunData MsmCallActivateRunData;

#define TYPE_MSM_CALL_HOLD_ACTIVE (msm_call_hold_active_get_type ())
#define MSM_CALL_HOLD_ACTIVE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_CALL_HOLD_ACTIVE, MsmCallHoldActive))
#define MSM_CALL_HOLD_ACTIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_CALL_HOLD_ACTIVE, MsmCallHoldActiveClass))
#define IS_MSM_CALL_HOLD_ACTIVE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_CALL_HOLD_ACTIVE))
#define IS_MSM_CALL_HOLD_ACTIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_CALL_HOLD_ACTIVE))
#define MSM_CALL_HOLD_ACTIVE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_CALL_HOLD_ACTIVE, MsmCallHoldActiveClass))

typedef struct _MsmCallHoldActive MsmCallHoldActive;
typedef struct _MsmCallHoldActiveClass MsmCallHoldActiveClass;
typedef struct _MsmCallHoldActivePrivate MsmCallHoldActivePrivate;
typedef struct _MsmCallHoldActiveRunData MsmCallHoldActiveRunData;

#define TYPE_MSM_CALL_INITIATE (msm_call_initiate_get_type ())
#define MSM_CALL_INITIATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_CALL_INITIATE, MsmCallInitiate))
#define MSM_CALL_INITIATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_CALL_INITIATE, MsmCallInitiateClass))
#define IS_MSM_CALL_INITIATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_CALL_INITIATE))
#define IS_MSM_CALL_INITIATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_CALL_INITIATE))
#define MSM_CALL_INITIATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_CALL_INITIATE, MsmCallInitiateClass))

typedef struct _MsmCallInitiate MsmCallInitiate;
typedef struct _MsmCallInitiateClass MsmCallInitiateClass;
typedef struct _MsmCallInitiatePrivate MsmCallInitiatePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _MsmCallInitiateRunData MsmCallInitiateRunData;

#define TYPE_MSM_CALL_LIST_CALLS (msm_call_list_calls_get_type ())
#define MSM_CALL_LIST_CALLS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_CALL_LIST_CALLS, MsmCallListCalls))
#define MSM_CALL_LIST_CALLS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_CALL_LIST_CALLS, MsmCallListCallsClass))
#define IS_MSM_CALL_LIST_CALLS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_CALL_LIST_CALLS))
#define IS_MSM_CALL_LIST_CALLS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_CALL_LIST_CALLS))
#define MSM_CALL_LIST_CALLS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_CALL_LIST_CALLS, MsmCallListCallsClass))

typedef struct _MsmCallListCalls MsmCallListCalls;
typedef struct _MsmCallListCallsClass MsmCallListCallsClass;
typedef struct _MsmCallListCallsPrivate MsmCallListCallsPrivate;
typedef struct _MsmCallListCallsRunData MsmCallListCallsRunData;

#define TYPE_MSM_CALL_SEND_DTMF (msm_call_send_dtmf_get_type ())
#define MSM_CALL_SEND_DTMF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_CALL_SEND_DTMF, MsmCallSendDtmf))
#define MSM_CALL_SEND_DTMF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_CALL_SEND_DTMF, MsmCallSendDtmfClass))
#define IS_MSM_CALL_SEND_DTMF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_CALL_SEND_DTMF))
#define IS_MSM_CALL_SEND_DTMF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_CALL_SEND_DTMF))
#define MSM_CALL_SEND_DTMF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_CALL_SEND_DTMF, MsmCallSendDtmfClass))

typedef struct _MsmCallSendDtmf MsmCallSendDtmf;
typedef struct _MsmCallSendDtmfClass MsmCallSendDtmfClass;
typedef struct _MsmCallSendDtmfPrivate MsmCallSendDtmfPrivate;
typedef struct _MsmCallSendDtmfRunData MsmCallSendDtmfRunData;

#define TYPE_MSM_CALL_RELEASE (msm_call_release_get_type ())
#define MSM_CALL_RELEASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_CALL_RELEASE, MsmCallRelease))
#define MSM_CALL_RELEASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_CALL_RELEASE, MsmCallReleaseClass))
#define IS_MSM_CALL_RELEASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_CALL_RELEASE))
#define IS_MSM_CALL_RELEASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_CALL_RELEASE))
#define MSM_CALL_RELEASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_CALL_RELEASE, MsmCallReleaseClass))

typedef struct _MsmCallRelease MsmCallRelease;
typedef struct _MsmCallReleaseClass MsmCallReleaseClass;
typedef struct _MsmCallReleasePrivate MsmCallReleasePrivate;
typedef struct _MsmCallReleaseRunData MsmCallReleaseRunData;

#define TYPE_MSM_CALL_RELEASE_ALL (msm_call_release_all_get_type ())
#define MSM_CALL_RELEASE_ALL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MSM_CALL_RELEASE_ALL, MsmCallReleaseAll))
#define MSM_CALL_RELEASE_ALL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MSM_CALL_RELEASE_ALL, MsmCallReleaseAllClass))
#define IS_MSM_CALL_RELEASE_ALL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MSM_CALL_RELEASE_ALL))
#define IS_MSM_CALL_RELEASE_ALL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MSM_CALL_RELEASE_ALL))
#define MSM_CALL_RELEASE_ALL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MSM_CALL_RELEASE_ALL, MsmCallReleaseAllClass))

typedef struct _MsmCallReleaseAll MsmCallReleaseAll;
typedef struct _MsmCallReleaseAllClass MsmCallReleaseAllClass;
typedef struct _MsmCallReleaseAllPrivate MsmCallReleaseAllPrivate;
typedef struct _MsmCallReleaseAllRunData MsmCallReleaseAllRunData;

struct _MsmCallActivate {
	FsoGsmCallActivate parent_instance;
	MsmCallActivatePrivate * priv;
};

struct _MsmCallActivateClass {
	FsoGsmCallActivateClass parent_class;
};

struct _MsmCallActivateRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	MsmCallActivate* self;
	gint id;
	FsoGsmModem* _tmp0_;
	FsoGsmCallHandler* _tmp1_;
	FsoGsmCallHandler* _tmp2_;
	gint _tmp3_;
	GError * _inner_error_;
};

struct _MsmCallHoldActive {
	FsoGsmCallHoldActive parent_instance;
	MsmCallHoldActivePrivate * priv;
};

struct _MsmCallHoldActiveClass {
	FsoGsmCallHoldActiveClass parent_class;
};

struct _MsmCallHoldActiveRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	MsmCallHoldActive* self;
	FsoGsmModem* _tmp0_;
	FsoGsmCallHandler* _tmp1_;
	FsoGsmCallHandler* _tmp2_;
	GError * _inner_error_;
};

struct _MsmCallInitiate {
	FsoGsmCallInitiate parent_instance;
	MsmCallInitiatePrivate * priv;
};

struct _MsmCallInitiateClass {
	FsoGsmCallInitiateClass parent_class;
};

struct _MsmCallInitiateRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	MsmCallInitiate* self;
	gchar* number;
	gchar* ctype;
	const gchar* _tmp0_;
	FsoGsmModem* _tmp1_;
	FsoGsmCallHandler* _tmp2_;
	FsoGsmCallHandler* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	GError * _inner_error_;
};

struct _MsmCallListCalls {
	FsoGsmCallListCalls parent_instance;
	MsmCallListCallsPrivate * priv;
};

struct _MsmCallListCallsClass {
	FsoGsmCallListCallsClass parent_class;
};

struct _MsmCallListCallsRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	MsmCallListCalls* self;
	GError* _tmp0_;
	GError * _inner_error_;
};

struct _MsmCallSendDtmf {
	FsoGsmCallSendDtmf parent_instance;
	MsmCallSendDtmfPrivate * priv;
};

struct _MsmCallSendDtmfClass {
	FsoGsmCallSendDtmfClass parent_class;
};

struct _MsmCallSendDtmfRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	MsmCallSendDtmf* self;
	gchar* tones;
	GError* _tmp0_;
	GError * _inner_error_;
};

struct _MsmCallRelease {
	FsoGsmCallRelease parent_instance;
	MsmCallReleasePrivate * priv;
};

struct _MsmCallReleaseClass {
	FsoGsmCallReleaseClass parent_class;
};

struct _MsmCallReleaseRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	MsmCallRelease* self;
	gint id;
	FsoGsmModem* _tmp0_;
	FsoGsmCallHandler* _tmp1_;
	FsoGsmCallHandler* _tmp2_;
	gint _tmp3_;
	GError * _inner_error_;
};

struct _MsmCallReleaseAll {
	FsoGsmCallReleaseAll parent_instance;
	MsmCallReleaseAllPrivate * priv;
};

struct _MsmCallReleaseAllClass {
	FsoGsmCallReleaseAllClass parent_class;
};

struct _MsmCallReleaseAllRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	MsmCallReleaseAll* self;
	FsoGsmModem* _tmp0_;
	FsoGsmCallHandler* _tmp1_;
	FsoGsmCallHandler* _tmp2_;
	GError * _inner_error_;
};


static gpointer msm_call_activate_parent_class = NULL;
static GType msm_call_activate_type_id = 0;
static gpointer msm_call_hold_active_parent_class = NULL;
static GType msm_call_hold_active_type_id = 0;
static gpointer msm_call_initiate_parent_class = NULL;
static GType msm_call_initiate_type_id = 0;
static gpointer msm_call_list_calls_parent_class = NULL;
static GType msm_call_list_calls_type_id = 0;
static gpointer msm_call_send_dtmf_parent_class = NULL;
static GType msm_call_send_dtmf_type_id = 0;
static gpointer msm_call_release_parent_class = NULL;
static GType msm_call_release_type_id = 0;
static gpointer msm_call_release_all_parent_class = NULL;
static GType msm_call_release_all_type_id = 0;

GType msm_call_activate_get_type (void) G_GNUC_CONST;
GType msm_call_activate_register_type (GTypeModule * module);
enum  {
	MSM_CALL_ACTIVATE_DUMMY_PROPERTY
};
static void msm_call_activate_real_run_data_free (gpointer _data);
static void msm_call_activate_real_run (FsoGsmCallActivate* base, gint id, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean msm_call_activate_real_run_co (MsmCallActivateRunData* _data_);
static void msm_call_activate_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
MsmCallActivate* msm_call_activate_new (void);
MsmCallActivate* msm_call_activate_construct (GType object_type);
GType msm_call_hold_active_get_type (void) G_GNUC_CONST;
GType msm_call_hold_active_register_type (GTypeModule * module);
enum  {
	MSM_CALL_HOLD_ACTIVE_DUMMY_PROPERTY
};
static void msm_call_hold_active_real_run_data_free (gpointer _data);
static void msm_call_hold_active_real_run (FsoGsmCallHoldActive* base, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean msm_call_hold_active_real_run_co (MsmCallHoldActiveRunData* _data_);
static void msm_call_hold_active_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
MsmCallHoldActive* msm_call_hold_active_new (void);
MsmCallHoldActive* msm_call_hold_active_construct (GType object_type);
GType msm_call_initiate_get_type (void) G_GNUC_CONST;
GType msm_call_initiate_register_type (GTypeModule * module);
enum  {
	MSM_CALL_INITIATE_DUMMY_PROPERTY
};
static void msm_call_initiate_real_run_data_free (gpointer _data);
static void msm_call_initiate_real_run (FsoGsmCallInitiate* base, const gchar* number, const gchar* ctype, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean msm_call_initiate_real_run_co (MsmCallInitiateRunData* _data_);
static void msm_call_initiate_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
MsmCallInitiate* msm_call_initiate_new (void);
MsmCallInitiate* msm_call_initiate_construct (GType object_type);
GType msm_call_list_calls_get_type (void) G_GNUC_CONST;
GType msm_call_list_calls_register_type (GTypeModule * module);
enum  {
	MSM_CALL_LIST_CALLS_DUMMY_PROPERTY
};
static void msm_call_list_calls_real_run_data_free (gpointer _data);
static void msm_call_list_calls_real_run (FsoGsmCallListCalls* base, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean msm_call_list_calls_real_run_co (MsmCallListCallsRunData* _data_);
MsmCallListCalls* msm_call_list_calls_new (void);
MsmCallListCalls* msm_call_list_calls_construct (GType object_type);
GType msm_call_send_dtmf_get_type (void) G_GNUC_CONST;
GType msm_call_send_dtmf_register_type (GTypeModule * module);
enum  {
	MSM_CALL_SEND_DTMF_DUMMY_PROPERTY
};
static void msm_call_send_dtmf_real_run_data_free (gpointer _data);
static void msm_call_send_dtmf_real_run (FsoGsmCallSendDtmf* base, const gchar* tones, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean msm_call_send_dtmf_real_run_co (MsmCallSendDtmfRunData* _data_);
MsmCallSendDtmf* msm_call_send_dtmf_new (void);
MsmCallSendDtmf* msm_call_send_dtmf_construct (GType object_type);
GType msm_call_release_get_type (void) G_GNUC_CONST;
GType msm_call_release_register_type (GTypeModule * module);
enum  {
	MSM_CALL_RELEASE_DUMMY_PROPERTY
};
static void msm_call_release_real_run_data_free (gpointer _data);
static void msm_call_release_real_run (FsoGsmCallRelease* base, gint id, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean msm_call_release_real_run_co (MsmCallReleaseRunData* _data_);
static void msm_call_release_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
MsmCallRelease* msm_call_release_new (void);
MsmCallRelease* msm_call_release_construct (GType object_type);
GType msm_call_release_all_get_type (void) G_GNUC_CONST;
GType msm_call_release_all_register_type (GTypeModule * module);
enum  {
	MSM_CALL_RELEASE_ALL_DUMMY_PROPERTY
};
static void msm_call_release_all_real_run_data_free (gpointer _data);
static void msm_call_release_all_real_run (FsoGsmCallReleaseAll* base, GAsyncReadyCallback _callback_, gpointer _user_data_);
static gboolean msm_call_release_all_real_run_co (MsmCallReleaseAllRunData* _data_);
static void msm_call_release_all_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
MsmCallReleaseAll* msm_call_release_all_new (void);
MsmCallReleaseAll* msm_call_release_all_construct (GType object_type);


static void msm_call_activate_real_run_data_free (gpointer _data) {
	MsmCallActivateRunData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (MsmCallActivateRunData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void msm_call_activate_real_run (FsoGsmCallActivate* base, gint id, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	MsmCallActivate * self;
	MsmCallActivateRunData* _data_;
	MsmCallActivate* _tmp0_;
	gint _tmp1_;
	self = (MsmCallActivate*) base;
	_data_ = g_slice_new0 (MsmCallActivateRunData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, msm_call_activate_real_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, msm_call_activate_real_run_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = id;
	_data_->id = _tmp1_;
	msm_call_activate_real_run_co (_data_);
}


static void msm_call_activate_real_run_finish (FsoGsmCallActivate* base, GAsyncResult* _res_, GError** error) {
	MsmCallActivateRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void msm_call_activate_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	MsmCallActivateRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	msm_call_activate_real_run_co (_data_);
}


static gboolean msm_call_activate_real_run_co (MsmCallActivateRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = fso_gsm_theModem;
	_data_->_tmp1_ = fso_gsm_modem_get_callhandler (_data_->_tmp0_);
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->_tmp3_ = _data_->id;
	_data_->_state_ = 1;
	fso_gsm_call_handler_activate (_data_->_tmp2_, _data_->_tmp3_, msm_call_activate_run_ready, _data_);
	return FALSE;
	_state_1:
	fso_gsm_call_handler_activate_finish (_data_->_tmp2_, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_GSM_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


MsmCallActivate* msm_call_activate_construct (GType object_type) {
	MsmCallActivate * self = NULL;
	self = (MsmCallActivate*) fso_gsm_call_activate_construct (object_type);
	return self;
}


MsmCallActivate* msm_call_activate_new (void) {
	return msm_call_activate_construct (TYPE_MSM_CALL_ACTIVATE);
}


static void msm_call_activate_class_init (MsmCallActivateClass * klass) {
	msm_call_activate_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_CALL_ACTIVATE_CLASS (klass)->run = msm_call_activate_real_run;
	FSO_GSM_CALL_ACTIVATE_CLASS (klass)->run_finish = msm_call_activate_real_run_finish;
}


static void msm_call_activate_instance_init (MsmCallActivate * self) {
}


GType msm_call_activate_get_type (void) {
	return msm_call_activate_type_id;
}


GType msm_call_activate_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (MsmCallActivateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) msm_call_activate_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MsmCallActivate), 0, (GInstanceInitFunc) msm_call_activate_instance_init, NULL };
	msm_call_activate_type_id = g_type_module_register_type (module, FSO_GSM_TYPE_CALL_ACTIVATE, "MsmCallActivate", &g_define_type_info, 0);
	return msm_call_activate_type_id;
}


static void msm_call_hold_active_real_run_data_free (gpointer _data) {
	MsmCallHoldActiveRunData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (MsmCallHoldActiveRunData, _data_);
}


static void msm_call_hold_active_real_run (FsoGsmCallHoldActive* base, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	MsmCallHoldActive * self;
	MsmCallHoldActiveRunData* _data_;
	MsmCallHoldActive* _tmp0_;
	self = (MsmCallHoldActive*) base;
	_data_ = g_slice_new0 (MsmCallHoldActiveRunData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, msm_call_hold_active_real_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, msm_call_hold_active_real_run_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	msm_call_hold_active_real_run_co (_data_);
}


static void msm_call_hold_active_real_run_finish (FsoGsmCallHoldActive* base, GAsyncResult* _res_, GError** error) {
	MsmCallHoldActiveRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void msm_call_hold_active_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	MsmCallHoldActiveRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	msm_call_hold_active_real_run_co (_data_);
}


static gboolean msm_call_hold_active_real_run_co (MsmCallHoldActiveRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = fso_gsm_theModem;
	_data_->_tmp1_ = fso_gsm_modem_get_callhandler (_data_->_tmp0_);
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->_state_ = 1;
	fso_gsm_call_handler_hold (_data_->_tmp2_, msm_call_hold_active_run_ready, _data_);
	return FALSE;
	_state_1:
	fso_gsm_call_handler_hold_finish (_data_->_tmp2_, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_GSM_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


MsmCallHoldActive* msm_call_hold_active_construct (GType object_type) {
	MsmCallHoldActive * self = NULL;
	self = (MsmCallHoldActive*) fso_gsm_call_hold_active_construct (object_type);
	return self;
}


MsmCallHoldActive* msm_call_hold_active_new (void) {
	return msm_call_hold_active_construct (TYPE_MSM_CALL_HOLD_ACTIVE);
}


static void msm_call_hold_active_class_init (MsmCallHoldActiveClass * klass) {
	msm_call_hold_active_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_CALL_HOLD_ACTIVE_CLASS (klass)->run = msm_call_hold_active_real_run;
	FSO_GSM_CALL_HOLD_ACTIVE_CLASS (klass)->run_finish = msm_call_hold_active_real_run_finish;
}


static void msm_call_hold_active_instance_init (MsmCallHoldActive * self) {
}


GType msm_call_hold_active_get_type (void) {
	return msm_call_hold_active_type_id;
}


GType msm_call_hold_active_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (MsmCallHoldActiveClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) msm_call_hold_active_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MsmCallHoldActive), 0, (GInstanceInitFunc) msm_call_hold_active_instance_init, NULL };
	msm_call_hold_active_type_id = g_type_module_register_type (module, FSO_GSM_TYPE_CALL_HOLD_ACTIVE, "MsmCallHoldActive", &g_define_type_info, 0);
	return msm_call_hold_active_type_id;
}


static void msm_call_initiate_real_run_data_free (gpointer _data) {
	MsmCallInitiateRunData* _data_;
	_data_ = _data;
	_g_free0 (_data_->number);
	_g_free0 (_data_->ctype);
	_g_object_unref0 (_data_->self);
	g_slice_free (MsmCallInitiateRunData, _data_);
}


static void msm_call_initiate_real_run (FsoGsmCallInitiate* base, const gchar* number, const gchar* ctype, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	MsmCallInitiate * self;
	MsmCallInitiateRunData* _data_;
	MsmCallInitiate* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	self = (MsmCallInitiate*) base;
	_data_ = g_slice_new0 (MsmCallInitiateRunData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, msm_call_initiate_real_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, msm_call_initiate_real_run_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = number;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->number = _tmp2_;
	_tmp3_ = ctype;
	_tmp4_ = g_strdup (_tmp3_);
	_data_->ctype = _tmp4_;
	msm_call_initiate_real_run_co (_data_);
}


static void msm_call_initiate_real_run_finish (FsoGsmCallInitiate* base, GAsyncResult* _res_, GError** error) {
	MsmCallInitiateRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void msm_call_initiate_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	MsmCallInitiateRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	msm_call_initiate_real_run_co (_data_);
}


static gboolean msm_call_initiate_real_run_co (MsmCallInitiateRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->number;
	fso_gsm_validatePhoneNumber (_data_->_tmp0_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_GSM_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp1_ = fso_gsm_theModem;
	_data_->_tmp2_ = fso_gsm_modem_get_callhandler (_data_->_tmp1_);
	_data_->_tmp3_ = _data_->_tmp2_;
	_data_->_tmp4_ = _data_->number;
	_data_->_tmp5_ = _data_->ctype;
	_data_->_state_ = 1;
	fso_gsm_call_handler_initiate (_data_->_tmp3_, _data_->_tmp4_, _data_->_tmp5_, msm_call_initiate_run_ready, _data_);
	return FALSE;
	_state_1:
	_data_->_tmp6_ = 0;
	_data_->_tmp6_ = fso_gsm_call_handler_initiate_finish (_data_->_tmp3_, _data_->_res_, &_data_->_inner_error_);
	_data_->_tmp7_ = _data_->_tmp6_;
	if (_data_->_inner_error_ != NULL) {
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_GSM_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	fso_gsm_call_initiate_set_id ((FsoGsmCallInitiate*) _data_->self, _data_->_tmp7_);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


MsmCallInitiate* msm_call_initiate_construct (GType object_type) {
	MsmCallInitiate * self = NULL;
	self = (MsmCallInitiate*) fso_gsm_call_initiate_construct (object_type);
	return self;
}


MsmCallInitiate* msm_call_initiate_new (void) {
	return msm_call_initiate_construct (TYPE_MSM_CALL_INITIATE);
}


static void msm_call_initiate_class_init (MsmCallInitiateClass * klass) {
	msm_call_initiate_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_CALL_INITIATE_CLASS (klass)->run = msm_call_initiate_real_run;
	FSO_GSM_CALL_INITIATE_CLASS (klass)->run_finish = msm_call_initiate_real_run_finish;
}


static void msm_call_initiate_instance_init (MsmCallInitiate * self) {
}


GType msm_call_initiate_get_type (void) {
	return msm_call_initiate_type_id;
}


GType msm_call_initiate_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (MsmCallInitiateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) msm_call_initiate_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MsmCallInitiate), 0, (GInstanceInitFunc) msm_call_initiate_instance_init, NULL };
	msm_call_initiate_type_id = g_type_module_register_type (module, FSO_GSM_TYPE_CALL_INITIATE, "MsmCallInitiate", &g_define_type_info, 0);
	return msm_call_initiate_type_id;
}


static void msm_call_list_calls_real_run_data_free (gpointer _data) {
	MsmCallListCallsRunData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (MsmCallListCallsRunData, _data_);
}


static void msm_call_list_calls_real_run (FsoGsmCallListCalls* base, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	MsmCallListCalls * self;
	MsmCallListCallsRunData* _data_;
	MsmCallListCalls* _tmp0_;
	self = (MsmCallListCalls*) base;
	_data_ = g_slice_new0 (MsmCallListCallsRunData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, msm_call_list_calls_real_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, msm_call_list_calls_real_run_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	msm_call_list_calls_real_run_co (_data_);
}


static void msm_call_list_calls_real_run_finish (FsoGsmCallListCalls* base, GAsyncResult* _res_, GError** error) {
	MsmCallListCallsRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean msm_call_list_calls_real_run_co (MsmCallListCallsRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = g_error_new_literal (FREE_SMARTPHONE_ERROR, FREE_SMARTPHONE_ERROR_UNSUPPORTED, "Not implemented yet!");
	_data_->_inner_error_ = _data_->_tmp0_;
	if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_GSM_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
		g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
		g_error_free (_data_->_inner_error_);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	} else {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


MsmCallListCalls* msm_call_list_calls_construct (GType object_type) {
	MsmCallListCalls * self = NULL;
	self = (MsmCallListCalls*) fso_gsm_call_list_calls_construct (object_type);
	return self;
}


MsmCallListCalls* msm_call_list_calls_new (void) {
	return msm_call_list_calls_construct (TYPE_MSM_CALL_LIST_CALLS);
}


static void msm_call_list_calls_class_init (MsmCallListCallsClass * klass) {
	msm_call_list_calls_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_CALL_LIST_CALLS_CLASS (klass)->run = msm_call_list_calls_real_run;
	FSO_GSM_CALL_LIST_CALLS_CLASS (klass)->run_finish = msm_call_list_calls_real_run_finish;
}


static void msm_call_list_calls_instance_init (MsmCallListCalls * self) {
}


GType msm_call_list_calls_get_type (void) {
	return msm_call_list_calls_type_id;
}


GType msm_call_list_calls_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (MsmCallListCallsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) msm_call_list_calls_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MsmCallListCalls), 0, (GInstanceInitFunc) msm_call_list_calls_instance_init, NULL };
	msm_call_list_calls_type_id = g_type_module_register_type (module, FSO_GSM_TYPE_CALL_LIST_CALLS, "MsmCallListCalls", &g_define_type_info, 0);
	return msm_call_list_calls_type_id;
}


static void msm_call_send_dtmf_real_run_data_free (gpointer _data) {
	MsmCallSendDtmfRunData* _data_;
	_data_ = _data;
	_g_free0 (_data_->tones);
	_g_object_unref0 (_data_->self);
	g_slice_free (MsmCallSendDtmfRunData, _data_);
}


static void msm_call_send_dtmf_real_run (FsoGsmCallSendDtmf* base, const gchar* tones, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	MsmCallSendDtmf * self;
	MsmCallSendDtmfRunData* _data_;
	MsmCallSendDtmf* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	self = (MsmCallSendDtmf*) base;
	_data_ = g_slice_new0 (MsmCallSendDtmfRunData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, msm_call_send_dtmf_real_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, msm_call_send_dtmf_real_run_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = tones;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->tones = _tmp2_;
	msm_call_send_dtmf_real_run_co (_data_);
}


static void msm_call_send_dtmf_real_run_finish (FsoGsmCallSendDtmf* base, GAsyncResult* _res_, GError** error) {
	MsmCallSendDtmfRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean msm_call_send_dtmf_real_run_co (MsmCallSendDtmfRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = g_error_new_literal (FREE_SMARTPHONE_ERROR, FREE_SMARTPHONE_ERROR_UNSUPPORTED, "Not implemented yet!");
	_data_->_inner_error_ = _data_->_tmp0_;
	if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_GSM_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
		g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
		g_error_free (_data_->_inner_error_);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	} else {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


MsmCallSendDtmf* msm_call_send_dtmf_construct (GType object_type) {
	MsmCallSendDtmf * self = NULL;
	self = (MsmCallSendDtmf*) fso_gsm_call_send_dtmf_construct (object_type);
	return self;
}


MsmCallSendDtmf* msm_call_send_dtmf_new (void) {
	return msm_call_send_dtmf_construct (TYPE_MSM_CALL_SEND_DTMF);
}


static void msm_call_send_dtmf_class_init (MsmCallSendDtmfClass * klass) {
	msm_call_send_dtmf_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_CALL_SEND_DTMF_CLASS (klass)->run = msm_call_send_dtmf_real_run;
	FSO_GSM_CALL_SEND_DTMF_CLASS (klass)->run_finish = msm_call_send_dtmf_real_run_finish;
}


static void msm_call_send_dtmf_instance_init (MsmCallSendDtmf * self) {
}


GType msm_call_send_dtmf_get_type (void) {
	return msm_call_send_dtmf_type_id;
}


GType msm_call_send_dtmf_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (MsmCallSendDtmfClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) msm_call_send_dtmf_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MsmCallSendDtmf), 0, (GInstanceInitFunc) msm_call_send_dtmf_instance_init, NULL };
	msm_call_send_dtmf_type_id = g_type_module_register_type (module, FSO_GSM_TYPE_CALL_SEND_DTMF, "MsmCallSendDtmf", &g_define_type_info, 0);
	return msm_call_send_dtmf_type_id;
}


static void msm_call_release_real_run_data_free (gpointer _data) {
	MsmCallReleaseRunData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (MsmCallReleaseRunData, _data_);
}


static void msm_call_release_real_run (FsoGsmCallRelease* base, gint id, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	MsmCallRelease * self;
	MsmCallReleaseRunData* _data_;
	MsmCallRelease* _tmp0_;
	gint _tmp1_;
	self = (MsmCallRelease*) base;
	_data_ = g_slice_new0 (MsmCallReleaseRunData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, msm_call_release_real_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, msm_call_release_real_run_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = id;
	_data_->id = _tmp1_;
	msm_call_release_real_run_co (_data_);
}


static void msm_call_release_real_run_finish (FsoGsmCallRelease* base, GAsyncResult* _res_, GError** error) {
	MsmCallReleaseRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void msm_call_release_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	MsmCallReleaseRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	msm_call_release_real_run_co (_data_);
}


static gboolean msm_call_release_real_run_co (MsmCallReleaseRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = fso_gsm_theModem;
	_data_->_tmp1_ = fso_gsm_modem_get_callhandler (_data_->_tmp0_);
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->_tmp3_ = _data_->id;
	_data_->_state_ = 1;
	fso_gsm_call_handler_release (_data_->_tmp2_, _data_->_tmp3_, msm_call_release_run_ready, _data_);
	return FALSE;
	_state_1:
	fso_gsm_call_handler_release_finish (_data_->_tmp2_, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_GSM_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


MsmCallRelease* msm_call_release_construct (GType object_type) {
	MsmCallRelease * self = NULL;
	self = (MsmCallRelease*) fso_gsm_call_release_construct (object_type);
	return self;
}


MsmCallRelease* msm_call_release_new (void) {
	return msm_call_release_construct (TYPE_MSM_CALL_RELEASE);
}


static void msm_call_release_class_init (MsmCallReleaseClass * klass) {
	msm_call_release_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_CALL_RELEASE_CLASS (klass)->run = msm_call_release_real_run;
	FSO_GSM_CALL_RELEASE_CLASS (klass)->run_finish = msm_call_release_real_run_finish;
}


static void msm_call_release_instance_init (MsmCallRelease * self) {
}


GType msm_call_release_get_type (void) {
	return msm_call_release_type_id;
}


GType msm_call_release_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (MsmCallReleaseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) msm_call_release_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MsmCallRelease), 0, (GInstanceInitFunc) msm_call_release_instance_init, NULL };
	msm_call_release_type_id = g_type_module_register_type (module, FSO_GSM_TYPE_CALL_RELEASE, "MsmCallRelease", &g_define_type_info, 0);
	return msm_call_release_type_id;
}


static void msm_call_release_all_real_run_data_free (gpointer _data) {
	MsmCallReleaseAllRunData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (MsmCallReleaseAllRunData, _data_);
}


static void msm_call_release_all_real_run (FsoGsmCallReleaseAll* base, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	MsmCallReleaseAll * self;
	MsmCallReleaseAllRunData* _data_;
	MsmCallReleaseAll* _tmp0_;
	self = (MsmCallReleaseAll*) base;
	_data_ = g_slice_new0 (MsmCallReleaseAllRunData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, msm_call_release_all_real_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, msm_call_release_all_real_run_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	msm_call_release_all_real_run_co (_data_);
}


static void msm_call_release_all_real_run_finish (FsoGsmCallReleaseAll* base, GAsyncResult* _res_, GError** error) {
	MsmCallReleaseAllRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void msm_call_release_all_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	MsmCallReleaseAllRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	msm_call_release_all_real_run_co (_data_);
}


static gboolean msm_call_release_all_real_run_co (MsmCallReleaseAllRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = fso_gsm_theModem;
	_data_->_tmp1_ = fso_gsm_modem_get_callhandler (_data_->_tmp0_);
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->_state_ = 1;
	fso_gsm_call_handler_releaseAll (_data_->_tmp2_, msm_call_release_all_run_ready, _data_);
	return FALSE;
	_state_1:
	fso_gsm_call_handler_releaseAll_finish (_data_->_tmp2_, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((_data_->_inner_error_->domain == FREE_SMARTPHONE_GSM_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


MsmCallReleaseAll* msm_call_release_all_construct (GType object_type) {
	MsmCallReleaseAll * self = NULL;
	self = (MsmCallReleaseAll*) fso_gsm_call_release_all_construct (object_type);
	return self;
}


MsmCallReleaseAll* msm_call_release_all_new (void) {
	return msm_call_release_all_construct (TYPE_MSM_CALL_RELEASE_ALL);
}


static void msm_call_release_all_class_init (MsmCallReleaseAllClass * klass) {
	msm_call_release_all_parent_class = g_type_class_peek_parent (klass);
	FSO_GSM_CALL_RELEASE_ALL_CLASS (klass)->run = msm_call_release_all_real_run;
	FSO_GSM_CALL_RELEASE_ALL_CLASS (klass)->run_finish = msm_call_release_all_real_run_finish;
}


static void msm_call_release_all_instance_init (MsmCallReleaseAll * self) {
}


GType msm_call_release_all_get_type (void) {
	return msm_call_release_all_type_id;
}


GType msm_call_release_all_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (MsmCallReleaseAllClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) msm_call_release_all_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MsmCallReleaseAll), 0, (GInstanceInitFunc) msm_call_release_all_instance_init, NULL };
	msm_call_release_all_type_id = g_type_module_register_type (module, FSO_GSM_TYPE_CALL_RELEASE_ALL, "MsmCallReleaseAll", &g_define_type_info, 0);
	return msm_call_release_all_type_id;
}



